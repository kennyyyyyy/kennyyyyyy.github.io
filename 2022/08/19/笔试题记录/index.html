<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="/images/logo.jpg">
  <title>知识点记录(Unity/C#) | Imperio</title>
  <meta name="author" content="kennyyy" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="C#, Unity" />
  
  <meta name="description" content="Shader 从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果 1234567891011Material material &#x3D; Render.materials;material.shader &#x3D; targetShader;&#x2F;&#x2F;修改 Shader 中参数的值：material.SetFloat(">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点记录(Unity&#x2F;C#)">
<meta property="og:url" content="http://kennyyyyyy.github.io/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Imperio">
<meta property="og:description" content="Shader 从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果 1234567891011Material material &#x3D; Render.materials;material.shader &#x3D; targetShader;&#x2F;&#x2F;修改 Shader 中参数的值：material.SetFloat(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://kennyyyyyy.github.io/images/logo.jpg">
<meta property="article:published_time" content="2022-08-19T14:13:21.000Z">
<meta property="article:modified_time" content="2022-10-09T10:21:33.406Z">
<meta property="article:author" content="kennyyy">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="C#">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://kennyyyyyy.github.io/images/logo.jpg">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" type="text/css" media="all">
  
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Imperio" type="application/atom+xml">
</head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <div class="nav-toggle"><a class="kratos-nav-toggle js-kratos-nav-toggle"><i></i></a></div>
            <header id="kratos-header-section">
                <div class="container">
                    <div class="nav-header">
                        <div class="color-logo"><a href="/">Imperio</a></div>
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>链接</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://imperio.cn">作者</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/kennyyyyyy/kennyyyyyy.github.io">链接</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>Imperio</h2> <br />
                        <span>Boy♂ Next♂ Door~</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        <section class="col-md-8">
    <article>
        <div class="kratos-hentry kratos-post-inner clearfix">
            <header class="kratos-entry-header">
                <h1 class="kratos-entry-title text-center">知识点记录(Unity/C#)</h1>
                
                <ul class="kratos-post-meta text-center">
                    <li><i class="fa fa-calendar"></i> 2022-08-19</li>
                    <li><i class="fa fa-user"></i> 作者 kennyyy</li>
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~21.51K
                        
                        字
                    </li>
                    
                </ul>
            </header>
            <div class="kratos-post-content">
                <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                    本文最后编辑于 <time datetime="1665310893406"></time> 前，其中的内容可能需要更新。
                </div>
                
                    <div class="kratos-post-inner-toc">
                        <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#Shader"><span class="toc-number">1.</span> <span class="toc-text">Shader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#oop%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="toc-number">3.</span> <span class="toc-text">oop的四个特征 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">迭代器和数组的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-number">5.</span> <span class="toc-text">泛型的作用。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E8%AF%AD%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">C#语法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E7%89%B9%E6%80%A7%EF%BC%88Attribute%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">C# 特性（Attribute）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">特殊类</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">反射的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prefab"><span class="toc-number">9.</span> <span class="toc-text">Prefab</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">委托和事件的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%87%E5%90%91%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">万向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">Unity生命周期函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AssetBundle"><span class="toc-number">13.</span> <span class="toc-text">AssetBundle</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#protobuf"><span class="toc-number">14.</span> <span class="toc-text">protobuf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">重写和重载的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86-Heap-%E5%92%8C%E6%A0%88-Stack"><span class="toc-number">16.</span> <span class="toc-text">堆(Heap)和栈(Stack)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GC"><span class="toc-number">17.</span> <span class="toc-text">GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lua"><span class="toc-number">18.</span> <span class="toc-text">Lua</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5"><span class="toc-number">19.</span> <span class="toc-text">网络同步</span></a></li></ol>
                    </div>
                
                <hr />
                <span id="more"></span>
<h5 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h5><ol>
<li><p><strong>从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Material material = Render.materials;</span><br><span class="line">material.shader = targetShader;</span><br><span class="line"><span class="comment">//修改 Shader 中参数的值：</span></span><br><span class="line">material.SetFloat(“参数名”，值); </span><br><span class="line">material.SetColor(“参数名”，颜色值); </span><br><span class="line">material.SetTexture(“参数名”，贴图); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Shader 中参数的值：</span></span><br><span class="line">material.GetFloat(“参数名”);</span><br><span class="line">material.GetColor(“参数名”); </span><br><span class="line">material.GetTexture(“参数名”); </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ol>
<li><p><strong>给定一个数组，有n(n &gt;= 0)个元素，找到数组中第二大的元素</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1 5 9 2 1 6 4 2 3 9</span></span><br><span class="line">	<span class="function"><span class="built_in">int</span> <span class="title">GetScendNum</span>(<span class="params"><span class="built_in">int</span>[] number, <span class="built_in">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> first=number[<span class="number">0</span>],second=number[<span class="number">0</span>];</span><br><span class="line">    		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        		<span class="keyword">if</span>(number[i]&gt;first)&#123;</span><br><span class="line">            		second=first;</span><br><span class="line">            		first=number[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">            		<span class="keyword">if</span>(number[i]&gt;second)</span><br><span class="line">                		second=number[i];</span><br><span class="line">            		<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 若第二和第一相等，则将当前值赋予第二</span></span><br><span class="line">                		second = first==second ? number[i] : second;</span><br><span class="line">            		&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>给定一个可包含重复数字的序列 nums ，按序列内字典升序返回所有不重复的全排列。</strong></p>
<p><strong>其中序列内字典升序指的是， 序列内从左到右的非降序排列，例如 nums=[1,2,3], 则因为[1,2,3] &lt; [1,3,2], [3,1,2] &lt; [3,2,1]， [1,2,3]要先于[1,3,2]输出，[3,1,2]要先于[3,2,1]输出</strong></p>
<ol>
<li><p>使用STL库用来计算排列组合关系的算法：next_permutation和prev_permutation。</p>
<p>即按字典序(lexicographical)来找到下一个或前一个的排列组合。例：{2，1，3}的下一个是{2，3，1}，前一个是{1，3，2}。字典序即两个组合从左往右依次比较，若某一位A比B小，则A的字典序在B之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">UniquePerm</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">    res.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h5 id="oop的四个特征"><a href="#oop的四个特征" class="headerlink" title="oop的四个特征 "></a><strong>oop的四个特征 </strong></h5><p><strong>抽象、封装、继承、多态</strong></p>
<ul>
<li>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。</li>
<li>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。这也体现了大自然中一般与特殊的关系。继承性很好的解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。</li>
<li>封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。</li>
<li><p>多态性是指的是同一接口的不同实现方式，多态允许基类的指针指向子类方法。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p>
<ul>
<li><p>多态的作用：</p>
<ul>
<li>不必编写每一子类的功能调用，可以直接把不同子类当父类看，屏蔽子类间的差异，提高代码的通用率/复用率</li>
</ul>
</li>
</ul>
</li>
<li>父类引用可以调用不同子类的功能，提高了代码的扩充性和可维护性</li>
</ul>
<h5 id="迭代器和数组的区别"><a href="#迭代器和数组的区别" class="headerlink" title="迭代器和数组的区别"></a><strong>迭代器和数组的区别</strong></h5><p>迭代器：<strong>迭代器</strong>（iterator）有时又称<strong>光标</strong>（cursor）是程序设计的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/软件设计模式">软件设计模式</a>，可在容器对象（container，例如<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/链表">链表</a>或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/数组">数组</a>）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lx2054807/article/details/107981276?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107981276-blog-123304449.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107981276-blog-123304449.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=2">C#</a> </p>
<ul>
<li><p>迭代器模式 指按照一定顺序来访问一个集合对象中的每个元素, 但是同时不会暴露集合对象的内部结构. C#中内置的迭代器模式就是Foreach语句, 它可以顺序遍历容器中的每个元素. 而迭代器的具体实现主要是靠IEnumerable 和IEnumerator.</p>
</li>
<li><p><strong>IEnumerator</strong></p>
<p>IEnumerator接口其实就是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=foreach&amp;spm=1001.2101.3001.7020">foreach</a>的具体实现, 它只定义了三个函数, 如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说我们实现一个最简单的IEnumerator接口只需要实现这三个函数即可. MoveNext()表示向集合中的下一个元素移动, 如果有下一个元素返回true, 没有就返回false. Current是一个只读属性, 返回当前迭代器所指元素. Reset()表示重置迭代器到第一个元素.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIEnumerator</span>: <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        count = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个简单的IEnumerator, 如果用Foreach输出, 可以得到从9到0的十个计数. 而具体的实现过程还需要IEnumerable.</p>
</li>
<li><p><strong>IEnumerable</strong></p>
<p>IEnumerable可以粗略的理解为可迭代(遍历)的, 如果接口继承了IEnumerable, 那么就可以使用Foreach语句进行迭代操作. 这个接口只定义了一个函数, 如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数需要返回一个我们刚才定义的IEnumerator, 即告知上层调用方可以枚举.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIEnumerable</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这个时候我们的迭代器已经实现, 可以使用Foreach语句进行迭代操作.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> VARIABLE <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">MyIEnumerable</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(VARIABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在有一个完整的迭代器了, 但是有一个问题, 很多时候我们需要的迭代器并不复杂, 如上面的计数装置, 如果每次都需要实现IEnumerator和IEnumerable十分不方便, 显得头重脚轻, 这时我们可以使用yield.</p>
</li>
<li><p><strong>yield</strong></p>
<p>yield是为了方便使用迭代器而产生的语法糖, 他可以直接使用在返回类型为IEnumerable或IEnumerator的函数中直接实现迭代器操作. 它有两种用法yield break 和yield return (something) 效果和break与return一样. 当使用yield return在foreach语句中进行迭代器操作时, 每一次执行到yield return时都会返回后面定义的something并且记录函数内的信息, 下一次运行时继续.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> VARIABLE <span class="keyword">in</span> <span class="title">myIEnumerable</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(VARIABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable <span class="title">myIEnumerable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  这里我们在i = 5的时候使用了yield break终止了迭代器操作, 如果去掉它, 这个函数就和我们刚才定义的迭代器作用一样, 产生了9到0, 共10个数的倒数.</p>
<ul>
<li><p><strong>协程(coroutine)</strong></p>
<p>除了foreach语句, Unity中另一种迭代器模式就是协程, 它是根据每一次IEnumerator的MoveNext()方法调用进行迭代的, 有些类似于Unity的Update方法. 同时它可以结合Unity的yield return new WaitForSeconds(time)等等接口实行迭代器+定时器模式.<br>使用和停止协程比较简单, 都只要传入IEnumerator就可以.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Coroutine <span class="title">StartCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br></pre></td></tr></table></figure>
<p>使用协程的方法实现我们的从9数到0.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StartCoroutine(myCoroutine());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">myCoroutine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(i);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">myCoroutine(</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  值得注意的是unity里有很多可以和yield结合使用的语句块, 如上的代码不仅实现了从9数到0, 还实现了每隔1秒数一次, 数到0后继续从头开始数, 当然还有很多其他有趣的功能可以通过coroutine和yield实现.</p>
</li>
</ul>
</li>
</ul>
<h5 id="泛型的作用。"><a href="#泛型的作用。" class="headerlink" title="泛型的作用。"></a><strong>泛型的作用。</strong></h5><p><strong>泛型和传统类型Boxing/UnBoxing的区别</strong></p>
<ol>
<li><p>泛型：即通过参数化类型来实现在同一份代码上操作多种数据类型。泛型编程是一种编程范式，它利用“参数化类型”将类型抽象化，从而实现更为灵活的复用。</p>
</li>
<li><p>作用：减少拆装箱，确保类型安全</p>
</li>
<li><p>区别：</p>
<ul>
<li>装箱：值类型转引用类型。开辟一块内存空间进行存放数据。</li>
<li>拆箱：引用类型转值类型。</li>
</ul>
</li>
<li><p>写一个泛型类 C 使其继承自 CBase</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CBase</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">C</span>&lt;<span class="title">T</span>&gt; : <span class="title">CBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">C1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">CBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><ol>
<li><p><strong>当你接手一个新项目，当运行一段时间后，发现内存占用高且帧率低，如何解决</strong></p>
<p>性能优化：</p>
</li>
</ol>
<h5 id="C-语法"><a href="#C-语法" class="headerlink" title="C#语法"></a>C#语法</h5><h6 id="C-特性（Attribute）"><a href="#C-特性（Attribute）" class="headerlink" title="C# 特性（Attribute）"></a><strong>C# 特性（Attribute）</strong></h6><p><strong>特性（Attribute）</strong>是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。</p>
<p><strong>特性（Attribute）</strong>用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：<em>预定义</em>特性和<em>自定义</em>特性。</p>
<p>规定特性（Attribute）的语法如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">attribute(positional_parameters, name_parameter = value, ...)</span>]</span><br><span class="line">element</span><br><span class="line">    </span><br><span class="line"><span class="comment">//特性（Attribute）的名称和值是在方括号内规定的，放置在它所应用的元素之前。</span></span><br><span class="line"><span class="comment">//positional_parameters 规定必需的信息，name_parameter 规定可选的信息。</span></span><br></pre></td></tr></table></figure>
<p><strong>预定义特性（Attribute）</strong></p>
<p>.Net 框架提供了三种预定义特性：</p>
<ul>
<li><p>AttributeUsage：描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。</p>
<p>规定该特性的语法如下：<br>[AttributeUsage( validon, AllowMultiple=allowmultiple，Inherited=inherited)]</p>
<ol>
<li>参数 validon规定特性可被放置的语言元素。它是枚举器AttributeTargets的值的组合。默认值是AttributeTargets.All。</li>
<li>参数allowmultiple(可选的)为该特性的AllowMultiple属性(property)提供一个布尔值。如果为true，则该特性是多用的。默认值是false(单用的)</li>
<li>参数inherited(可选的)为该特性的Inherited 属性(property)提供一个布尔值。如果为true，则该特性可被派生类继承。默认值是false(不被继承)。</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AttributeUsage(AttributeTargets.Class)//只能使用在类上</span></span><br><span class="line"><span class="comment"> * AttributeUsage(AttributeTargets.Method)//只能使用在方法上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//AttributeTargets.Method|AttributeTargets.Class表示可以在类上用也可以在方法上用</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)</span>]<span class="comment">//AllowMultiple =true可以在方法上写多个[C1]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">C1</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">C2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用</span></span><br><span class="line">    [<span class="meta">C1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStr</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Conditional：我们可以将一些函数隔离出来，使得它们只有在定义了某些环节变量或者设置了某个值之后才能发挥作用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若把 #define DEBUG 注释，则Message方法不会执行。即Conditional特性只会只会在其包含的”DEBUG“定义后才能执行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Conditional(<span class="meta-string">&quot;DEBUG&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Message</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass.Message(<span class="string">&quot;In Function 1.&quot;</span>);</span><br><span class="line">        function2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass.Message(<span class="string">&quot;In Function 2.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass.Message(<span class="string">&quot;In Main function.&quot;</span>);</span><br><span class="line">        function1();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Obsolete：它标记了不应被使用的程序实体。当一个新方法被用在一个类中，但若仍然想要保持类中的旧方法，可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Obsolete(</span></span><br><span class="line"><span class="meta">   message</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line">[<span class="meta">Obsolete(</span></span><br><span class="line"><span class="meta">   message,</span></span><br><span class="line"><span class="meta">   iserror</span></span><br><span class="line"><span class="meta">)</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 <em>message</em>，是一个字符串，描述项目为什么过时以及该替代使用什么。</li>
<li>参数 <em>iserror</em>，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">   [<span class="meta">Obsolete(<span class="meta-string">&quot;Don&#x27;t use OldMethod, use NewMethod instead&quot;</span>, true)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OldMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;It is the old method&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;It is the new method&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      OldMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当使用OldMethod方法时，编译器会报错，错误信息为Obsolete的内容</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h6><ol>
<li><p>密封类：不能被继承</p>
<ul>
<li>关键字：sealed</li>
</ul>
</li>
<li><p>接口类：接口定义了所有类继承]接口时应遵循的语法合同</p>
<ul>
<li>Interface</li>
</ul>
</li>
<li><p>抽象类：不能被实例化，可以包含非抽象成员</p>
<ul>
<li><p>abstract</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法只需要声明</span></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">GetName</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 抽象属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h5 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a><strong>反射的作用</strong></h5><p><strong>动态创建一个数据集，并获得其类型T，调用T的Create函数。</strong></p>
<ul>
<li><p>.NET的一个强大功能是它可以通过一种称为反射(reflection)的过程访问应用程序的元数据。简单地说，反射就是运行时查询类型信息的能力。可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。</p>
</li>
<li><p>反射（Reflection）有下列用途：</p>
<ul>
<li>它允许在运行时查看特性（attribute）信息。</li>
<li>它允许审查集合中的各种类型，以及实例化这些类型。</li>
<li>它允许延迟绑定的方法和属性（property）。</li>
<li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>1、反射提高了程序的灵活性和扩展性。</li>
<li>2、降低耦合性，提高自适应能力。</li>
<li>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li>
<li>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Rectangle r = <span class="keyword">new</span> Rectangle(<span class="number">4.5</span>, <span class="number">7.5</span>);</span><br><span class="line">        r.Display();</span><br><span class="line">        Type type = <span class="keyword">typeof</span>(Rectangle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 Rectangle 类的特性</span></span><br><span class="line">        <span class="keyword">foreach</span> (DeBugInfo attributes <span class="keyword">in</span> type.GetCustomAttributes(<span class="literal">false</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != attributes)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Bug no: &#123;0&#125;&quot;</span>, attributes.BugNo);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Developer: &#123;0&#125;&quot;</span>, attributes.Developer);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Last Reviewed: &#123;0&#125;&quot;</span>,</span><br><span class="line">                                         attributes.LastReview);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Remarks: &#123;0&#125;&quot;</span>, attributes.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Prefab"><a href="#Prefab" class="headerlink" title="Prefab"></a>Prefab</h5><p><strong>如何获得Prefab的GameObject类型，PrefabInstance和ModelPrefabInstance的区别</strong></p>
<h5 id="委托和事件的区别"><a href="#委托和事件的区别" class="headerlink" title="委托和事件的区别"></a><strong>委托和事件的区别</strong></h5><ol>
<li><p>委托类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p>
<p>委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 <strong>System.Delegate</strong> 类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明语法</span></span><br><span class="line"><span class="built_in">delegate</span> &lt;<span class="keyword">return</span> type&gt; &lt;<span class="built_in">delegate</span>-name&gt; &lt;parameter list&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestDelegate</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    	num += p;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        num *= q;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    	<span class="comment">// 创建委托实例 ： 新建委托对象，传入函数签名和委托类型一致的函数</span></span><br><span class="line">        NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">        NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);</span><br><span class="line">        <span class="comment">// 使用委托对象调用方法，调用委托，传入参数</span></span><br><span class="line">        nc1(<span class="number">25</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">        nc2(<span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事件（Event）</strong> 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。</p>
<p>C# 中使用事件机制实现线程间的通信。</p>
<p>通过事件使用委托</p>
<ul>
<li><p>事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 <strong>发布器（publisher）</strong> 类。其他接受该事件的类被称为 <strong>订阅器（subscriber）</strong> 类。事件使用 <strong>发布-订阅（publisher-subscriber）</strong> 模型。</p>
</li>
<li><p><strong>发布器（publisher）</strong> 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。</p>
</li>
<li><p><strong>订阅器（subscriber）</strong> 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilerLogHandler</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于上面的委托定义事件， 事件会在生成时调用委托</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> BoilerLogHandler BoilerEventLog;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>区别</p>
<ol>
<li><p>委托</p>
<ul>
<li>Delegate 是一个类，在任何可以声明类的地方都可以声明委托。</li>
<li>可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。</li>
</ul>
</li>
<li><p>事件</p>
<ul>
<li><p>在类的内部，它总是private 的。</p>
</li>
<li><p>在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。</p>
</li>
<li><p>使用事件不仅能获得比委托更好的封装性以外，还能限制含有事件的类型的能力。</p>
</li>
<li><p>事件应该由事件发布者触发，而不应该由事件的客户端（客户程序）来触发。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="万向锁"><a href="#万向锁" class="headerlink" title="万向锁"></a>万向锁</h5><p>万向锁(Gimbal Lock)：一旦选择±90°作为pitch角，就会导致第一次旋转和第三次旋转等价，整个旋转表示系统被限制在只能绕竖直轴旋转，丢失了一个表示维度。</p>
<p>以unity为例：unity中欧拉角的旋转顺序为 y-x-z。即旋转y轴x轴和z轴都改变，旋转x轴z轴改变，旋转z轴其他轴不变。</p>
<p>当模型的x轴的旋转为±90度时，旋转y轴和z轴的效果是一样的，这就是万向锁。此时y轴（惯性坐标系）旋转面和z轴（模型坐标系）旋转面共面</p>
<p><img src="/images/笔试题记录/image-20221005214034031.png" alt></p>
<p>因为计算机每次执行旋转都是从[0, 0, 0]开始进行，且y轴旋转的优先级最高，此时y轴的模型坐标系和惯性坐标系的重合，因此y轴的旋转从结果上看就是惯性坐标系的旋转。</p>
<h5 id="Unity生命周期函数"><a href="#Unity生命周期函数" class="headerlink" title="Unity生命周期函数"></a><strong>Unity生命周期函数</strong></h5><p>Awake -&gt; OnEnable -&gt; Start -&gt; FixedUpdate -&gt; OnTrigger/OnCollision -&gt; 输入事件 -&gt; Update -&gt;  LateUpdate -&gt; 渲染(Scene -&gt; Gizmo -&gt; GUI) -&gt; OnDisable -&gt; OnDestroy</p>
<h5 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a><strong>AssetBundle</strong></h5><p>AssetBundle是Unity中的一种资源包，这种资源包可以是游戏内要用到的几乎所有资源，并且可以在运行时动态加载。</p>
<ol>
<li>卸载Load的asset资源，通过Resources.UnloadAsset(asset)来进行卸载；</li>
<li><p>压缩格式：LZMA, LZ4, 以及不压缩。</p>
<ol>
<li>LZMA是一种默认的压缩形式，这种标准压缩格式是一个单一LZMA流序列化数据文件，并且在使用前需要解压缩整个包体。能使压缩后文件达到最小，但是解压相对缓慢。</li>
<li>LZ4能使得压缩量更大，而且在使用资源包前不需要解压整个包体。</li>
<li>不压缩的方式打包后包体会很大，导致很占用空间</li>
</ol>
</li>
<li><p><strong>AssetBundle的卸载和加载</strong></p>
<ul>
<li><p>加载</p>
<ol>
<li><p>AssetBundle.LoadFromFile：从本地加载</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundle ab = AssetBundle.LoadFromFile(<span class="string">&quot;ab包名字/所在目录/资源名称.后缀&quot;</span>);</span><br><span class="line">    GameObject gameObj= ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;资源名称&quot;</span>);</span><br><span class="line">    Instantiate(gameObj);   <span class="comment">//实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AssetBundle.LoadFromMemory：从内存加载</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundle ab = AssetBundle.LoadFromMemory(File.ReadAllBytes(<span class="string">&quot;ab包名字/所在目录/资源名称.后缀&quot;</span>));</span><br><span class="line">    GameObject gameObj= ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;资源名称&quot;</span>);</span><br><span class="line">    Instantiate(gameObj);   <span class="comment">//实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AssetBundle.LoadFromMemoryAsync：从内存异步加载</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundleCreateRequest request = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(<span class="string">&quot;ab包名字/所在目录/资源名称.后缀&quot;</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line">    AssetBundle ab = request.assetBundle;</span><br><span class="line">    GameObject obj = ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;资源名称&quot;</span>);</span><br><span class="line">    Instantiate(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从AB中加载资源</p>
<p>AssetBundle.LoadAsset(assetName) ：加载AB包中的指定对象，不包含依赖的包  AssetBundle.LoadAllAssets() ：加载AB包中所有的对象，不包含依赖的包  AssetBundle.LoadAssetAsync() ：异步加载，加载较大资源的时候  AssetBundle.LoadAllAssetsAsync() ：异步加载全部资源  AssetBundle.LoadAssetWithSubAssets() ：加载资源及其子资源</p>
</li>
</ol>
</li>
<li><p>卸载</p>
<ul>
<li>AssetBundle.Unload(true)：卸载所有资源，包含其中正被使用的资源  </li>
<li>AssetBundle.Unload(false)：卸载所有没被使用的资源 </li>
<li>Resources.UnloadUnusedAssets()：卸载未使用的资源</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a><strong>protobuf</strong></h5><h5 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a><strong>重写和重载的区别</strong></h5><p>​    1.定义不同—-重载是定义相同的方法名，参数不同；重写是子类重写父类的方法。</p>
<p>​    2.范围不同—-重载是在一个类中，重写是子类与父类之间的。</p>
<p>​    3.多态不同—-重载是编译时的多态性，重写是运行时的多态性。</p>
<p>​    4.返回不同—-重载对返回类型没有要求，而重写要求返回类型，有兼容的返回类型。</p>
<p>​    5.参数不同—-重载的参数个数、参数类型、参数顺序可以不同，而重写父子方法参数必须相同。</p>
<p>​    6.修饰不同—-重载对访问修饰没有特殊要求，重写访问修饰符的限制一定要大于被重写方法的访问修.</p>
<h5 id="堆-Heap-和栈-Stack"><a href="#堆-Heap-和栈-Stack" class="headerlink" title="堆(Heap)和栈(Stack)"></a><strong>堆(Heap)和栈(Stack)</strong></h5><ol>
<li><p>程序内存</p>
<ul>
<li><p>栈：由操作系统自动分配释放，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。：堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。</p>
</li>
<li><p>区别：</p>
<ul>
<li>管理方式不同。栈自动释放；堆手动释放，容易产生内存泄漏</li>
<li>空间大小不同。栈 &lt;&lt; 堆。</li>
<li>生长方向不同。堆的内存地址由低到高；栈的内存地址由高到低。</li>
<li>分配方式不同。堆都是动态分配的；栈有静态分配和动态分配。</li>
</ul>
</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li>栈：线性表。先进后出(First In Last Out).</li>
<li>堆：树形结构，是一种特殊的完全二叉树。满足所有节点的值总是不大于或不小于父节点的值的完全二叉树。根节点最大称为大顶堆，根节点最小称为小顶堆。</li>
</ul>
</li>
<li><p>值类型存储在栈中；引用类型存储在堆上。</p>
</li>
</ol>
<h5 id="GC"><a href="#GC" class="headerlink" title="GC"></a><strong>GC</strong></h5><p>​    什么是GC：即Garbage Collection，垃圾回收。当使用可用内存不能满足内存请求时，GC会自动进行。</p>
<ol>
<li><p><strong>C#</strong>中的GC</p>
<ol>
<li><p>GC的四个步骤。</p>
<ul>
<li><p>垃圾回收器搜索内存中的托管对象；</p>
</li>
<li><p>从托管代码中搜索被引用的对象并标记为有效；</p>
</li>
<li><p>释放没有被标记为有效的对象并收回内存；</p>
</li>
<li><p>整理内存将有效对象挪动到一起。</p>
</li>
</ul>
</li>
<li><p>GC的作用：</p>
<ul>
<li><p>提高软件系统的内聚。</p>
</li>
<li><p>降低编程复杂度，使程序员不必分散精力去处理析构。</p>
</li>
<li><p>不妨碍设计师进行系统抽象。</p>
</li>
<li><p>减少由于内存运用不当产生的Bug。</p>
</li>
<li><p>成功的将内存管理工作从程序的编写时，脱离至运行时，使不可预估的管理漏洞变为可预估的。</p>
</li>
</ul>
</li>
<li><p>什么是垃圾</p>
<p>只要判定一个引用类型对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。</p>
</li>
<li><p>对象代龄</p>
<p>CLR初始化后的第一批被创建的对象被列为0代对象。</p>
</li>
<li><p>回收方法</p>
<ul>
<li><p>Finalizer(析构函数)：一般不用，因为不确定GC调用时间，影响效率。</p>
</li>
<li><p>Dispose：继承IDisposable接口，实现Dispose方法；调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。’</p>
</li>
<li><p>Mark-Compact 标记压缩算法</p>
</li>
<li><p>Generational 分代算法</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>Unity</strong>中的CG</p>
<ol>
<li>Boehm GC(非分代非压缩)<ol>
<li>Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGen GC的设计思想）。</li>
<li>Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。 </li>
</ol>
</li>
<li>降低GC的方法：<ol>
<li>使用对象池</li>
<li>减少string，使用StringBuilder</li>
<li>减少拆装箱</li>
<li>struct中不要有引用类型变量</li>
<li>主动调用GC</li>
</ol>
</li>
</ol>
</li>
<li><p>三色标记清除法</p>
<ol>
<li>三色：黑色、灰色、白色<ul>
<li><code>黑色</code>: <strong>表示对象以及被垃圾收集器访问过，且这个对象的引用都已经扫描过</strong>。黑色的对象代表以及扫描过，他是安全存活的，如果有其他对象引用指向了黑色对象，无需重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li><code>灰色</code>: <strong>表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描到</strong></li>
<li><code>白色</code>: <strong>表示对象尚未被垃圾收集器访问过</strong>。显然在可达性分析刚刚开始的阶段，所有的对象都是白色，如在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
</ul>
</li>
<li>步骤：<ol>
<li>刚开始，所有对象都在<code>白色集合</code>中</li>
<li>将GC Roots直接引用的对象挪到<code>灰色集合</code>中</li>
<li>从<code>灰色集合</code>中获取对象：<ul>
<li>将本对象的引用到的对象放入<code>灰色集合</code>中</li>
<li>将本对象放入<code>黑色集合</code>中</li>
</ul>
</li>
<li>重复步骤3，直到<code>灰色集合</code>为空结束</li>
<li>结束后，仍在<code>白色集合</code>的对象即为GC Roots不可达，可以进行回收。</li>
</ol>
</li>
</ol>
</li>
<li><p>三代标记清除法</p>
</li>
</ol>
<h5 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a><strong>Lua</strong></h5><ol>
<li><p>pairs和ipairs</p>
<ul>
<li><p>同：都能遍历集合，均按优先顺序输出没有key的值</p>
</li>
<li><p>异：对于又key的值</p>
<p><strong>ipairs</strong>从第一个数字key开始，依次输出所有的key+1的键值，遇到字母下标不会结束遍历，但不输出，如果遇到nil则退出；<br><strong>pairs</strong>无序输出字母类型key或者数字类型key的键值，遇到nil不输出，也不会停止遍历。</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span> = &#123; [<span class="number">1</span>] = <span class="string">&quot;test3&quot;</span>, [<span class="number">2</span>] = <span class="string">&quot;val1&quot;</span> , [<span class="number">5</span>] = <span class="string">&quot;val2&quot;</span>, [<span class="number">4</span>] = <span class="string">&quot;val4&quot;</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------ipairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------pairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--输出</span></span><br><span class="line"><span class="comment">-----------ipairs----------------</span></span><br><span class="line"><span class="number">1</span>       test3</span><br><span class="line"><span class="number">2</span>       val1</span><br><span class="line"><span class="comment">-----------pairs----------------</span></span><br><span class="line"><span class="number">4</span>       val4</span><br><span class="line"><span class="number">1</span>       test3</span><br><span class="line"><span class="number">2</span>       val1</span><br><span class="line"><span class="number">5</span>       val2</span><br><span class="line"><span class="comment">--结论</span></span><br><span class="line"><span class="number">1</span>、<span class="built_in">ipairs</span>会按照key的顺序输出数据，遇到不连续的数据停止输出；</span><br><span class="line"><span class="number">2</span>、<span class="built_in">pairs</span>会无序输出所有数据；</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span> = &#123; [<span class="number">3</span>] = <span class="string">&quot;test3&quot;</span>, [<span class="string">&quot;test&quot;</span>] = <span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val3&quot;</span> , [<span class="number">4</span>] = <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val4&quot;</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------ipairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------pairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--输出</span></span><br><span class="line"><span class="comment">-----------ipairs----------------</span></span><br><span class="line"><span class="number">1</span>	val3</span><br><span class="line"><span class="number">2</span>	val4</span><br><span class="line"><span class="number">3</span>	test3</span><br><span class="line"><span class="number">4</span>	val2</span><br><span class="line"><span class="comment">-----------pairs----------------</span></span><br><span class="line"><span class="number">1</span>	val3</span><br><span class="line"><span class="number">2</span>	val4</span><br><span class="line"><span class="number">4</span>	val2</span><br><span class="line">test	val1</span><br><span class="line"><span class="number">3</span>	test3</span><br><span class="line"></span><br><span class="line"><span class="comment">--结论</span></span><br><span class="line"><span class="number">1</span>、<span class="built_in">pairs</span>和<span class="built_in">ipairs</span>均优先输出没有key的value；</span><br><span class="line"><span class="number">2</span>、<span class="built_in">pairs</span>会输出所有的数据，不带key的值按顺序输出，带key的值无序输出；</span><br><span class="line"><span class="number">3</span>、<span class="built_in">ipairs</span>会跳过字符串的key，按顺序输出数字型key的值；</span><br></pre></td></tr></table></figure>
</li>
<li><p>__index和__newindex</p>
<ul>
<li><p>__index：(get)当在表中找不到元素时，lua会从 __index指向的表查找元素或获得方法的返回值。</p>
</li>
<li><p>__newindex：(set)对表中不存在的值进行赋值时调用。</p>
<p>当__newindex指向一个函数时，会执行该函数，且对本表的创建不成功；</p>
<p>当__newindex指向一个表时，会对指向的表进行操作，且对本表创建不成功。</p>
</li>
</ul>
</li>
<li><p>__rawset和 __rawget</p>
<p>可以通过rawset和rawget操作绕过原表这一过程(__index和__newindex)，直接把这个表相应的结论输出。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> table1 = &#123; x = <span class="string">&quot;val1&quot;</span> &#125;</span><br><span class="line"><span class="keyword">local</span> table2 = &#123; y = <span class="string">&quot;val2&quot;</span> &#125;</span><br><span class="line"><span class="keyword">local</span> table3 = &#123; z = <span class="string">&quot;val3&quot;</span> &#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(table1, &#123;<span class="built_in">__index</span> = table2, <span class="built_in">__newindex</span> = table3&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(table1.y)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(table1, <span class="string">&quot;y&quot;</span>))  </span><br><span class="line"></span><br><span class="line">table1.newN = <span class="string">&quot;newN&quot;</span></span><br><span class="line"><span class="built_in">print</span>(table1.newN)</span><br><span class="line"><span class="built_in">print</span>(table3.newN)</span><br><span class="line"></span><br><span class="line"><span class="built_in">rawset</span>(table1, <span class="string">&quot;newN&quot;</span>, <span class="string">&quot;newZ&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(table1.newN)</span><br><span class="line"></span><br><span class="line"><span class="comment">--输出--</span></span><br><span class="line">val2</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">newN</span><br><span class="line">newZ</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>a</li>
</ol>
<h5 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h5><p>​    网络同步的目标时保证多台机器的游戏表现完全一致</p>
<ol>
<li><p>帧同步</p>
<ol>
<li>原理：<ul>
<li>帧同步的战斗逻辑在客户端；</li>
<li>在帧同步下，服务端只转发操作，不做任何逻辑处理；</li>
<li>客户端按照一定的帧速率（逻辑帧）去上传当前的操作指令，服务端将操作指令广播给所有客户端；</li>
<li>当客户端收到指令后执行本地代码，如果输入的指令一致，计算的过程一致，那么计算的结果肯定是一致的，这样就能保证所有客户端的同步，这就是帧同步。</li>
</ul>
</li>
<li>缺点：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     <ul>
<li>由于帧同步战斗逻辑都在客户端，服务器没有验证，外挂成本低（加速、透视、自动瞄准、数据修改等）；</li>
<li>网络条件较差的客户端会影响其他玩家的游戏体验。（优化方案：乐观帧锁定、渲染与逻辑帧分离、客户端预执行、指令流水线化、操作回滚等）；</li>
<li>不同机器浮点数精度问题、容器排序不确定性、RPC时序、随机数值计算不统一。</li>
</ul>
</li>
<li>乐观帧锁定：</li>
</ol>
</li>
<li><p>状态同步</p>
<ol>
<li><p>原理：</p>
<ul>
<li><p>状态同步的战斗逻辑在服务端；</p>
</li>
<li><p>在状态同步下，客户端更像是一个服务端数据的表现层；</p>
</li>
<li><p>一般流程：</p>
</li>
<li><ul>
<li>客户端上传操作到服务器；</li>
<li>服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态；</li>
<li>客户端收到状态后再根据状态显示内容。</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>状态同步的回放实现较为复杂；</li>
<li>延迟过大、客户端性能浪费、服务端压力大；</li>
<li>对带宽的浪费。对于对象少的游戏，可以用快照保存整个游戏的状态发送，但一旦数量多起来，数量的占用就会直线上升。（优化：增量快照同步，协议同步指定数据）</li>
</ul>
</li>
</ol>
</li>
<li><p>区别</p>
<table border="1">
    <tr>
        <th>属性</th>
        <th>状态同步</th>
        <th>帧同步</th>
    </tr>
    <tr>
        <td>流量</td>
        <td>相对高</td>
        <td>相对低</td>
    </tr>
    <tr>
        <td>回放</td>
        <td>记录文件大，且实现相对复杂</td>
        <td>记录文件小，且相对容易实现</td>
    </tr>
        <tr>
        <td>安全性</td>
        <td>服务器实现逻辑，安全性高</td>
        <td>逻辑在客户端，防作弊难度高</td>
    </tr>
    <tr>
        <td>服务器压力</td>
        <td>逻辑在服务端，压力大</td>
        <td>小</td>
    </tr>
    <tr>
        <td>战斗校验</td>
        <td></td>
        <td>服务端可以重跑一遍战斗</td>
    </tr>
    <tr>
        <td>网络卡顿表现</td>
        <td>瞬移，回位</td>
        <td>卡顿</td>
    </tr>
</table>
</li>
<li><p>表现优化</p>
<p>表现优化用于弱化玩家对延迟的感受。</p>
<ol>
<li>插值优化：客户端采用插值，避免位置突变</li>
<li>客户端预测+回滚</li>
</ol>
</li>
</ol>

            </div>
            
                <div class="kratos-copyright text-center clearfix">
                    <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
                </div>
            
            <footer class="kratos-entry-footer clearfix">
                
                    <div class="post-like-donate text-center clearfix" id="post-like-donate">
                    
                    
                        <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                        <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://kennyyyyyy.github.io/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://kennyyyyyy.github.io/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/";
            const title         = "「知识点记录(Unity/C#)」";
            const excerpt       = `
Shader
从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果
1234567891011Material material = R...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                    
                    </div>
                
                <div class="footer-tag clearfix">
                    <div class="pull-left">
                    <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/C/" rel="tag">C#</a>, <a class="tag-none-link" href="/tags/Unity/" rel="tag">Unity</a>
                    </div>
                    <div class="pull-date">
                    <span>最后编辑：2022-10-09</span>
                    </div>
                </div>
            </footer>
        </div>
        
            <nav class="navigation post-navigation clearfix" role="navigation">
                
                <div class="nav-previous clearfix">
                    <a title=" 热更新" href="/2022/08/16/热更新/">&lt; 上一篇</a>
                </div>
                
                
                <div class="nav-next clearfix">
                    <a title=" C/C++相关记录" href="/2022/09/21/C-C-相关记录/">下一篇 &gt;</a>
                </div>
                
            </nav>
        
        
    </article>
</section>

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.jpg" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">Deep♂ Dark♂ Fantasy♂</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#Shader"><span class="toc-text">Shader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#oop%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="toc-text">oop的四个特征 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">迭代器和数组的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-text">泛型的作用。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E8%AF%AD%E6%B3%95"><span class="toc-text">C#语法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E7%89%B9%E6%80%A7%EF%BC%88Attribute%EF%BC%89"><span class="toc-text">C# 特性（Attribute）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB"><span class="toc-text">特殊类</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">反射的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prefab"><span class="toc-text">Prefab</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">委托和事件的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%87%E5%90%91%E9%94%81"><span class="toc-text">万向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-text">Unity生命周期函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AssetBundle"><span class="toc-text">AssetBundle</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#protobuf"><span class="toc-text">protobuf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">重写和重载的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86-Heap-%E5%92%8C%E6%A0%88-Stack"><span class="toc-text">堆(Heap)和栈(Stack)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GC"><span class="toc-text">GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lua"><span class="toc-text">Lua</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5"><span class="toc-text">网络同步</span></a></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/C/" style="font-size: 0.73em;">C#</a> <a href="/tags/C/" style="font-size: 0.6em;">C++</a> <a href="/tags/C-C/" style="font-size: 0.6em;">C/C++</a> <a href="/tags/Leetcode/" style="font-size: 0.6em;">Leetcode</a> <a href="/tags/Lua/" style="font-size: 0.67em;">Lua</a> <a href="/tags/Unity/" style="font-size: 0.8em;">Unity</a> <a href="/tags/c/" style="font-size: 0.6em;">c++</a> <a href="/tags/unity/" style="font-size: 0.67em;">unity</a> <a href="/tags/xlua/" style="font-size: 0.6em;">xlua</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 0.6em;">图形学</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 0.6em;">学习</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.6em;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.6em;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.6em;">数据结构</a> <a href="/tags/%E7%BB%8F%E9%AA%8C/" style="font-size: 0.67em;">经验</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.6em;">计算机网络</a> <a href="/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/" style="font-size: 0.67em;">错误总结</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/10/07/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"><i class="fa  fa-book"></i> 3D数学基础：图形与游戏开发</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/09/22/%E5%85%AB%E8%82%A1/"><i class="fa  fa-book"></i> 操作系统/计网/数据库</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/09/21/C-C-%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/"><i class="fa  fa-book"></i> C/C++相关记录</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/"><i class="fa  fa-book"></i> 知识点记录(Unity/C#)</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/"><i class="fa  fa-book"></i> 热更新</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  >
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 Imperio 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by kennyyy.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>

<script async src="/js/candy.min.js"></script>


    <script defer src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>