<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Imperio</title>
  
  <subtitle>Boy♂ Next♂ Door~</subtitle>
  <link href="http://kennyyyyyy.github.io/atom.xml" rel="self"/>
  
  <link href="http://kennyyyyyy.github.io/"/>
  <updated>2022-10-07T12:05:39.460Z</updated>
  <id>http://kennyyyyyy.github.io/</id>
  
  <author>
    <name>kennyyy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3D数学基础：图形与游戏开发</title>
    <link href="http://kennyyyyyy.github.io/2022/10/07/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    <id>http://kennyyyyyy.github.io/2022/10/07/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</id>
    <published>2022-10-07T11:38:59.000Z</published>
    <updated>2022-10-07T12:05:39.460Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="2、笛卡尔坐标系"><a href="#2、笛卡尔坐标系" class="headerlink" title="2、笛卡尔坐标系"></a>2、笛卡尔坐标系</h4><h4 id="3、多坐标系"><a href="#3、多坐标系" class="headerlink" title="3、多坐标系"></a>3、多坐标系</h4><h5 id="3-2-一些有用的坐标系"><a href="#3-2-一些有用的坐标系" class="headerlink" title="3.2 一些有用的坐标系"></a>3.2 一些有用的坐标系</h5><h6 id="3-2-1-世界坐标系"><a href="#3-2-1-世界坐标系" class="headerlink" title="3.2.1 世界坐标系"></a>3.2.1 世界坐标系</h6><p>​    世界坐标系建立了描述其他坐标系所需要的参考框架，能够用世界坐标系描述其他坐标系的位置，而不能用更大的、外部的坐标系来描述世界坐标系。</p><p>​    世界坐标系的典型问题都是关于<strong>初始位置和环境</strong>的，如：</p><ul><li>每个物体的位置和方向；</li><li>摄像机的位置和方向；</li><li>世界中没一点的地形是什么（如山丘、湖泊等）；</li><li>个物体从哪里来，到哪里去（NPC的运动策略）。</li></ul><h6 id="3-2-2-物体坐标系"><a href="#3-2-2-物体坐标系" class="headerlink" title="3.2.2 物体坐标系"></a>3.2.2 物体坐标系</h6><p>​    物体坐标系是特定物体相关联的坐标系，每个物体都有独立的坐标系，当物体移动或改变方向时，该物体相关联的坐标系也会移动或改变方向。</p><p>​    世界坐标系也叫模型坐标系。</p><ul><li>周围有需要相互作用的物体吗？（我要攻击他吗？）</li><li>哪个方向？前面？左边？</li></ul><h6 id="3-2-3-摄像机坐标系"><a href="#3-2-3-摄像机坐标系" class="headerlink" title="3.2.3 摄像机坐标系"></a>3.2.3 摄像机坐标系</h6><p>​    摄像机坐标系是和观察者密切相关的坐标系。可以被看做是一种特殊的“物体“坐标系，该”物体“坐标系定义在摄像机的屏幕可视区域。</p><ul><li>3D空间中的给定点在摄像机前方吗？</li><li>某个物体是否在屏幕上？</li><li>两个物体，谁在前？</li></ul><h6 id="3-2-4-惯性坐标系"><a href="#3-2-4-惯性坐标系" class="headerlink" title="3.2.4 惯性坐标系"></a>3.2.4 惯性坐标系</h6><p>​    为了简化世界坐标系到物体坐标系的转换，引入的新的坐标系。惯性坐标系的原点和物体坐标系的原点重合，轴和世界坐标系的轴平行。</p><p>​    从世界坐标系到惯性坐标系只需要平移，从惯性坐标系到物体坐标系只需要旋转。</p><h4 id="4、向量与标量"><a href="#4、向量与标量" class="headerlink" title="4、向量与标量"></a>4、向量与标量</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;2、笛卡尔坐标系&quot;&gt;&lt;a href=&quot;#2、笛卡尔坐标系&quot; class=&quot;headerlink&quot; title=&quot;2、笛卡尔坐标系&quot;&gt;&lt;/a&gt;2、笛卡尔坐标系&lt;/h4&gt;&lt;h4 id=&quot;3、多坐标系&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="图形学" scheme="http://kennyyyyyy.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统/计网/数据库</title>
    <link href="http://kennyyyyyy.github.io/2022/09/22/%E5%85%AB%E8%82%A1/"/>
    <id>http://kennyyyyyy.github.io/2022/09/22/%E5%85%AB%E8%82%A1/</id>
    <published>2022-09-22T09:33:32.000Z</published>
    <updated>2022-09-27T09:31:54.766Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><hr><h6 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h6><ul><li>进程：一个在内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。</li><li>线程：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</li><li>区别<ul><li>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</li><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</li><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。</li></ul></li></ul><h6 id="谷歌浏览器为什么是多进程"><a href="#谷歌浏览器为什么是多进程" class="headerlink" title="谷歌浏览器为什么是多进程"></a>谷歌浏览器为什么是多进程</h6><ul><li>浏览器存在单进程架构和多进程架构</li><li>单进程架构<ul><li>所有的功能模块都是运行在同一个进程里的。可能会导致 不稳定、不流畅、不安全。</li></ul></li><li>对进程架构<ul><li>具备更好的容错性，提供安全性和沙盒性。</li><li>谷歌浏览器的进程：<ul><li>浏览器进程（Browser Process），浏览器的主进程，负责包括地址栏、前进后退按钮、处理网络访问、文件访问等。</li><li>渲染进程（Renderer Process），控制显示网站的选项卡内的所有内容。</li><li>插件进程（Plugin Process），控制网站使用的所有插件。</li><li>GPU（GPU Process），与其他进程隔离处理GPU任务，由于GPU处理来自多个应用程序的请求并将它们绘制在同一表面上，因此将其分为不同的过程。</li><li>网络进程（NetWork Process），负责页面的网络资源加载，之前是放在浏览器进程中的一个线程运行，现在独立出来。</li></ul></li></ul></li></ul><h4 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h4><ul><li><p>流媒体传输协议</p></li><li><p>传输层协议：</p><ul><li><p>TCP：面向连接的、可靠的、基于字节流的</p><p>SYN：同步序列号；ACK：确认字符；seq：序列号</p><ul><li><p>三次握手：</p><ol><li>Client =&gt; Server : SYN = 1, seq = x</li><li>Server =&gt; Client : SYN = 1, ACK = 1, seq = y, ack = x + 1</li><li>Client =&gt; Server : ACK = 1, seq = x + 1, ack = y + 1</li></ol></li><li><p>四次挥手：</p><ol><li>Client =&gt; Server : FIN = 1, seq = x</li><li>Server =&gt; Cilent : ACK = 1, seq = y, ack = x + 1</li><li>Server =&gt; Client : FIN = 1, ACK = 1, seq = z, ack = x + 1；服务端关闭</li><li>Client =&gt; Server : ACK = 1, seq = x + 1, ack = z + 1</li><li>等待两倍报文最大生存时间后客户端关闭</li></ol></li></ul></li><li><p>UDP：无连接的、不可靠的、面向数据报的</p></li><li><p>区别：</p><ul><li>TCP是一对一的传输，UDP支持一对一、一对多、多对多的交互通信</li><li>TCP首部长度长，开销较大；UDP首部8个字节，固定不变，开销较小</li></ul></li></ul></li><li><p>Socket通信：</p><ol><li><p>流程：服务端监听，客户端请求，确认连接进行通信</p></li><li><p>c++下的Socket</p><ol><li><p>创建Socket</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">af:一个地址家族，通常为AF_INET</span></span><br><span class="line"><span class="comment">type:套接字类型，SOCK_STREAM表示创建面向流连接的套接字;为SOCK_DGRAM，表示创建面向无连接的数据包套接字;为SOCK_RAW，表示创建原始套接字.</span></span><br><span class="line"><span class="comment">protocol:套接字所用协议，不指定可以设置为0</span></span><br><span class="line"><span class="comment">返回值就是一个socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">int</span> ytpe, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>绑定端口和地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockeSrv为socket；addrSrv为结构体指针，包含端口和IP地址信息；第三个参数为缓冲区长度，一般为sizeof计算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_family = AF_INET;</span><br><span class="line">addrSrv.sin_port = <span class="built_in">htons</span>(<span class="number">8088</span>); <span class="comment">//1024~65535中的端口号</span></span><br><span class="line">addrSrv.sin_addr.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;154.152.70.22&quot;</span>); </span><br><span class="line"><span class="comment">//通过inet_addr函数将字符串转化为整型(in_addr_t)</span></span><br><span class="line"><span class="built_in">bind</span>(sockSrv, (LPSOCKADDR)&amp;addrSrv, <span class="built_in"><span class="keyword">sizeof</span></span>(SOCKADDR_IN));</span><br></pre></td></tr></table></figure></li><li><p>服务端监听</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1:socket</span></span><br><span class="line"><span class="comment">2:等待连接队列长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">listen</span>(sockSrv, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>服务端接收客户端请求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1：socekt</span></span><br><span class="line"><span class="comment">2:包含客户端端口IP信息的sockaddr_in结构体指针</span></span><br><span class="line"><span class="comment">3：接收参数addr的长度</span></span><br><span class="line"><span class="comment">返回值为socket。可以在客户端和服务端接受和发送数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">accept</span>(sockSrv, (SOCKADDR*)&amp;addrClient, <span class="built_in"><span class="keyword">sizeof</span></span>(SOCKADDR));</span><br></pre></td></tr></table></figure></li><li><p>关闭连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">colsesocket</span><span class="params">(SOCKET s)</span></span></span><br></pre></td></tr></table></figure></li><li><p>客户端发送连接请求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1:socket</span></span><br><span class="line"><span class="comment">2:结构体执政，包括主机的IP地址</span></span><br><span class="line"><span class="comment">3：缓冲区大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">connect</span>(sockCLient, (SOCKADDR*)&amp;addrSrv, <span class="built_in"><span class="keyword">sizeof</span></span>(addrSrv));</span><br></pre></td></tr></table></figure></li><li><p>接收消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1: 建立好连接的socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">recv</span>(sockClient, buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>发送消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">send</span>(sockClient, buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ul><h4 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h4><ul><li><p>数据对齐</p><p>1.数据或结构体、类中的数据成员的存储起始地址为有效对齐值N的倍数。</p><p>2.结构体或类或联合体最终的大小应为有效对齐值N的倍数（圆整）。</p><p>基本数据类型</p><p>char: 1；short：2；int：4；float：4；long：4；long long：8；double：8；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cl</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> aa;</span><br><span class="line">    <span class="keyword">short</span> aaa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sizeof(Cl) = 12</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> aa;</span><br><span class="line">    <span class="keyword">int</span> aaa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sizeof(c2) = 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> aa;</span><br><span class="line">    <span class="keyword">double</span> aaa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sizeof(c3) = 16;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> aa;</span><br><span class="line">    <span class="keyword">short</span> aaa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sizeof(c4) = 24;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li><p>关系型数据库：</p><ul><li><p>优点：</p><ul><li>结构简单、易于维护：都是使用表结构，格式一致；数据库设计和规范化过程也简单易行和易于理解。</li><li>使用方便、灵活：使用标准查询语言SQL，允许用户几乎毫无差别地从一个产品到另一个产品存取信息。与关系数据库接口的应用软件具有相似的程序访问机制，提供大量标准的数据存取方法。</li><li>复杂操作：可以进行join等复杂查询；</li><li>保持数据的一致性；</li><li>由于以标准为前提，数据更新的开销小（相同的字段基本都是只有一处）；</li><li>存在很多实际成果和专业技术信息（成熟的技术）。</li></ul></li><li><p>缺点：</p><ul><li>数据类型表达能力差：关系数据模型不直接支持复杂的数据类型。</li><li>复杂读写功能差。</li><li>支持长事务能力差：由于RDBMS记录锁机制的颗粒度限制，对于支持多种记录类型的大段数据的登记和查询来说，简单的记录级的锁机制是不够</li><li>环境应变能力差：在要求系统频繁改变的环境下，关系系统的成本高且修改困难。</li><li>读写性能：面对海量数据的高并发读写需求，效率就会变得很差，硬盘I/O是一个很大的瓶颈；</li><li>扩展方式：固定的表结构，灵活度稍欠，如字段不固定时的应用；</li></ul></li><li><p>存储过程：</p><ul><li><p>优点：</p><p>1、重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。</p><p>2、减少网络流量：存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。</p><p>3、安全性：参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。</p></li><li><p>缺点：</p><p>1、更改比较繁琐：如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则仍需要更新程序集中的代码以添加参数、更新 GetValue() 调用。</p><p>2、可移植性差：由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。如果应用程序的可移植性在您的环境中非常重要，则需要将业务逻辑封装在不特定于 RDBMS 的中间层中。</p></li></ul></li></ul></li></ul><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/composite">设计模式</a></li><li><a href="https://gpp.tkchu.me/introduction.html">游戏设计模式</a></li></ul><h4 id="图形学-大概"><a href="#图形学-大概" class="headerlink" title="图形学(大概)"></a>图形学(大概)</h4><ul><li><p><a href="https://www.freesion.com/article/97131313052/">mipmap</a>：<strong>多级渐远纹理</strong></p><p>一系列的纹理图像，后一个纹理图像是前一个的二分之一。</p><p>当物体距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个纹理。</p><ul><li></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h4&gt;&lt;hr&gt;
&lt;h6 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; clas</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://kennyyyyyy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="计算机网络" scheme="http://kennyyyyyy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="数据库" scheme="http://kennyyyyyy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C/C++相关记录</title>
    <link href="http://kennyyyyyy.github.io/2022/09/21/C-C-%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2022/09/21/C-C-%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/</id>
    <published>2022-09-21T12:09:10.000Z</published>
    <updated>2022-09-21T13:57:40.978Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h6 id="C中如何调用C-函数"><a href="#C中如何调用C-函数" class="headerlink" title="C中如何调用C++函数"></a>C中如何调用C++函数</h6><ol><li><p>对于非成员函数，将 C++ 函数声明为 <code>extern &quot;C&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ code</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">f</span>(i);</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于成员函数，需要简单包装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">double</span> <span class="title">call_C_f</span><span class="params">(C* p, <span class="keyword">int</span> i)</span> <span class="comment">// wrapper function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;<span class="built_in">f</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c code</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">call_C_f</span><span class="params">(struct C* p, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(struct C* p, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="built_in">call_C_f</span>(p, i);</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若要调用重载函数，则需要提供不同名字的包装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++ code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">f_i</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="built_in">f</span>(i) &#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">f_d</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123; <span class="built_in">f</span>(d) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_i</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_d</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fff</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f_i</span>(i);</span><br><span class="line">    <span class="built_in">f_d</span>(d);</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h6 id=&quot;C中如何调用C-函数&quot;&gt;&lt;a href=&quot;#C中如何调用C-函数&quot; class=&quot;headerlink&quot; title=&quot;C中如何调用C++函数&quot;&gt;&lt;/a&gt;C中如何调用C++函数&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于非</summary>
      
    
    
    
    
    <category term="C/C++" scheme="http://kennyyyyyy.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>知识点记录(Unity/C#)</title>
    <link href="http://kennyyyyyy.github.io/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-08-19T14:13:21.000Z</published>
    <updated>2022-10-05T13:46:37.908Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h5 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h5><ol><li><p><strong>从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Material material = Render.materials;</span><br><span class="line">material.shader = targetShader;</span><br><span class="line"><span class="comment">//修改 Shader 中参数的值：</span></span><br><span class="line">material.SetFloat(“参数名”，值); </span><br><span class="line">material.SetColor(“参数名”，颜色值); </span><br><span class="line">material.SetTexture(“参数名”，贴图); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Shader 中参数的值：</span></span><br><span class="line">material.GetFloat(“参数名”);</span><br><span class="line">material.GetColor(“参数名”); </span><br><span class="line">material.GetTexture(“参数名”); </span><br></pre></td></tr></table></figure></li></ol><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ol><li><p><strong>给定一个数组，有n(n &gt;= 0)个元素，找到数组中第二大的元素</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1 5 9 2 1 6 4 2 3 9</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetScendNum</span>(<span class="params"><span class="built_in">int</span>[] number, <span class="built_in">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> first=number[<span class="number">0</span>],second=number[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(number[i]&gt;first)&#123;</span><br><span class="line">            second=first;</span><br><span class="line">            first=number[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i]&gt;second)</span><br><span class="line">                second=number[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 若第二和第一相等，则将当前值赋予第二</span></span><br><span class="line">                second = first==second ? number[i] : second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给定一个可包含重复数字的序列 nums ，按序列内字典升序返回所有不重复的全排列。</strong></p><p><strong>其中序列内字典升序指的是， 序列内从左到右的非降序排列，例如 nums=[1,2,3], 则因为[1,2,3] &lt; [1,3,2], [3,1,2] &lt; [3,2,1]， [1,2,3]要先于[1,3,2]输出，[3,1,2]要先于[3,2,1]输出</strong></p><ol><li><p>使用STL库用来计算排列组合关系的算法：next_permutation和prev_permutation。</p><p>即按字典序(lexicographical)来找到下一个或前一个的排列组合。例：{2，1，3}的下一个是{2，3，1}，前一个是{1，3，2}。字典序即两个组合从左往右依次比较，若某一位A比B小，则A的字典序在B之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">UniquePerm</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">    res.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h5 id="oop的四个特征"><a href="#oop的四个特征" class="headerlink" title="oop的四个特征 "></a><strong>oop的四个特征 </strong></h5><p><strong>抽象、封装、继承、多态</strong></p><ul><li>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。</li><li>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。这也体现了大自然中一般与特殊的关系。继承性很好的解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。</li><li>封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。</li><li><p>多态性是指的是同一接口的不同实现方式，多态允许基类的指针指向子类方法。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p><ul><li><p>多态的作用：</p><ul><li>不必编写每一子类的功能调用，可以直接把不同子类当父类看，屏蔽子类间的差异，提高代码的通用率/复用率</li></ul></li></ul></li><li>父类引用可以调用不同子类的功能，提高了代码的扩充性和可维护性</li></ul><h5 id="迭代器和数组的区别"><a href="#迭代器和数组的区别" class="headerlink" title="迭代器和数组的区别"></a><strong>迭代器和数组的区别</strong></h5><p>迭代器：<strong>迭代器</strong>（iterator）有时又称<strong>光标</strong>（cursor）是程序设计的<a href="https://baike.baidu.com/item/软件设计模式">软件设计模式</a>，可在容器对象（container，例如<a href="https://baike.baidu.com/item/链表">链表</a>或<a href="https://baike.baidu.com/item/数组">数组</a>）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。</p><ul><li><p><a href="https://blog.csdn.net/lx2054807/article/details/107981276?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107981276-blog-123304449.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107981276-blog-123304449.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=2">C#</a> </p><ul><li><p>迭代器模式 指按照一定顺序来访问一个集合对象中的每个元素, 但是同时不会暴露集合对象的内部结构. C#中内置的迭代器模式就是Foreach语句, 它可以顺序遍历容器中的每个元素. 而迭代器的具体实现主要是靠IEnumerable 和IEnumerator.</p></li><li><p><strong>IEnumerator</strong></p><p>IEnumerator接口其实就是<a href="https://so.csdn.net/so/search?q=foreach&amp;spm=1001.2101.3001.7020">foreach</a>的具体实现, 它只定义了三个函数, 如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们实现一个最简单的IEnumerator接口只需要实现这三个函数即可. MoveNext()表示向集合中的下一个元素移动, 如果有下一个元素返回true, 没有就返回false. Current是一个只读属性, 返回当前迭代器所指元素. Reset()表示重置迭代器到第一个元素.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIEnumerator</span>: <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        count = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的IEnumerator, 如果用Foreach输出, 可以得到从9到0的十个计数. 而具体的实现过程还需要IEnumerable.</p></li><li><p><strong>IEnumerable</strong></p><p>IEnumerable可以粗略的理解为可迭代(遍历)的, 如果接口继承了IEnumerable, 那么就可以使用Foreach语句进行迭代操作. 这个接口只定义了一个函数, 如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数需要返回一个我们刚才定义的IEnumerator, 即告知上层调用方可以枚举.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIEnumerable</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个时候我们的迭代器已经实现, 可以使用Foreach语句进行迭代操作.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> VARIABLE <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">MyIEnumerable</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(VARIABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在有一个完整的迭代器了, 但是有一个问题, 很多时候我们需要的迭代器并不复杂, 如上面的计数装置, 如果每次都需要实现IEnumerator和IEnumerable十分不方便, 显得头重脚轻, 这时我们可以使用yield.</p></li><li><p><strong>yield</strong></p><p>yield是为了方便使用迭代器而产生的语法糖, 他可以直接使用在返回类型为IEnumerable或IEnumerator的函数中直接实现迭代器操作. 它有两种用法yield break 和yield return (something) 效果和break与return一样. 当使用yield return在foreach语句中进行迭代器操作时, 每一次执行到yield return时都会返回后面定义的something并且记录函数内的信息, 下一次运行时继续.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> VARIABLE <span class="keyword">in</span> <span class="title">myIEnumerable</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(VARIABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable <span class="title">myIEnumerable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  这里我们在i = 5的时候使用了yield break终止了迭代器操作, 如果去掉它, 这个函数就和我们刚才定义的迭代器作用一样, 产生了9到0, 共10个数的倒数.</p><ul><li><p><strong>协程(coroutine)</strong></p><p>除了foreach语句, Unity中另一种迭代器模式就是协程, 它是根据每一次IEnumerator的MoveNext()方法调用进行迭代的, 有些类似于Unity的Update方法. 同时它可以结合Unity的yield return new WaitForSeconds(time)等等接口实行迭代器+定时器模式.<br>使用和停止协程比较简单, 都只要传入IEnumerator就可以.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Coroutine <span class="title">StartCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br></pre></td></tr></table></figure><p>使用协程的方法实现我们的从9数到0.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StartCoroutine(myCoroutine());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">myCoroutine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(i);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">myCoroutine(</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  值得注意的是unity里有很多可以和yield结合使用的语句块, 如上的代码不仅实现了从9数到0, 还实现了每隔1秒数一次, 数到0后继续从头开始数, 当然还有很多其他有趣的功能可以通过coroutine和yield实现.</p></li></ul></li></ul><h5 id="泛型的作用。"><a href="#泛型的作用。" class="headerlink" title="泛型的作用。"></a><strong>泛型的作用。</strong></h5><p><strong>泛型和传统类型Boxing/UnBoxing的区别</strong></p><ol><li><p>泛型：即通过参数化类型来实现在同一份代码上操作多种数据类型。泛型编程是一种编程范式，它利用“参数化类型”将类型抽象化，从而实现更为灵活的复用。</p></li><li><p>作用：减少拆装箱，确保类型安全</p></li><li><p>区别：</p><ul><li>装箱：值类型转引用类型。开辟一块内存空间进行存放数据。</li><li>拆箱：引用类型转值类型。</li></ul></li><li><p>写一个泛型类 C 使其继承自 CBase</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CBase</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">C</span>&lt;<span class="title">T</span>&gt; : <span class="title">CBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">C1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">CBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><ol><li><p><strong>当你接手一个新项目，当运行一段时间后，发现内存占用高且帧率低，如何解决</strong></p><p>性能优化：</p></li></ol><h5 id="C-语法"><a href="#C-语法" class="headerlink" title="C#语法"></a>C#语法</h5><h6 id="C-特性（Attribute）"><a href="#C-特性（Attribute）" class="headerlink" title="C# 特性（Attribute）"></a><strong>C# 特性（Attribute）</strong></h6><p><strong>特性（Attribute）</strong>是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。</p><p><strong>特性（Attribute）</strong>用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：<em>预定义</em>特性和<em>自定义</em>特性。</p><p>规定特性（Attribute）的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">attribute(positional_parameters, name_parameter = value, ...)</span>]</span><br><span class="line">element</span><br><span class="line">    </span><br><span class="line"><span class="comment">//特性（Attribute）的名称和值是在方括号内规定的，放置在它所应用的元素之前。</span></span><br><span class="line"><span class="comment">//positional_parameters 规定必需的信息，name_parameter 规定可选的信息。</span></span><br></pre></td></tr></table></figure><p><strong>预定义特性（Attribute）</strong></p><p>.Net 框架提供了三种预定义特性：</p><ul><li><p>AttributeUsage：描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。</p><p>规定该特性的语法如下：<br>[AttributeUsage( validon, AllowMultiple=allowmultiple，Inherited=inherited)]</p><ol><li>参数 validon规定特性可被放置的语言元素。它是枚举器AttributeTargets的值的组合。默认值是AttributeTargets.All。</li><li>参数allowmultiple(可选的)为该特性的AllowMultiple属性(property)提供一个布尔值。如果为true，则该特性是多用的。默认值是false(单用的)</li><li>参数inherited(可选的)为该特性的Inherited 属性(property)提供一个布尔值。如果为true，则该特性可被派生类继承。默认值是false(不被继承)。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AttributeUsage(AttributeTargets.Class)//只能使用在类上</span></span><br><span class="line"><span class="comment"> * AttributeUsage(AttributeTargets.Method)//只能使用在方法上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//AttributeTargets.Method|AttributeTargets.Class表示可以在类上用也可以在方法上用</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)</span>]<span class="comment">//AllowMultiple =true可以在方法上写多个[C1]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">C1</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">C2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用</span></span><br><span class="line">    [<span class="meta">C1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStr</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Conditional：我们可以将一些函数隔离出来，使得它们只有在定义了某些环节变量或者设置了某个值之后才能发挥作用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若把 #define DEBUG 注释，则Message方法不会执行。即Conditional特性只会只会在其包含的”DEBUG“定义后才能执行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Conditional(<span class="meta-string">&quot;DEBUG&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Message</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass.Message(<span class="string">&quot;In Function 1.&quot;</span>);</span><br><span class="line">        function2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass.Message(<span class="string">&quot;In Function 2.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass.Message(<span class="string">&quot;In Main function.&quot;</span>);</span><br><span class="line">        function1();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Obsolete：它标记了不应被使用的程序实体。当一个新方法被用在一个类中，但若仍然想要保持类中的旧方法，可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Obsolete(</span></span><br><span class="line"><span class="meta">   message</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line">[<span class="meta">Obsolete(</span></span><br><span class="line"><span class="meta">   message,</span></span><br><span class="line"><span class="meta">   iserror</span></span><br><span class="line"><span class="meta">)</span>]</span><br></pre></td></tr></table></figure><ul><li>参数 <em>message</em>，是一个字符串，描述项目为什么过时以及该替代使用什么。</li><li>参数 <em>iserror</em>，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">   [<span class="meta">Obsolete(<span class="meta-string">&quot;Don&#x27;t use OldMethod, use NewMethod instead&quot;</span>, true)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OldMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;It is the old method&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;It is the new method&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      OldMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当使用OldMethod方法时，编译器会报错，错误信息为Obsolete的内容</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h6><ol><li><p>密封类：不能被继承</p><ul><li>关键字：sealed</li></ul></li><li><p>接口类：接口定义了所有类继承]接口时应遵循的语法合同</p><ul><li>Interface</li></ul></li><li><p>抽象类：不能被实例化，可以包含非抽象成员</p><ul><li><p>abstract</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法只需要声明</span></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">GetName</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 抽象属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a><strong>反射的作用</strong></h5><p><strong>动态创建一个数据集，并获得其类型T，调用T的Create函数。</strong></p><ul><li><p>.NET的一个强大功能是它可以通过一种称为反射(reflection)的过程访问应用程序的元数据。简单地说，反射就是运行时查询类型信息的能力。可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。</p></li><li><p>反射（Reflection）有下列用途：</p><ul><li>它允许在运行时查看特性（attribute）信息。</li><li>它允许审查集合中的各种类型，以及实例化这些类型。</li><li>它允许延迟绑定的方法和属性（property）。</li><li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li></ul></li><li><p>优点：</p><ul><li>1、反射提高了程序的灵活性和扩展性。</li><li>2、降低耦合性，提高自适应能力。</li><li>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li></ul><p>缺点：</p><ul><li>1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li><li>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Rectangle r = <span class="keyword">new</span> Rectangle(<span class="number">4.5</span>, <span class="number">7.5</span>);</span><br><span class="line">        r.Display();</span><br><span class="line">        Type type = <span class="keyword">typeof</span>(Rectangle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 Rectangle 类的特性</span></span><br><span class="line">        <span class="keyword">foreach</span> (DeBugInfo attributes <span class="keyword">in</span> type.GetCustomAttributes(<span class="literal">false</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != attributes)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Bug no: &#123;0&#125;&quot;</span>, attributes.BugNo);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Developer: &#123;0&#125;&quot;</span>, attributes.Developer);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Last Reviewed: &#123;0&#125;&quot;</span>,</span><br><span class="line">                                         attributes.LastReview);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Remarks: &#123;0&#125;&quot;</span>, attributes.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Prefab"><a href="#Prefab" class="headerlink" title="Prefab"></a>Prefab</h5><p><strong>如何获得Prefab的GameObject类型，PrefabInstance和ModelPrefabInstance的区别</strong></p><h5 id="委托和事件的区别"><a href="#委托和事件的区别" class="headerlink" title="委托和事件的区别"></a><strong>委托和事件的区别</strong></h5><ol><li><p>委托类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p><p>委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 <strong>System.Delegate</strong> 类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明语法</span></span><br><span class="line"><span class="built_in">delegate</span> &lt;<span class="keyword">return</span> type&gt; &lt;<span class="built_in">delegate</span>-name&gt; &lt;parameter list&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestDelegate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    num += p;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        num *= q;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    <span class="comment">// 创建委托实例 ： 新建委托对象，传入函数签名和委托类型一致的函数</span></span><br><span class="line">        NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">        NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);</span><br><span class="line">        <span class="comment">// 使用委托对象调用方法，调用委托，传入参数</span></span><br><span class="line">        nc1(<span class="number">25</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">        nc2(<span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>事件（Event）</strong> 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。</p><p>C# 中使用事件机制实现线程间的通信。</p><p>通过事件使用委托</p><ul><li><p>事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 <strong>发布器（publisher）</strong> 类。其他接受该事件的类被称为 <strong>订阅器（subscriber）</strong> 类。事件使用 <strong>发布-订阅（publisher-subscriber）</strong> 模型。</p></li><li><p><strong>发布器（publisher）</strong> 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。</p></li><li><p><strong>订阅器（subscriber）</strong> 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilerLogHandler</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于上面的委托定义事件， 事件会在生成时调用委托</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> BoilerLogHandler BoilerEventLog;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>区别</p><ol><li><p>委托</p><ul><li>Delegate 是一个类，在任何可以声明类的地方都可以声明委托。</li><li>可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。</li></ul></li><li><p>事件</p><ul><li><p>在类的内部，它总是private 的。</p></li><li><p>在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。</p></li><li><p>使用事件不仅能获得比委托更好的封装性以外，还能限制含有事件的类型的能力。</p></li><li><p>事件应该由事件发布者触发，而不应该由事件的客户端（客户程序）来触发。</p></li></ul></li></ol></li></ol><h5 id="万向锁"><a href="#万向锁" class="headerlink" title="万向锁"></a>万向锁</h5><p>万向锁(Gimbal Lock)：一旦选择±90°作为pitch角，就会导致第一次旋转和第三次旋转等价，整个旋转表示系统被限制在只能绕竖直轴旋转，丢失了一个表示维度。</p><p>以unity为例：unity中欧拉角的旋转顺序为 y-x-z。即旋转y轴x轴和z轴都改变，旋转x轴z轴改变，旋转z轴其他轴不变。</p><p>当模型的x轴的旋转为±90度时，旋转y轴和z轴的效果是一样的，这就是万向锁。此时y轴（惯性坐标系）旋转面和z轴（模型坐标系）旋转面共面</p><p><img src="/images/笔试题记录/image-20221005214034031.png" alt></p><p>因为计算机每次执行旋转都是从[0, 0, 0]开始进行，且y轴旋转的优先级最高，此时y轴的模型坐标系和惯性坐标系的重合，因此y轴的旋转从结果上看就是惯性坐标系的旋转。</p><h5 id="Unity生命周期函数"><a href="#Unity生命周期函数" class="headerlink" title="Unity生命周期函数"></a><strong>Unity生命周期函数</strong></h5><p>Awake -&gt; OnEnable -&gt; Start -&gt; FixedUpdate -&gt; OnTrigger/OnCollision -&gt; 输入事件 -&gt; Update -&gt;  LateUpdate -&gt; 渲染(Scene -&gt; Gizmo -&gt; GUI) -&gt; OnDisable -&gt; OnDestroy</p><h5 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a><strong>AssetBundle</strong></h5><p>AssetBundle是Unity中的一种资源包，这种资源包可以是游戏内要用到的几乎所有资源，并且可以在运行时动态加载。</p><ol><li>卸载Load的asset资源，通过Resources.UnloadAsset(asset)来进行卸载；</li><li><p>压缩格式：LZMA, LZ4, 以及不压缩。</p><ol><li>LZMA是一种默认的压缩形式，这种标准压缩格式是一个单一LZMA流序列化数据文件，并且在使用前需要解压缩整个包体。能使压缩后文件达到最小，但是解压相对缓慢。</li><li>LZ4能使得压缩量更大，而且在使用资源包前不需要解压整个包体。</li><li>不压缩的方式打包后包体会很大，导致很占用空间</li></ol></li><li><p><strong>AssetBundle的卸载和加载</strong></p><ul><li><p>加载</p><ol><li><p>AssetBundle.LoadFromFile：从本地加载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundle ab = AssetBundle.LoadFromFile(<span class="string">&quot;ab包名字/所在目录/资源名称.后缀&quot;</span>);</span><br><span class="line">    GameObject gameObj= ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;资源名称&quot;</span>);</span><br><span class="line">    Instantiate(gameObj);   <span class="comment">//实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AssetBundle.LoadFromMemory：从内存加载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundle ab = AssetBundle.LoadFromMemory(File.ReadAllBytes(<span class="string">&quot;ab包名字/所在目录/资源名称.后缀&quot;</span>));</span><br><span class="line">    GameObject gameObj= ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;资源名称&quot;</span>);</span><br><span class="line">    Instantiate(gameObj);   <span class="comment">//实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AssetBundle.LoadFromMemoryAsync：从内存异步加载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundleCreateRequest request = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(<span class="string">&quot;ab包名字/所在目录/资源名称.后缀&quot;</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line">    AssetBundle ab = request.assetBundle;</span><br><span class="line">    GameObject obj = ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;资源名称&quot;</span>);</span><br><span class="line">    Instantiate(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从AB中加载资源</p><p>AssetBundle.LoadAsset(assetName) ：加载AB包中的指定对象，不包含依赖的包  AssetBundle.LoadAllAssets() ：加载AB包中所有的对象，不包含依赖的包  AssetBundle.LoadAssetAsync() ：异步加载，加载较大资源的时候  AssetBundle.LoadAllAssetsAsync() ：异步加载全部资源  AssetBundle.LoadAssetWithSubAssets() ：加载资源及其子资源</p></li></ol></li><li><p>卸载</p><ul><li>AssetBundle.Unload(true)：卸载所有资源，包含其中正被使用的资源  </li><li>AssetBundle.Unload(false)：卸载所有没被使用的资源 </li><li>Resources.UnloadUnusedAssets()：卸载未使用的资源</li></ul></li></ul></li></ol><h5 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a><strong>protobuf</strong></h5><h5 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a><strong>重写和重载的区别</strong></h5><p>​    1.定义不同—-重载是定义相同的方法名，参数不同；重写是子类重写父类的方法。</p><p>​    2.范围不同—-重载是在一个类中，重写是子类与父类之间的。</p><p>​    3.多态不同—-重载是编译时的多态性，重写是运行时的多态性。</p><p>​    4.返回不同—-重载对返回类型没有要求，而重写要求返回类型，有兼容的返回类型。</p><p>​    5.参数不同—-重载的参数个数、参数类型、参数顺序可以不同，而重写父子方法参数必须相同。</p><p>​    6.修饰不同—-重载对访问修饰没有特殊要求，重写访问修饰符的限制一定要大于被重写方法的访问修.</p><h5 id="堆-Heap-和栈-Stack"><a href="#堆-Heap-和栈-Stack" class="headerlink" title="堆(Heap)和栈(Stack)"></a><strong>堆(Heap)和栈(Stack)</strong></h5><ol><li><p>程序内存</p><ul><li><p>栈：由操作系统自动分配释放，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。：堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。</p></li><li><p>区别：</p><ul><li>管理方式不同。栈自动释放；堆手动释放，容易产生内存泄漏</li><li>空间大小不同。栈 &lt;&lt; 堆。</li><li>生长方向不同。堆的内存地址由低到高；栈的内存地址由高到低。</li><li>分配方式不同。堆都是动态分配的；栈有静态分配和动态分配。</li></ul></li></ul></li><li><p>数据结构</p><ul><li>栈：线性表。先进后出(First In Last Out).</li><li>堆：树形结构，是一种特殊的完全二叉树。满足所有节点的值总是不大于或不小于父节点的值的完全二叉树。根节点最大称为大顶堆，根节点最小称为小顶堆。</li></ul></li><li><p>值类型存储在栈中；引用类型存储在堆上。</p></li></ol><h5 id="GC"><a href="#GC" class="headerlink" title="GC"></a><strong>GC</strong></h5><p>​    什么是GC：即Garbage Collection，垃圾回收。当使用可用内存不能满足内存请求时，GC会自动进行。</p><ol><li><p><strong>C#</strong>中的GC</p><ol><li><p>GC的四个步骤。</p><ul><li><p>垃圾回收器搜索内存中的托管对象；</p></li><li><p>从托管代码中搜索被引用的对象并标记为有效；</p></li><li><p>释放没有被标记为有效的对象并收回内存；</p></li><li><p>整理内存将有效对象挪动到一起。</p></li></ul></li><li><p>GC的作用：</p><ul><li><p>提高软件系统的内聚。</p></li><li><p>降低编程复杂度，使程序员不必分散精力去处理析构。</p></li><li><p>不妨碍设计师进行系统抽象。</p></li><li><p>减少由于内存运用不当产生的Bug。</p></li><li><p>成功的将内存管理工作从程序的编写时，脱离至运行时，使不可预估的管理漏洞变为可预估的。</p></li></ul></li><li><p>什么是垃圾</p><p>只要判定一个引用类型对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。</p></li><li><p>对象代龄</p><p>CLR初始化后的第一批被创建的对象被列为0代对象。</p></li><li><p>回收方法</p><ul><li><p>Finalizer(析构函数)：一般不用，因为不确定GC调用时间，影响效率。</p></li><li><p>Dispose：继承IDisposable接口，实现Dispose方法；调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。’</p></li><li><p>Mark-Compact 标记压缩算法</p></li><li><p>Generational 分代算法</p></li></ul></li></ol></li><li><p><strong>Unity</strong>中的CG</p><ol><li>Boehm GC(非分代非压缩)<ol><li>Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGen GC的设计思想）。</li><li>Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。 </li></ol></li><li>降低GC的方法：<ol><li>使用对象池</li><li>减少string，使用StringBuilder</li><li>减少拆装箱</li><li>struct中不要有引用类型变量</li><li>主动调用GC</li></ol></li></ol></li><li><p>三色标记清除法</p><ol><li>三色：黑色、灰色、白色<ul><li><code>黑色</code>: <strong>表示对象以及被垃圾收集器访问过，且这个对象的引用都已经扫描过</strong>。黑色的对象代表以及扫描过，他是安全存活的，如果有其他对象引用指向了黑色对象，无需重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li><li><code>灰色</code>: <strong>表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描到</strong></li><li><code>白色</code>: <strong>表示对象尚未被垃圾收集器访问过</strong>。显然在可达性分析刚刚开始的阶段，所有的对象都是白色，如在分析结束的阶段，仍然是白色的对象，即代表不可达。</li></ul></li><li>步骤：<ol><li>刚开始，所有对象都在<code>白色集合</code>中</li><li>将GC Roots直接引用的对象挪到<code>灰色集合</code>中</li><li>从<code>灰色集合</code>中获取对象：<ul><li>将本对象的引用到的对象放入<code>灰色集合</code>中</li><li>将本对象放入<code>黑色集合</code>中</li></ul></li><li>重复步骤3，直到<code>灰色集合</code>为空结束</li><li>结束后，仍在<code>白色集合</code>的对象即为GC Roots不可达，可以进行回收。</li></ol></li></ol></li><li><p>三代标记清除法</p></li></ol><h5 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a><strong>Lua</strong></h5><ol><li><p>pairs和ipairs</p><ul><li><p>同：都能遍历集合，均按优先顺序输出没有key的值</p></li><li><p>异：对于又key的值</p><p><strong>ipairs</strong>从第一个数字key开始，依次输出所有的key+1的键值，遇到字母下标不会结束遍历，但不输出，如果遇到nil则退出；<br><strong>pairs</strong>无序输出字母类型key或者数字类型key的键值，遇到nil不输出，也不会停止遍历。</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span> = &#123; [<span class="number">1</span>] = <span class="string">&quot;test3&quot;</span>, [<span class="number">2</span>] = <span class="string">&quot;val1&quot;</span> , [<span class="number">5</span>] = <span class="string">&quot;val2&quot;</span>, [<span class="number">4</span>] = <span class="string">&quot;val4&quot;</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------ipairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------pairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--输出</span></span><br><span class="line"><span class="comment">-----------ipairs----------------</span></span><br><span class="line"><span class="number">1</span>       test3</span><br><span class="line"><span class="number">2</span>       val1</span><br><span class="line"><span class="comment">-----------pairs----------------</span></span><br><span class="line"><span class="number">4</span>       val4</span><br><span class="line"><span class="number">1</span>       test3</span><br><span class="line"><span class="number">2</span>       val1</span><br><span class="line"><span class="number">5</span>       val2</span><br><span class="line"><span class="comment">--结论</span></span><br><span class="line"><span class="number">1</span>、<span class="built_in">ipairs</span>会按照key的顺序输出数据，遇到不连续的数据停止输出；</span><br><span class="line"><span class="number">2</span>、<span class="built_in">pairs</span>会无序输出所有数据；</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span> = &#123; [<span class="number">3</span>] = <span class="string">&quot;test3&quot;</span>, [<span class="string">&quot;test&quot;</span>] = <span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val3&quot;</span> , [<span class="number">4</span>] = <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val4&quot;</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------ipairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------pairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--输出</span></span><br><span class="line"><span class="comment">-----------ipairs----------------</span></span><br><span class="line"><span class="number">1</span>val3</span><br><span class="line"><span class="number">2</span>val4</span><br><span class="line"><span class="number">3</span>test3</span><br><span class="line"><span class="number">4</span>val2</span><br><span class="line"><span class="comment">-----------pairs----------------</span></span><br><span class="line"><span class="number">1</span>val3</span><br><span class="line"><span class="number">2</span>val4</span><br><span class="line"><span class="number">4</span>val2</span><br><span class="line">testval1</span><br><span class="line"><span class="number">3</span>test3</span><br><span class="line"></span><br><span class="line"><span class="comment">--结论</span></span><br><span class="line"><span class="number">1</span>、<span class="built_in">pairs</span>和<span class="built_in">ipairs</span>均优先输出没有key的value；</span><br><span class="line"><span class="number">2</span>、<span class="built_in">pairs</span>会输出所有的数据，不带key的值按顺序输出，带key的值无序输出；</span><br><span class="line"><span class="number">3</span>、<span class="built_in">ipairs</span>会跳过字符串的key，按顺序输出数字型key的值；</span><br></pre></td></tr></table></figure></li><li><p>__index和__newindex</p><ul><li><p>__index：(get)当在表中找不到元素时，lua会从 __index指向的表查找元素或获得方法的返回值。</p></li><li><p>__newindex：(set)对表中不存在的值进行赋值时调用。</p><p>当__newindex指向一个函数时，会执行该函数，且对本表的创建不成功；</p><p>当__newindex指向一个表时，会对指向的表进行操作，且对本表创建不成功。</p></li></ul></li><li><p>__rawset和 __rawget</p><p>可以通过rawset和rawget操作绕过原表这一过程(__index和__newindex)，直接把这个表相应的结论输出。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> table1 = &#123; x = <span class="string">&quot;val1&quot;</span> &#125;</span><br><span class="line"><span class="keyword">local</span> table2 = &#123; y = <span class="string">&quot;val2&quot;</span> &#125;</span><br><span class="line"><span class="keyword">local</span> table3 = &#123; z = <span class="string">&quot;val3&quot;</span> &#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(table1, &#123;<span class="built_in">__index</span> = table2, <span class="built_in">__newindex</span> = table3&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(table1.y)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(table1, <span class="string">&quot;y&quot;</span>))  </span><br><span class="line"></span><br><span class="line">table1.newN = <span class="string">&quot;newN&quot;</span></span><br><span class="line"><span class="built_in">print</span>(table1.newN)</span><br><span class="line"><span class="built_in">print</span>(table3.newN)</span><br><span class="line"></span><br><span class="line"><span class="built_in">rawset</span>(table1, <span class="string">&quot;newN&quot;</span>, <span class="string">&quot;newZ&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(table1.newN)</span><br><span class="line"></span><br><span class="line"><span class="comment">--输出--</span></span><br><span class="line">val2</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">newN</span><br><span class="line">newZ</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li>a</li></ol><h5 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h5><p>​    网络同步的目标时保证多台机器的游戏表现完全一致</p><ol><li><p>帧同步</p><ol><li>原理：<ul><li>帧同步的战斗逻辑在客户端；</li><li>在帧同步下，服务端只转发操作，不做任何逻辑处理；</li><li>客户端按照一定的帧速率（逻辑帧）去上传当前的操作指令，服务端将操作指令广播给所有客户端；</li><li>当客户端收到指令后执行本地代码，如果输入的指令一致，计算的过程一致，那么计算的结果肯定是一致的，这样就能保证所有客户端的同步，这就是帧同步。</li></ul></li><li>缺点：<ul><li>由于帧同步战斗逻辑都在客户端，服务器没有验证，外挂成本低（加速、透视、自动瞄准、数据修改等）；</li><li>网络条件较差的客户端会影响其他玩家的游戏体验。（优化方案：乐观帧锁定、渲染与逻辑帧分离、客户端预执行、指令流水线化、操作回滚等）；</li><li>不同机器浮点数精度问题、容器排序不确定性、RPC时序、随机数值计算不统一。</li></ul></li><li>乐观帧锁定：</li></ol></li><li><p>状态同步</p><ol><li><p>原理：</p><ul><li><p>状态同步的战斗逻辑在服务端；</p></li><li><p>在状态同步下，客户端更像是一个服务端数据的表现层；</p></li><li><p>一般流程：</p></li><li><ul><li>客户端上传操作到服务器；</li><li>服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态；</li><li>客户端收到状态后再根据状态显示内容。</li></ul></li></ul></li><li><p>缺点：</p><ul><li>状态同步的回放实现较为复杂；</li><li>延迟过大、客户端性能浪费、服务端压力大；</li><li>对带宽的浪费。对于对象少的游戏，可以用快照保存整个游戏的状态发送，但一旦数量多起来，数量的占用就会直线上升。（优化：增量快照同步，协议同步指定数据）</li></ul></li></ol></li><li><p>区别</p><table border="1">    <tr>        <th>属性</th>        <th>状态同步</th>        <th>帧同步</th>    </tr>    <tr>        <td>流量</td>        <td>相对高</td>        <td>相对低</td>    </tr>    <tr>        <td>回放</td>        <td>记录文件大，且实现相对复杂</td>        <td>记录文件小，且相对容易实现</td>    </tr>        <tr>        <td>安全性</td>        <td>服务器实现逻辑，安全性高</td>        <td>逻辑在客户端，防作弊难度高</td>    </tr>    <tr>        <td>服务器压力</td>        <td>逻辑在服务端，压力大</td>        <td>小</td>    </tr>    <tr>        <td>战斗校验</td>        <td></td>        <td>服务端可以重跑一遍战斗</td>    </tr>    <tr>        <td>网络卡顿表现</td>        <td>瞬移，回位</td>        <td>卡顿</td>    </tr></table></li><li><p>表现优化</p><p>表现优化用于弱化玩家对延迟的感受。</p><ol><li>插值优化：客户端采用插值，避免位置突变</li><li>客户端预测+回滚</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h5 id=&quot;Shader&quot;&gt;&lt;a href=&quot;#Shader&quot; class=&quot;headerlink&quot; title=&quot;Shader&quot;&gt;&lt;/a&gt;Shader&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;从Render获取材质，获</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>热更新</title>
    <link href="http://kennyyyyyy.github.io/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://kennyyyyyy.github.io/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2022-08-16T01:41:04.000Z</published>
    <updated>2022-08-16T02:25:21.091Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><hr><h4 id="资源目录划分"><a href="#资源目录划分" class="headerlink" title="资源目录划分"></a>资源目录划分</h4><p><img src="/images/热更新/资源目录划分.png" alt="image-20220816102442776"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;hr&gt;
&lt;h4 id=&quot;资源目录划分&quot;&gt;&lt;a href=&quot;#资源目录划分&quot; class=&quot;headerlink&quot; title=&quot;资源目录划分&quot;&gt;&lt;/a&gt;资源目录划分&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/热更新/资源目</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="Lua" scheme="http://kennyyyyyy.github.io/tags/Lua/"/>
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
    <category term="xlua" scheme="http://kennyyyyyy.github.io/tags/xlua/"/>
    
  </entry>
  
  <entry>
    <title>Lua学习</title>
    <link href="http://kennyyyyyy.github.io/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/"/>
    <id>http://kennyyyyyy.github.io/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-08-12T02:30:23.000Z</published>
    <updated>2022-08-16T01:40:18.024Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><a href="https://www.runoob.com/manual/lua53doc/contents.html">Lua5.3参考手册</a></p><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><ol><li><p><strong>变量</strong></p><ul><li>动态类型 弱类型 大小写敏感 默认全局 带GC</li><li>类型：nil、boolean、number、string、function、userdata(用户自定义类型)、tread、table</li><li></li></ul></li></ol><ol><li><p><strong>语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 赋值 --</span></span><br><span class="line">a,b = <span class="string">&quot;hello&quot;</span>, <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of a = &quot;</span>, <span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of b = &quot;</span>, <span class="built_in">type</span>(b))</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    多行注释 d </span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"><span class="comment">-- 交换 --</span></span><br><span class="line">a,b = b,a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分支 if  boolean: false、nil。 0 != false</span></span><br><span class="line"><span class="keyword">if</span> b == <span class="number">15</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b = 15&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> b ~= <span class="number">16</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b != 15&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)        </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 循环： 有break 无continue</span></span><br><span class="line"><span class="comment">-- for 起始，终值，增值</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> ,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- while</span></span><br><span class="line">d = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> d &lt;= <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line">    d = d + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- repeat until (do while)</span></span><br><span class="line"></span><br><span class="line">ans = <span class="number">15</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;guess the password (little than 100)&quot;</span>)</span><br><span class="line">    a =<span class="built_in">tonumber</span>(<span class="built_in">io</span>.<span class="built_in">read</span>())</span><br><span class="line">    <span class="keyword">if</span> a == ans <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You are right!&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elseif</span> a &gt; ans <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(a,<span class="string">&quot;Too big&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(a,<span class="string">&quot;Too small&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">until</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数学运算  + -  *  /(//)    %   ^</span></span><br><span class="line"><span class="comment">--         加 减 乘 除(取整) 取余 幂</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;5^3 = &quot;</span>, <span class="number">5</span>^<span class="number">3</span>)</span><br><span class="line"><span class="comment">-- 关系运算 &gt; &lt; &gt;= &lt;= == ~=(不等)</span></span><br><span class="line"><span class="comment">-- 逻辑运算 and(&amp;&amp;) or(||) not(!)</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>数据结构 Table</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table</span></span><br><span class="line"><span class="comment">-- 下标从一开始</span></span><br><span class="line"><span class="comment">-- 可以看作为键值对，没有键值，则默认的位置下标为键值(去掉中间存在键值的)</span></span><br><span class="line"><span class="comment">-- table.key or talbe[&quot;key&quot;]</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,pos =&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;ddd&quot;</span>, [<span class="string">&quot;z&quot;</span>] = <span class="string">&quot;zz&quot;</span>&#125;, x = <span class="number">123</span>, y = <span class="number">456</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;x&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a.y)</span><br><span class="line"><span class="built_in">print</span>(a.pos.z)  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(k) == <span class="built_in">table</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(k) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">print</span>(key, <span class="string">&quot;:&quot;</span>, val)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(k, <span class="string">&quot;:&quot;</span>, v);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>function 函数</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- function </span></span><br><span class="line"><span class="comment">-- 有多个值返回的，从第一个返回的值开始接收，多余的丢弃</span></span><br><span class="line">add = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a + b    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a - b, a * b, <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ans1, ans2 = func(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(ans1, ans2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 高阶函数 第一类(first class)</span></span><br><span class="line"><span class="comment">-- 即返回值或参数为函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span><span class="params">(f, a, b)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;f(a,b)&quot;</span>, f(a,b))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p(func, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 变参 #v == length(v)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">local</span> args = &#123;...&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(args) <span class="keyword">do</span></span><br><span class="line">        sum = sum + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> #args, sum</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>运算符</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 运算符</span></span><br><span class="line"><span class="comment">-- # 求长度 : 用于普通数组，用于表不准确，存在未定义事件(下标不连续，不是整数等)，无法计算长度</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">nil</span>, x = <span class="string">&quot;ss&quot;</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接符 .. 性能消耗大</span></span><br><span class="line">a = <span class="string">&quot;ab&quot;</span></span><br><span class="line">b = <span class="string">&quot;cd&quot;</span></span><br><span class="line">c = a..b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑运算符 and or not (与其他语言基本一致)</span></span><br><span class="line"><span class="comment">-- 优先级 and &gt; or</span></span><br><span class="line"><span class="comment">-- 右结合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>^<span class="number">3</span>^<span class="number">2</span>) <span class="comment">-- &lt;--(2^(3^2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 位运算 &amp;  |  ~  ~    &gt;&gt; &lt;&lt;</span></span><br><span class="line"><span class="comment">--       与 或 非 异或  位运算</span></span><br><span class="line"><span class="comment">-- 3 0011</span></span><br><span class="line"><span class="comment">-- 5 0101</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>~<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>函数库：例</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &quot;&quot;有转译， [[]]无转义</span></span><br><span class="line">a = <span class="string">&quot;a\nb\\c 0b110&quot;</span></span><br><span class="line">b = <span class="string">[[d \ \ \ \ \ cdca\c\]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">&quot;,&quot;</span>, b)</span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">upper</span>(a))</span><br><span class="line"><span class="built_in">print</span>(b:<span class="built_in">upper</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">--string 正则匹配与标准不完全一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--table</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(a, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(a, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(a)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&quot;:&quot;</span>, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">table</span>.<span class="built_in">concat</span>(a, <span class="string">&quot;+&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--math</span></span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>协程</strong></p><p><img src="/images/Lua学习/协程执行流程.png" alt="协程执行流程"></p><p><img src="/images/Lua学习/协程状态转换.png" alt="协程状态转换"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 协程：与Unity协程基本一致，执行到yield，下次执行从yeild后继续</span></span><br><span class="line"><span class="comment">-- thread 线程 协程 进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--type(co) = thread</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;coroutine running...&quot;</span>)</span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;coroutine continue...&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 运行协程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br><span class="line">        v1,v2 = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;v1 = &quot;</span>, v1, <span class="string">&quot;v2 = &quot;</span>, v2)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line">a1,a2,a3 = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a1, a2, a3)   <span class="comment">-- a1：执行结果(成功/失败) a2，a3(yield返回值)</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">-- 第二次调用时传入的参数会作为yeild的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- type(func) == function</span></span><br><span class="line">func = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>OO 面向对象</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 简易面向对象实现代码</span></span><br><span class="line"><span class="comment">-- 定义对象</span></span><br><span class="line"><span class="keyword">local</span> Monster = &#123;</span><br><span class="line">    name = <span class="string">&quot;Monster&quot;</span>,</span><br><span class="line">    HP = <span class="number">100</span>,</span><br><span class="line">    pos = &#123;x = <span class="number">10</span>, y = <span class="number">10</span>&#125;,</span><br><span class="line">    TakeDamage = <span class="function"><span class="keyword">function</span><span class="params">(self, damage)</span></span></span><br><span class="line">        <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">local</span> Monster2 = &#123;HP = <span class="number">200</span>&#125;</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">-- 增加方法,传入对象</span></span><br><span class="line"><span class="comment">    Monster.TakeDamage = function(self, damage)</span></span><br><span class="line"><span class="comment">        self.HP = self.HP - damage    </span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    function Monster:TakeDamage(damage)</span></span><br><span class="line"><span class="comment">        self.HP = self.HP - damamge</span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line">Monster.TakeDamage(Monster2, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(Monster.HP)</span><br><span class="line"><span class="built_in">print</span>(Monster2.HP)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Monster.TakeDamage(Monster, 10),即将Monster作为TakeDamage的第一个参数</span></span><br><span class="line">Monster:TakeDamage(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">------------------------------------------</span></span><br><span class="line"><span class="comment">-- 定义类</span></span><br><span class="line"><span class="comment">-- 通过原表</span></span><br><span class="line">CMonster = &#123;</span><br><span class="line">    name = <span class="string">&quot;Monster&quot;</span>,</span><br><span class="line">    HP = <span class="number">1000</span>,</span><br><span class="line">    TakeDamage = <span class="function"><span class="keyword">function</span><span class="params">(self, damage)</span></span></span><br><span class="line">        <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjMonster = &#123;pos = &#123;x = <span class="number">10</span>, y = <span class="number">10</span>&#125;&#125;</span><br><span class="line"><span class="comment">-- 设置原表  -- 该值或加值，调用的是__newindex</span></span><br><span class="line"><span class="built_in">setmetatable</span>(</span><br><span class="line">    ObjMonster, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">__index</span> = CMonster,</span><br><span class="line">        <span class="built_in">__newindex</span> = CMonster   <span class="comment">-- 若__newindex = CMonster 则修改会影响原表</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(ObjMonster.HP)</span><br><span class="line">ObjMonster.HP = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义new 方法，用于新建对象</span></span><br><span class="line">CMonster = &#123;</span><br><span class="line">    name = <span class="string">&quot;Monster&quot;</span>,</span><br><span class="line">    HP = <span class="number">1000</span>,</span><br><span class="line">    TakeDamage = <span class="function"><span class="keyword">function</span><span class="params">(self, damage)</span></span></span><br><span class="line">        <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line">    <span class="keyword">end</span> ,</span><br><span class="line">    Show = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">self</span>.name, <span class="string">&quot;:&quot;</span>, <span class="built_in">self</span>.HP, <span class="string">&quot;:&quot;</span>, <span class="built_in">self</span>.x, <span class="string">&quot;;&quot;</span>, <span class="built_in">self</span>.y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 设置CMonster的__index， 设置原表时就不需要新建一个表来设置__index了</span></span><br><span class="line">CMonster.<span class="built_in">__index</span> = CMonster </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CMonster:new</span><span class="params">(name, hp, x, y)</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    obj.HP = hp</span><br><span class="line">    obj.x = x</span><br><span class="line">    obj.y = y</span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, CMonster)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置CMonster的原表，使其调用可以直接使用 () 来调用new或其他函数  </span></span><br><span class="line"><span class="built_in">setmetatable</span>(CMonster, &#123;<span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, name, hp, x, y)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>:new(name, hp, x, y)</span><br><span class="line"><span class="keyword">end</span>&#125;)</span><br><span class="line"></span><br><span class="line">obj1 = CMonster(<span class="string">&quot;mon&quot;</span>, <span class="number">300</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">obj1:Show()</span><br><span class="line">obj1:TakeDamage(<span class="number">250</span>)</span><br><span class="line">obj1:Show()</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>类的继承的简单实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 继承</span></span><br><span class="line"><span class="comment">-- 引用上一个文件的CMonster类</span></span><br><span class="line"><span class="keyword">local</span> Cm = <span class="built_in">require</span>(<span class="string">&quot;t6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> obj1 = Cm(<span class="string">&quot;Monster&quot;</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">obj1:Show()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个新类</span></span><br><span class="line"><span class="keyword">local</span> MMonster = &#123;</span><br><span class="line">    MP = <span class="number">200</span>,</span><br><span class="line">    Attack = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Attacking...&quot;</span>)</span><br><span class="line">        <span class="built_in">self</span>.MP = <span class="built_in">self</span>.MP - <span class="number">10</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义其原表未Cm，即模拟继承的效果</span></span><br><span class="line"><span class="built_in">setmetatable</span>(MMonster, &#123;</span><br><span class="line">    <span class="built_in">__index</span> = Cm,</span><br><span class="line">    <span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, name, HP)</span></span></span><br><span class="line">        <span class="keyword">local</span> obj = Cm(name, HP)</span><br><span class="line">        <span class="built_in">setmetatable</span>(obj, &#123;<span class="built_in">__index</span> = MMonster&#125;)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多态的实现，即在新类中定义原表中存在的方法，模拟多态的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MMonster:Show</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;M Monster:&quot;</span>, <span class="built_in">self</span>.name, <span class="built_in">self</span>.HP, <span class="built_in">self</span>.MP)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mm = MMonster(<span class="string">&quot;MMonster1&quot;</span>, <span class="number">100</span>)</span><br><span class="line">mm:Show()</span><br><span class="line">mm:TakeDamage(<span class="number">10</span>)</span><br><span class="line">mm:Show()</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>简单封装的实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 实现Monster类，并进行封装</span></span><br><span class="line"><span class="keyword">local</span> Monster = &#123;&#125;</span><br><span class="line">Monster.HP = <span class="number">100</span></span><br><span class="line">Monster.x = <span class="number">1000</span></span><br><span class="line">Monster.y = <span class="number">10</span></span><br><span class="line">Monster.<span class="built_in">type</span> = <span class="string">&quot;Monster&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:GetHP</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>.HP</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:TakeDamage</span><span class="params">(damage)</span></span></span><br><span class="line">    <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:SetHP</span><span class="params">(hp)</span></span></span><br><span class="line">    <span class="built_in">self</span>.HP = hp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;HP = Monster.HP, x = Monster.x, y = Monster.y&#125;    <span class="comment">-- 默认值</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, Monster)</span><br><span class="line">    <span class="comment">-- __index 定义新表，表示哪些属性可以被obj访问</span></span><br><span class="line">    Monster.<span class="built_in">__index</span> = &#123;GetHP = Monster.GetHP, TakeDamage = Monster.TakeDamage, <span class="built_in">type</span> = Monster.<span class="built_in">type</span>&#125;</span><br><span class="line">    <span class="comment">-- __newindex 访问不存在的域时的调用 例如 obj.type = “ddd&quot; 三个分别对应function的三个参数 </span></span><br><span class="line">    Monster.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(tab, key, value)</span></span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&quot;type&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Forbiden orerate.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">rawset</span>(tab, key, value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Monster</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 引用并测试</span></span><br><span class="line"><span class="keyword">local</span> CMonster = <span class="built_in">require</span>(<span class="string">&quot;t9&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> cm = CMonster:new()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cm:GetHP())</span><br><span class="line">cm:TakeDamage(<span class="number">10</span>)</span><br><span class="line">cm.<span class="built_in">type</span> = <span class="string">&quot;Player&quot;</span>  <span class="comment">-- Forbiden orerate.</span></span><br><span class="line"><span class="comment">--cm:SetHP(100)     -- attempt to call a nil value (method &#x27;SetHP&#x27;) 无法访问，即设置为私有了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cm.z)<span class="comment">-- nil</span></span><br><span class="line">cm.z = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(cm.z)<span class="comment">-- 20</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>闭包</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 闭包：通过一系方法,将函数内部的变量(局部变量)转化为全局变量</span></span><br><span class="line"><span class="comment">-- 如下，</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span><span class="params">()</span></span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cn = Counter()</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/manual/lua53doc/contents.html&quot;&gt;Lua5.3参考手册&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;语法：&quot;&gt;&lt;a href=&quot;#语法：&quot; cla</summary>
      
    
    
    
    
    <category term="Lua" scheme="http://kennyyyyyy.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://kennyyyyyy.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://kennyyyyyy.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2022-05-12T02:30:23.000Z</published>
    <updated>2022-09-25T07:03:58.968Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p><strong>时间复杂度</strong>：指执行算法所需要的工作量。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，即考察输入值大小趋近无穷时的情况。</p><p><strong>空间复杂度</strong>：指执行算法需要的内存空间</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h4><h5 id="栈（Stack）："><a href="#栈（Stack）：" class="headerlink" title="栈（Stack）："></a><strong>栈（Stack）</strong>：</h5><p>后进先出的数据结构。只能在栈顶进行添加（入栈）和删除（出栈）的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本方法</span></span><br><span class="line"><span class="built_in">top</span>()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</span><br><span class="line"><span class="built_in">push</span>(<span class="keyword">const</span> T&amp; obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 <span class="built_in">push_back</span>() 函数完成的。</span><br><span class="line"><span class="built_in">push</span>(T&amp;&amp; obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 <span class="built_in">push_back</span>() 函数完成的。</span><br><span class="line"><span class="built_in">pop</span>()：弹出栈顶元素。</span><br><span class="line"><span class="built_in">size</span>()：返回栈中元素的个数。</span><br><span class="line"><span class="built_in">empty</span>()：在栈中没有元素的情况下返回 <span class="literal">true</span>。</span><br><span class="line"><span class="built_in">emplace</span>()：用传入的参数调用构造函数，在栈顶生成对象。</span><br><span class="line"><span class="built_in">swap</span>(stack&lt;T&gt; &amp; other_stack)：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 <span class="built_in">swap</span>() 可以使用。</span><br></pre></td></tr></table></figure><p><strong>应用</strong>：①撤销操作，②数组反转，③递归</p><h5 id="队列（Queue）："><a href="#队列（Queue）：" class="headerlink" title="队列（Queue）："></a><strong>队列（Queue）</strong>：</h5><p> 先进先出的数据结构，只能在队尾添加（入队）元素，队首删除（出队）元素。（双向队列无尾首区别）</p><p>循环队列 性能最好</p><p><strong>应用</strong>：排队</p><ul><li><p>queue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>();</span><br><span class="line"><span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">front</span>();</span><br><span class="line"><span class="built_in">back</span>();</span><br></pre></td></tr></table></figure></li></ul><h5 id="集合（Set）："><a href="#集合（Set）：" class="headerlink" title="集合（Set）："></a><strong>集合（Set）</strong>：</h5><p>包含不重复元素的集合称为set，例如HashSet等，能快速的进行去重操作。</p><p><strong>应用</strong>：词汇量统计</p><h5 id="映射（Reflection）："><a href="#映射（Reflection）：" class="headerlink" title="映射（Reflection）："></a><strong>映射（Reflection）</strong>：</h5><p>特殊集合，例如Dictionary，存储的是键值对</p><p><strong>应用</strong>：词汇量统计</p><h5 id="有序数组："><a href="#有序数组：" class="headerlink" title="有序数组："></a><strong>有序数组：</strong></h5><p><img src="../images/数据结构与算法/image-20220323182228705.png" alt="image-20220323182228705" style="zoom:50%;"></p><ul><li>Rank使用二分查找找到target的对应位置，方便add 和 remove 的操作，保证数组始终有序</li></ul><h5 id="树："><a href="#树：" class="headerlink" title="树："></a>树：</h5><p>​    <strong>二叉树（Binary Tree）</strong>：普通二叉树</p><p>​    <strong>满二叉树（Full Binary Tree）</strong>：除了叶子节点外都有两个节点</p><p>​    <strong>完全二叉树（Complete Binary Tree）</strong>：每层的节点均达到最大值，及每层的节点数为2的n-1次方个</p><p>​    <strong>二叉搜索树（Binary Search Tree）</strong>：每个节点左边所有节点的值均小于右边节点的值</p><p>​    <strong>平衡二叉树（AVL Tree）</strong>：任何节点的两颗字数的高度差小于等于1</p><p>​    <strong>B树（B-Tree）</strong>：B树与平衡二叉树一样，但是是多叉树</p><p>​    <strong>红黑树（Red-Black Tree）</strong>：自平衡二叉寻找数</p><p>​    </p><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><ul><li>substr(int pos, int len); 获得字串，pos为起始位置，len为长度</li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h4><h6 id="排序：升序为例"><a href="#排序：升序为例" class="headerlink" title="排序：升序为例"></a>排序：升序为例</h6><ul><li><p><strong>冒泡</strong>：双重循环，依次比较大小，前一个比后一个大，则交换位置，时间复杂度O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> t = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>选择</strong>：双重循环，但内循环只选出第 i 个即其之后位置的最小值，然后和第 i 个位置交换，时间复杂度O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = arr.<span class="built_in">size</span>(), idx = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> mx = arr[i];</span><br><span class="line">           idx = i;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(mx &gt; arr[j])&#123;</span><br><span class="line">                   mx = arr[j];</span><br><span class="line">                   idx = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> t = arr[i];</span><br><span class="line">           arr[i] = mx;</span><br><span class="line">           arr[idx] = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>快排</strong>：以第一个数为界 记flag，从前往后找出第一个比flag大的值，从后往前，找出第一个比flag小的数，然后交换两个数的位置。直到找到flag的位置，然后递归查找flag的左侧和右侧的中间值</p><p>时间复杂度O(n log2 n)</p><font color="red">不能对存在重复元素的数组进行排序</font><font color="red">若快排前数组有序，则时间复杂度为O(n^2)</font><font color="red">排序前可以将第一个元素与中间或随机元素进行交换，可优化时间复杂度</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = arr[start];</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++i] &lt; flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == end)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[j] &gt; flag)&#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(j == start)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[start] = arr[j];</span><br><span class="line">    arr[j] = flag;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, start, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, j + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>三路快排</strong>：<font color="red">有重复元素的快速排序</font> ，即相比上一个方法，多了等于flag的情况</p><p>即将数组中的元素分为三个区域，大于[gt, right] 小于[l+1, lt]和等于选定值flag的情况</p><p><img src="../images/数据结构与算法/70.png" alt="img"></p><p>i 指向当前元素</p><ul><li>若 i 指向元素等于flag，则i++；</li><li>若 i 指向元素小于flag，则将 it + 1 指向的值与 i 交换，然后 it++、i++。即将小于flag的区域增1，且等于flag的区域右移1.</li><li>若 i 指向的元素大于flag， 则将 gt - 1 指向的元素与 i 交换，然后 gt—。即将大于flag的区域向后增1，其余区域不变</li><li>当 i 指向 gt 时，表示遍历完成，此时只需将 flag 除的值与 lt 处的值进行交换，则三个区间形成，然后继续遍历大于flag和小于flag的区域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, i</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="number">1</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">while</span>(i &lt; gt)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">if</span>(arr[i] &lt; flag)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> t = arr[i];</span></span></span><br><span class="line"><span class="function"><span class="params">                arr[i] = arr[lt + <span class="number">1</span>];</span></span></span><br><span class="line"><span class="function"><span class="params">                arr[lt + <span class="number">1</span>] = t;</span></span></span><br><span class="line"><span class="function"><span class="params">                lt++;</span></span></span><br><span class="line"><span class="function"><span class="params">                i++;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; flag)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> t = arr[i];</span></span></span><br><span class="line"><span class="function"><span class="params">                arr[i] = arr[gt - <span class="number">1</span>];</span></span></span><br><span class="line"><span class="function"><span class="params">                arr[gt - <span class="number">1</span>] = t;</span></span></span><br><span class="line"><span class="function"><span class="params">                gt--;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">else</span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                i++;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    arr[start] = arr[lt];</span></span></span><br><span class="line"><span class="function"><span class="params">    arr[lt] = flag;</span></span></span><br><span class="line"><span class="function"><span class="params">        QuickSort(arr, start, lt - <span class="number">1</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        QuickSort(arr, gt, end);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">     </span></span></span><br><span class="line"><span class="function"><span class="params">    vector&lt;<span class="keyword">int</span>&gt; MySort(vector&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        QuickSort(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> arr;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>归并</strong>：采用分治法，先使子序列有序，然后将两个有序子序列合并，得到有序序列。即先将输入序列分成n/2个子序列，对这两个子序列分别采用归并排序，将两个排序好的子序列合并成排序序列，时间复杂度O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, vector&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = start;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">            res[k++] = arr[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        res[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(j &lt;= end)&#123;</span><br><span class="line">        res[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = start; z &lt;= end; z++)&#123;</span><br><span class="line">        arr[z] = res[z];</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, vector&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, res, start, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, res, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">Merge</span>(arr, res, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, res, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>堆</strong>：</p></li><li><p><strong>桶</strong>：</p></li></ul><h6 id="查找："><a href="#查找：" class="headerlink" title="查找："></a><strong>查找：</strong></h6><ul><li><p>顺序查找<strong>O(n)</strong>：遍历所有数据，进行处理 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">OrderSearch</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n, i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(target == arr[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找<strong>O(log n)</strong>：对有序数组进行分半查找，每次为对比中间数据，然后根据大小关系，对前半部分或后半部分进行对比。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BinarySearch</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>; <span class="comment">//防止数据溢出</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt; arr[mid])</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; arr[mid])</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="递归-recursion-："><a href="#递归-recursion-：" class="headerlink" title="递归(recursion)："></a><strong>递归(recursion)：</strong></h6><ul><li>程序调用自身的编程技巧称为递归，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解.。递归需要有边界条件、递归前进段和递归返回段。</li><li><strong>尾递归</strong>：首先执行计算，然后执行递归调用<ul><li>在尾部调用的是函数自身 （Self-called）；</li><li>可通过优化，使得计算仅占用常量栈空间 (Stack Space)。</li></ul></li></ul><h6 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h6><ul><li><p>定义：在一些有N个元素的集合应用问题中，通常在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。</p></li><li><p>主要用于解决一些<strong>元素分组</strong>的问题，用于管理一系列<strong>不相交的集合</strong>并存在两种操作：</p><ul><li><strong>查找(Find)</strong>:查询两个元素是否在同一个集合中；</li><li><strong>合并(Union)</strong>:把两个不相交的集合合并成一个集合。</li></ul></li><li><p>最简单版本的并查集代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> parent[MaxSize]; <span class="comment">//使用parents数组来记录每个节点的父节点</span></span><br><span class="line"><span class="comment">//初始化：首先将所有的节点的父节点设置为自己</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询:通过递归不断访问父节点，直到访问到根节点。根据两个节点的根节点是否相同来判断是否在同一个集合当中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[val] == val)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Find</span>(parent[val]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并：找到两个节点所在集合的根节点，将一个根节点的父节点设置为另一个根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parent[<span class="built_in">Find</span>(i)] == <span class="built_in">Find</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接合并可能会导致每次查询的路径过长，而增加时间消耗，因此，存在两个方面对算法进行优化</p><ul><li><p>路径压缩：在查询过程中把沿途的每个节点的父节点全部设置为根节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[val] == val)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    parent[val] = <span class="built_in">Find</span>(Parent[val]); <span class="comment">//将父节点设置为根节点</span></span><br><span class="line">    <span class="keyword">return</span> parent[val]<span class="comment">//返回父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通常简化为</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">Find</span>(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> parent[val] == val ? val:(parent[val] = <span class="built_in">Find</span>(parent[val]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按秩合并：用rank[]数组记录每个根节点对应的深度。初始化为1。合并时把rank较小的合并在较大的根节点上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="built_in">Find</span>(i);</span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">Find</span>(j);</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &gt; rank[y])</span><br><span class="line">        parent[y] = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">parent[x] = y;</span><br><span class="line">    <span class="keyword">if</span>(rank[x] == rank[y] &amp;&amp; x != y)<span class="comment">//如果深度相同且不是同一个根节点，则新的根节点深度加一</span></span><br><span class="line">        rank[y]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]"> ，但是很可能会破坏rank的准确性。</p></li></ul><h6 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h6><p>背包问题大体的解题模板是<strong>两层循环</strong>，分别遍历物品nums和背包容量target，然后写转移方程，根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法。</p><ol><li><p>01背包：外循环nums,内循环target,target倒序且target&gt;=nums[i];</p><p>例：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p></li><li><p>完全背包</p><ul><li>组合问题：外循环nums,内循环target,target正序且target&gt;=nums[i]</li><li>排列问题：外循环target,内循环nums,target正序且target&gt;=nums[i]</li></ul></li><li><p>分组背包：需要多重循环：外循环nums,内部循环根据题目的要求构建多重背包循环</p></li></ol><h4 id="STL-C"><a href="#STL-C" class="headerlink" title="STL(C++)"></a>STL(C++)</h4><ul><li>增删查：insert()、erase()、find()</li></ul><h6 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h6><ul><li><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec2</span><span class="params">(vec)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec2 = vec;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec2&#123;a, b, c&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec2</span><span class="params">(len, val)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>增</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + idx, val);</span><br></pre></td></tr></table></figure></li><li><p>删</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">pop_back</span>();<span class="comment">//尾部删除</span></span><br><span class="line"></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + idx);</span><br><span class="line"><span class="comment">//删除一段区间内的元素</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + idx, v.<span class="built_in">begin</span>() + idx + length);</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure></li></ul><h6 id="set"><a href="#set" class="headerlink" title="set"></a>set</h6><ul><li><p>find(T val); 返回指向对应元素的迭代器，若无对应元素，则返回指向end()。</p></li><li><p>erase(iterator); 删除迭代器指向的元素；</p></li><li><p>insert(T val); 插入元素</p></li><li><p>若T为结构体，则需重载 &lt; 运算符</p></li></ul><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><ul><li><h6 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列(priority_queue)"></a>优先队列(priority_queue)</h6></li><li><p>特殊队列。每次从队列中取出的是具有最高优先权的元素。\</p></li><li><p>自定义优先级：</p><ul><li><p>重载运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小优先</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> a.val &gt; b.val</span>;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;T, vector&lt;T&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h6 id="智能指针-shared-ptr"><a href="#智能指针-shared-ptr" class="headerlink" title="智能指针(shared_ptr)"></a>智能指针(shared_ptr)</h6><ul><li><h6 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h6></li><li></li></ul><h6 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h6><ul><li>static的用法<ol><li>静态局部变量</li><li>静态全局变量</li><li>静态函数</li><li></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;算法复杂度&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：指执行算法所需要的工作</summary>
      
    
    
    
    
    <category term="C++" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
    <category term="数据结构" scheme="http://kennyyyyyy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://kennyyyyyy.github.io/2021/09/16/%E5%89%91%E6%8C%87offer/"/>
    <id>http://kennyyyyyy.github.io/2021/09/16/%E5%89%91%E6%8C%87offer/</id>
    <published>2021-09-16T08:45:47.000Z</published>
    <updated>2021-10-06T06:12:07.330Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p>链表反转：</p><p>开始先设定三个指针，并进行初始化，如图</p><p><img src="/images/剑指offer/List_1.png" alt="List_1"></p><p>并将Pre的指向的Next指向NULL</p><p><img src="/images/剑指offer/List_2.png" alt="List_2"></p><p>开始循环，head指针后移，让Cur指针的Next指向Pre，然后使Pre = Cur，Cur = Head。直到链表尾</p><p><img src="/images/剑指offer/List_3.png" alt="List_3"></p><p><img src="/images/剑指offer/List_4.png" alt="List_4"></p></li></ul><ul><li><p>二分法模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;根据题目判断搜索条件&quot;</span>) &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>广度优先遍历（BFS）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; qu;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        qu.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left)</span><br><span class="line">            qu.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;right)</span><br><span class="line">            qu.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>深度优先遍历（DFS）</p><ul><li>例题：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></li><li>用dfs深度遍历加回溯法。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//循环查找，每个字符都可能是第一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">const</span> string&amp; word, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx == word.<span class="built_in">length</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= board.<span class="built_in">size</span>() || </span><br><span class="line">        col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || </span><br><span class="line">        board[row][col] != word[idx]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//将遍历过的，和word字符匹配的位置置为不可能出现的字符，起到visited数组的作用</span></span><br><span class="line">board[row][col] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行递归遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, row - <span class="number">1</span>, col, idx + <span class="number">1</span>) ||</span><br><span class="line"><span class="built_in">dfs</span>(board, word, row + <span class="number">1</span>, col, idx + <span class="number">1</span>) ||</span><br><span class="line"><span class="built_in">dfs</span>(board, word, row, col - <span class="number">1</span>, idx + <span class="number">1</span>) ||</span><br><span class="line"><span class="built_in">dfs</span>(board, word, row, col + <span class="number">1</span>, idx + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若此次遍历无匹配，则将数组字符还原</span></span><br><span class="line">board[row][col] = word[idx];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><p>清除字符串前后的空格符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>​    <img src="/images/剑指offer/image-20210929203313557.png" alt="image-20210929203313557"></p><ol><li><p>前序遍历：优先遍历根节点，然后是左子节点，再是右子节点</p><p>​    A-B-D-F-G-H-I-E-C</p></li><li><p>中序遍历：优先遍历左子节点，然后是根节点，再是右子节点</p><p>​    F-D-H-G-I-B-E-A-C</p></li><li><p>后序遍历：优先遍历左子节点，然后是右子节点，再是根节点</p><p>​    F-H-I-G-D-E-B-C-A</p></li></ol><ul><li><h5 id="二叉树转化成双向链表："><a href="#二叉树转化成双向链表：" class="headerlink" title="二叉树转化成双向链表："></a>二叉树转化成双向链表：</h5><p>用中序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head保存双向链表头节点，pre保存中序遍历时的前一个遍历的节点</span></span><br><span class="line">Node* pre = <span class="literal">NULL</span>, * head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">dfsm</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使首尾相连</span></span><br><span class="line">head-&gt;left = pre;</span><br><span class="line">    pre-&gt;right = head;</span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsm</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">dfsm</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">//如果pre为空，则此节点为第一个节点，所以记录下头节点</span></span><br><span class="line">    <span class="keyword">if</span> (!pre)</span><br><span class="line">head = root;</span><br><span class="line">    <span class="comment">//不为空则表示已经遍历过其他节点，因此使上一个节点指向此节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pre)</span><br><span class="line">    pre-&gt;right = root;</span><br><span class="line">    <span class="comment">//双向链表，因此此节点的左指针指向上一个节点</span></span><br><span class="line">root-&gt;left = pre;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="built_in">dfsm</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><h4 id="优先队列：priority-queue"><a href="#优先队列：priority-queue" class="headerlink" title="优先队列：priority_queue"></a>优先队列：priority_queue</h4><ul><li><p>包含在头文件 ‘queue’ 中,我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队.</p></li><li><p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列，小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序队列，大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="二叉搜索树：Binary-Search-Tree"><a href="#二叉搜索树：Binary-Search-Tree" class="headerlink" title="二叉搜索树：Binary Search Tree"></a>二叉搜索树：Binary Search Tree</h4><ul><li><p>若它的左子树不空，则左子树上所有结点的值均小于它的<a href="https://baike.baidu.com/item/根结点/9795570">根结点</a>的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为<a href="https://baike.baidu.com/item/二叉排序树/10905079">二叉排序树</a>。</p></li><li><p>中序遍历得到的结果使有序的</p><p><img src="images/剑指offer/image-20211003134458224.png" alt="image-20211003134458224"></p></li></ul></li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><h5 id="分组位运算："><a href="#分组位运算：" class="headerlink" title="分组位运算："></a>分组位运算：</h5><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p></li></ul><p>  相同数字异或为零</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;<span class="comment">//所有数字异或的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到第一位为1的位置</span></span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//通过是否为一将数组分为两组，分别进行异或运算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= n;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;链表反转：&lt;/p&gt;
&lt;p&gt;开始先设定三个指针，并进行初始化，如图&lt;/p&gt;
</summary>
      
    
    
    
    <category term="c++" scheme="http://kennyyyyyy.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="http://kennyyyyyy.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>FSM状态机</title>
    <link href="http://kennyyyyyy.github.io/2021/07/29/FSM%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://kennyyyyyy.github.io/2021/07/29/FSM%E7%8A%B6%E6%80%81%E6%9C%BA/</id>
    <published>2021-07-29T11:36:24.000Z</published>
    <updated>2021-07-29T13:47:44.736Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ol><li><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>FSM是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的机器。</p><p>是一种设计模式</p></li><li><h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;ol&gt;
&lt;li&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;FSM是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="unity" scheme="http://kennyyyyyy.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>3D RPG 学习笔记</title>
    <link href="http://kennyyyyyy.github.io/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://kennyyyyyy.github.io/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-23T07:38:31.000Z</published>
    <updated>2021-09-07T11:03:10.186Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="一、创建项目导入素材"><a href="#一、创建项目导入素材" class="headerlink" title="一、创建项目导入素材"></a>一、创建项目导入素材</h2><ol><li><h4 id="创建普通项目"><a href="#创建普通项目" class="headerlink" title="创建普通项目"></a>创建普通项目</h4><ul><li>在Package Manager中安装Universal RP</li><li>在Asset中创建Rendering =&gt; Universal Render Pipeline =&gt; Pipeline Asset(URP的设置文件)</li><li>将project setting中Graphics和Quality的渲染管线设置为刚创建的渲染管线设置文件</li><li>导入素材（Dog Knight PBR Polyart、 Low-Poly Simple Nature Pack 和 FREE Skybox Extended Shader）</li><li>在Edit =&gt; Edit=Render Pipeline =&gt; Universal Render Pipeline 中设置当前项目或当前素材的渲染管线</li><li>在Lighting =&gt; Environment 中设置天空盒的材质</li><li>注意Asset窗口和Inspect窗口的物体分类，方便管理</li></ul></li><li><h4 id="安装package"><a href="#安装package" class="headerlink" title="安装package"></a>安装package</h4><ul><li><p><strong>PolyBrush</strong> </p><p><img src="/images/3D-RPG-学习笔记/0.png" alt="PolyBrush "></p><ol><li><p>调整地面的高度(左键直接点击变高，control+左键点击变矮)</p><p><img src="/images/3D-RPG-学习笔记/1.png" alt="调整"></p><ul><li>Outer Radius：外圈大小</li><li>Inner Radius：内圈大小</li><li>Strength：变化强度</li><li>Direction：设置变化的方向。Brush normal：材质的法线方向</li><li>Brush Mirroring：沿坐标轴对称形成另一个笔刷同时进行相同操作</li></ul></li><li><p>柔化：将比较突出的棱角变的平滑。设置基本同上</p><p><img src="/images/3D-RPG-学习笔记/2.png" alt="柔化"></p></li><li><p>将当前物体刷上不同的颜色</p><p><img src="/images/3D-RPG-学习笔记/3.png" alt="颜色刷"></p><ul><li>如果需要将颜色刷到物体上，则物体材质的 shader 需要为 Polybrush=&gt; Shader 下的shader</li><li>Brush：根据笔刷的大小刷上颜色</li><li>Fill：填充区块</li><li>Flood：整个物体</li></ul></li><li><p>将预制体刷到场景当中</p><p><img src="/images/3D-RPG-学习笔记/4.png" alt="预制体刷"></p><ul><li>基本设置同1</li><li>将需要的prefab添加到Current Palette中，当前选中的prefab会在Brush Loadout中</li><li>Brush Loadout 中prefab下的拖动条表示此物体出现的概率</li><li>Hit Surface is Parent：将所有的画在平面上的物体都是此平面的子物体</li></ul></li><li><p>将texture刷到场景当中</p><ul><li>同4</li></ul></li></ol></li><li><p><strong>Pro Builder</strong> </p><p><img src="/images/3D-RPG-学习笔记/ProBuilder.png" alt=" Pro Builder "></p><ul><li>按住shift可以查看图标的功能</li><li></li></ul></li><li><p><strong>Pro Grids</strong></p><ul><li><p>安装ProGrids需要在Project Setting的Package Manger中打开允许preview</p><p><img src="/images/3D-RPG-学习笔记/EnablePreview.png" alt="Enable Preview"></p></li><li><p><img src="/images/3D-RPG-学习笔记/ProGrids.png" alt="Pro Grids"></p></li></ul><ol><li>设置物体移动时的单位距离</li><li>是否在Scene窗口中显示坐标轴</li><li>是否自动吸附：即按照1的设置在坐标轴上自动进行吸附，每次只移动1的距离</li><li>4</li><li>5</li><li>X 、Y、 Z、 3D均为Scene窗口显示的坐标轴</li></ol></li></ul></li><li><h4 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h4><p>自动导航</p></li><li><h4 id="点击移动"><a href="#点击移动" class="headerlink" title="点击移动"></a>点击移动</h4><ol><li><p><strong>自定义事件的注册和调用</strong></p><ol><li><p><img src="/images/3D-RPG-学习笔记/image-20210724155224166.png" alt="自定义事件"></p><ul><li><p>注册</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventVector3</span> : <span class="title">UnityEvent</span>&lt;<span class="title">Vector3</span>&gt; &#123; &#125;;</span><br><span class="line"><span class="comment">//声明类，继承UnityEvent，并需要参数Vector3</span></span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OnMouseClicked?.Invoke(hitInfo.point);</span><br><span class="line"><span class="comment">//当OnMouseClicked事件不为空时调用，并传入point信息</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p><strong>屏幕射线转为世界射线</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure></li><li><p><strong>单例模式</strong></p><p>方便事件函数等在外部的调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MouseManager Instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Instance != <span class="literal">null</span>)</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    Instance = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>事件注册和调用</strong></p></li></ol></li><li><h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><ul><li>鼠标指针图片切换</li><li>Cinemachine：多功能相机插件</li><li>Post Processing：后处理</li><li>Animator</li></ul></li><li><h4 id="Shader-Graph-遮挡剔除"><a href="#Shader-Graph-遮挡剔除" class="headerlink" title="Shader Graph 遮挡剔除"></a>Shader Graph 遮挡剔除</h4></li><li><h4 id="FSM-状态机"><a href="#FSM-状态机" class="headerlink" title="FSM 状态机"></a>FSM 状态机</h4></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;一、创建项目导入素材&quot;&gt;&lt;a href=&quot;#一、创建项目导入素材&quot; class=&quot;headerlink&quot; title=&quot;一、创建项目导入素材&quot;&gt;&lt;/a&gt;一、创建项目导入素材&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="unity" scheme="http://kennyyyyyy.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>每日一题</title>
    <link href="http://kennyyyyyy.github.io/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://kennyyyyyy.github.io/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2021-07-19T07:49:14.000Z</published>
    <updated>2021-09-15T09:34:03.991Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="面试题-10-02-变位词组"><a href="#面试题-10-02-变位词组" class="headerlink" title="面试题 10.02. 变位词组"></a><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></h3><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序</li></ul><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>思路</strong>：计数法。</p><p>计算每个字符串中所有字符出现的个数，将相同的放在同一个list中，完成分类</p></li><li><p><strong>代码</strong>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; GroupAnagrams(<span class="built_in">string</span>[] strs) &#123;</span><br><span class="line">        </span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; vs = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"><span class="comment">// 用字典储存相同的字符串</span></span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, IList&lt;<span class="built_in">string</span>&gt;&gt; pairs = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">        <span class="comment">// 用list储存出现过的key</span></span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; keysss = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环计算所有字符串中出现字符的次数，并通过key将字符串添加到相应的pairs中，最终结果key也添加到keysss列表中</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> str <span class="keyword">in</span> strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> key = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&#x27;0&#x27;</span>, <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> val <span class="keyword">in</span> str)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> keys = key.ToCharArray();</span><br><span class="line">                keys[val - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                key = <span class="keyword">new</span> <span class="built_in">string</span>(keys);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pairs.ContainsKey(key))</span><br><span class="line">            &#123;</span><br><span class="line">                pairs[key].Add(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                IList&lt;<span class="built_in">string</span>&gt; temp = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">                temp.Add(str);</span><br><span class="line">                pairs.Add(key, temp);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (!keysss.Contains(key))</span><br><span class="line">            &#123;</span><br><span class="line">                keysss.Add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出字典中的数据，存到list中</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> key <span class="keyword">in</span> keysss)</span><br><span class="line">        &#123;</span><br><span class="line">            vs.Add(pairs[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1877-数组中最大数对和的最小值"><a href="#1877-数组中最大数对和的最小值" class="headerlink" title="1877. 数组中最大数对和的最小值"></a><a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></h3><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a><strong>题解</strong>：</h4><ol><li><p><strong>分析</strong>：</p><p>最大与最小相加产生的数对和最小，即第k大的数和第k小的数相加，所得的最大数对和最小.</p><p>所以先将数组进行排序，然后依次下相加比较，即得出结果</p></li><li><p><strong>代码</strong>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinPairSum</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.Length;</span><br><span class="line">    Array.Sort(nums);</span><br><span class="line">    <span class="built_in">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxSum = Math.Max(maxSum, nums[i] + nums[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1893-检查是否区域内所有整数都被覆盖"><a href="#1893-检查是否区域内所有整数都被覆盖" class="headerlink" title="1893. 检查是否区域内所有整数都被覆盖"></a><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">1893. 检查是否区域内所有整数都被覆盖</a></h3><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>暴力解法，用一个 right-left+1 大小的数组来记录，直接通过二重循环，依次判断ranges中的每个[start,end]中是否包含[left,right]中的任意数字，如果包含，则对应的数组的值加一，循环完毕后再次循环判断数组中是否有0，有则为false，没有返回true。</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsCovered</span>(<span class="params"><span class="built_in">int</span>[][] ranges, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span>[] ltr = <span class="keyword">new</span> <span class="built_in">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ranges.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = ranges[i][<span class="number">0</span>]; j &lt;= ranges[i][<span class="number">1</span>]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt;= right &amp;&amp; j &gt;= left)</span><br><span class="line">            &#123;</span><br><span class="line">                ltr[j - left]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ltr[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1743-从相邻元素对还原数组"><a href="#1743-从相邻元素对还原数组" class="headerlink" title="1743. 从相邻元素对还原数组"></a><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/">1743. 从相邻元素对还原数组</a></h3><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>将数组中的数对用字典储存，则数组头或尾中字典的list的长度只有1，然后在通过字典，一次查找下一个</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">RestoreArray</span>(<span class="params"><span class="built_in">int</span>[][] adjacentPairs</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt; pairs = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">int</span>[] pair <span class="keyword">in</span> adjacentPairs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pairs.ContainsKey(pair[<span class="number">0</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    pairs.Add(pair[<span class="number">0</span>], <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!pairs.ContainsKey(pair[<span class="number">1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    pairs.Add(pair[<span class="number">1</span>], <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                pairs[pair[<span class="number">0</span>]].Add(pair[<span class="number">1</span>]);</span><br><span class="line">                pairs[pair[<span class="number">1</span>]].Add(pair[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> n = adjacentPairs.Length + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> pair <span class="keyword">in</span> pairs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> key = pair.Key;</span><br><span class="line">                <span class="keyword">if</span>(pair.Value.Count == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[<span class="number">0</span>] = key;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[<span class="number">1</span>] = pairs[nums[<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;<span class="built_in">int</span>&gt; vs = pairs[nums[i - <span class="number">1</span>]];</span><br><span class="line">                nums[i] = nums[i - <span class="number">2</span>] == vs[<span class="number">0</span>] ? vs[<span class="number">1</span>] : vs[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="704-二分查找-2021-9-7"><a href="#704-二分查找-2021-9-7" class="headerlink" title="704. 二分查找 2021/9/7"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a> 2021/9/7</h3><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>经典二分题，将数组分成两个部分，通过判断中间数字和目标数字的大小比较，然后进入目标数字存在的部分再次进行二分查找</p><p>在进行中间下标的计算时，若直接用 (left + right)/2 会导致一些特殊情况出现问题，所以使用 (right - left)/2 + left， 或直接使用位移运算 left + right &gt;&gt; 1。</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> right = nums.Length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> middle = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (nums[middle] == target)</span><br><span class="line">                    <span class="keyword">return</span> middle;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">                    left = middle + <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="470-用-Rand7-实现-Rand10-2021-9-6"><a href="#470-用-Rand7-实现-Rand10-2021-9-6" class="headerlink" title="470. 用 Rand7() 实现 Rand10()  2021/9/6"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a>  2021/9/6</h3><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>Rand7() 有 1~7 共7种数字，49种情况，所以从1-10依次分布如下</p><p>​    <img src="/images/每日一题/Rand7.png" alt="Rand7"></p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Rand10</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> ra = Rand7();</span><br><span class="line">    <span class="built_in">int</span> rb = Rand7();</span><br><span class="line">    <span class="built_in">int</span> idx;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ra = Rand7();</span><br><span class="line">        rb = Rand7();</span><br><span class="line">        idx = ra + (rb - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(idx &gt; <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> (idx) % <span class="number">10</span> + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1221-分割平衡字符串-2021-9-7"><a href="#1221-分割平衡字符串-2021-9-7" class="headerlink" title="1221. 分割平衡字符串 2021/9/7"></a><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串</a> 2021/9/<strong>7</strong></h3><h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>循环计算字符串中的L和R的字符个数，当两个个数相等时就表示出现一个平衡字符串，则计数器加一。</p></li></ol><ol><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BalancedStringSplit</span>(<span class="params"><span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">int</span> len = s.Length;</span><br><span class="line">    <span class="built_in">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i].Equals(<span class="string">&#x27;L&#x27;</span>))</span><br><span class="line">            L++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R++;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (L == R)</span><br><span class="line">        &#123;</span><br><span class="line">            L = <span class="number">0</span>;</span><br><span class="line">            R = <span class="number">0</span>;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="678-有效的括号字符串-2021-9-12"><a href="#678-有效的括号字符串-2021-9-12" class="headerlink" title="678. 有效的括号字符串  2021/9/12"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a>  2021/9/12</h3><h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><ul><li><p><strong>堆栈法：</strong></p><p>对字符串s逐个字符进行判断，有如下三种情况</p><ul><li>如果字符是左括号，则将其下标压入左括号栈</li><li>如果字符是星号，则将其下表压入星号栈</li><li>如果字符是右括号，则<ul><li>如果左括号栈中元素不为空，则将左括号栈中顶部元素出栈</li><li>如果左括号栈中元素为空，星号栈中元素不为空，则将星号栈中顶部元素出栈</li><li>如果两个栈中元素都为空，则此右括号无匹配元素，返回false</li></ul></li><li>字符串遍历完后，如果两个栈中元素都不为空，则依次将两个栈中的栈顶元素出栈，然后比较两个元素的大小，如果左括号栈的出栈下标比星号栈的出栈下标大，则表示左括号在星号的后面，无法匹配，返回false</li><li>最后判断左括号栈中的所有元素是否全部出栈，即所有左括号均有匹配，则返回true（星号可以为空字符，所以星号栈不需要做判断）</li></ul></li><li><p><strong>动态规划：</strong></p></li><li><p><strong>贪心：</strong></p></li></ul></li></ol><ol><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckValidString</span>(<span class="params"><span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> length = s.Length;</span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; left = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; aster = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i].Equals(<span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">                left.Push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i].Equals(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                aster.Push(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (left.Count &gt; <span class="number">0</span>)</span><br><span class="line">                    left.Pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (aster.Count &gt; <span class="number">0</span>)</span><br><span class="line">                    aster.Pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left.Count &gt; <span class="number">0</span> &amp;&amp; aster.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> leftIndex = left.Pop();</span><br><span class="line">            <span class="built_in">int</span> asterIndex = aster.Pop();</span><br><span class="line">            <span class="keyword">if</span> (leftIndex &gt; asterIndex)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.Count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="447-回旋镖的数量-2021-9-12"><a href="#447-回旋镖的数量-2021-9-12" class="headerlink" title="447. 回旋镖的数量  2021/9/12"></a><a href="https://leetcode-cn.com/problems/number-of-boomerangs/">447. 回旋镖的数量</a>  2021/9/12</h3><h4 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><ul><li><p>直接三重循环依次判断三个点是否组成等边三角形，然后返回值。（严重超时）</p></li><li><p>一个回旋镖可以看作三个点组成的一个等边三角形，所以要判断是否可以放置回旋镖即判断是否可以组成等边三角形，即找到两个点到同一个点的距离相同。每多一个点到顶点的距离相同，就会多两个可摆放的回旋镖（存在位置差异，n&gt;=2），即为n的排列组合。</p><center>An = n * (n - 1)</center><p>所以我们可以采用枚举的方法，依次判断所有点到其他点的距离，并用字典储存,再在最后进行判断。</p></li></ul></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">NumberOfBoomerangs</span>(<span class="params"><span class="built_in">int</span>[][] points</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//三重循环直接超时</span></span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span>[] p <span class="keyword">in</span> points)</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; cnt = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">int</span>[] q <span class="keyword">in</span> points)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> dis = (p[<span class="number">1</span>] - q[<span class="number">1</span>]) * (p[<span class="number">1</span>] - q[<span class="number">1</span>]) + (p[<span class="number">0</span>] - q[<span class="number">0</span>]) * (p[<span class="number">0</span>] - q[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!cnt.ContainsKey(dis))</span><br><span class="line">                cnt.Add(dis, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt[dis]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pair <span class="keyword">in</span> cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> m = pair.Value;</span><br><span class="line">            sum += m * (m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="524-通过删除字母匹配到字典里最长单词-2021-9-14"><a href="#524-通过删除字母匹配到字典里最长单词-2021-9-14" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词 2021/9/14"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a> 2021/9/14</h3><h4 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>题目描述不清楚，应为在第二个参数dictionary中找到最长的s的，且相同长度下字典序靠前的子字符串。</p><p>所以先将字典中的字符串按长度和字典序进行排序，然后依次判断是否为s的子串。</p><p>排序时需要先将 IList 转化为 List <code>var list = new List<string>(dictionary);</string></code> </p><p>然后使用List的Sort方法 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list.Sort((x, y) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x.Length == y.Length)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> x.CompareTo(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y.Length.CompareTo(x.Length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">FindLongestWord</span>(<span class="params"><span class="built_in">string</span> s, IList&lt;<span class="built_in">string</span>&gt; dictionary</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;(dictionary);</span><br><span class="line">    list.Sort((x, y) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(x.Length == y.Length)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span> x.CompareTo(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y.Length.CompareTo(x.Length);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> str <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.Length &amp;&amp; j &lt; s.Length)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == s[j])</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span> (i == str.Length)</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="162-寻找峰值-2021-9-15"><a href="#162-寻找峰值-2021-9-15" class="headerlink" title="162. 寻找峰值  2021/9/15"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a>  2021/9/15</h3><h4 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>该题需要时间复杂度为O(log n)，所以直接循环查找行不通。</p><p>因此需要使用二分法进行查找。</p><p>在二分查找时有四种情况</p><ul><li>nums[mid - 1] &lt; nums[mid] &lt; nums[mid + 1]，此时右边一定存在一个峰值</li><li>nums[mid - 1] &gt; nums[mid] &gt; nums[mid + 1]，此时左边一定存在一个峰值</li><li>nums[mid - 1] &gt; nums[mid] &lt; nums[mid + 1]，此时左边和右边都存在峰值</li><li>nums[mid - 1] &lt; nums[mid] &gt; nums[mid + 1]，此时mid 本生就为一个峰值</li></ul><p>对上述四种情况进行优化，可以分为两种情况，峰值在左边（右边）和峰值在右边（左边）和中间</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindPeakElement</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.Length;</span><br><span class="line">    <span class="built_in">int</span> mid;</span><br><span class="line">    <span class="built_in">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h3 id=&quot;面试题-10-02-变位词组&quot;&gt;&lt;a href=&quot;#面试题-10-02-变位词组&quot; class=&quot;headerlink&quot; title=&quot;面试题 10.02. 变位词组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://le</summary>
      
    
    
    
    <category term="每日一题" scheme="http://kennyyyyyy.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
    <category term="Leetcode" scheme="http://kennyyyyyy.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>VRTK学习记录</title>
    <link href="http://kennyyyyyy.github.io/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-06-06T11:27:43.000Z</published>
    <updated>2021-07-20T12:41:43.122Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>unity 2018.4.14<br>VRTK 3.3.0<br>steamVR 1.2.3</p><h3 id="键鼠模拟基本操作"><a href="#键鼠模拟基本操作" class="headerlink" title="键鼠模拟基本操作"></a>键鼠模拟基本操作</h3><ul><li>wasd控制人物移动</li><li>鼠标默认控制人物方向</li><li>alt切换控制模式<ul><li>鼠标：控制人物方向 —&gt;控制左右Controller的水平位置</li><li>ctrl：按住ctrl控制Controller的垂直位置</li></ul></li><li>tab切换左右Controller</li><li>ctrl 切换为抓取物体模式<ul><li>鼠标右键为右Controller抓取</li><li>鼠标左键为左Controller抓取</li></ul></li><li>shift 奔跑</li><li>q 发出射线<ul><li>鼠标右键代表Controller的扳机</li></ul></li></ul><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ol><li><p>新建场景，删除原本的Camera。</p></li><li><p>simulator为键鼠模拟；steamVr为设备操作；[VRSimulator_CameraRig]是VRTK的prefab，可直接使用；</p><p>RightController 为右控制器； LeftController 为左控制器； PlayArea 为需要传送时添加。</p><p><img src="/images/VRTK学习记录/基本结构.png" alt="基本结构"></p></li></ol><ol><li><p>VRTK SDK 需要添加VRTK_SDKManager 组件，并将子物体simulator和steamVR添加到组件中Setups的列表中（因为只需要键鼠模拟，所以只添加了simulator），然后将左右手控制器分别添加到Scripts Aliases中。</p><p><img src="/images/VRTK学习记录/VRTK_SDKManager.png" alt="Manager"></p></li></ol><ol><li><p>Simulator和SteamVR需要添加VRTK_SDK Setup 组件，并将Quick Select设置为相应的模式</p><p><img src="/images/VRTK学习记录/VRTK_SDKSetup.png" alt="Setup"></p></li></ol><h3 id="Controller相关"><a href="#Controller相关" class="headerlink" title="Controller相关"></a>Controller相关</h3><h4 id="控制器基本组件"><a href="#控制器基本组件" class="headerlink" title="控制器基本组件"></a>控制器基本组件</h4><p>​    <img src="/images/VRTK学习记录/Controller1.png" alt="Controller基本组件"></p><p>​    <img src="/images/VRTK学习记录/grab.png" alt="Controller抓取物体所需组件"></p><p>​    <img src="/images/VRTK学习记录/point.png" alt="Controller射线组件"></p><ul><li>​    射线类型可以为直线(VRTK_Straight Pointer Renderer)或贝塞尔曲线(VRTK_Bezier Pointer Renderer)</li></ul><p>​    <img src="/images/VRTK学习记录/Controller_UI.png" alt="Controller_UI"></p><ul><li>Heighlighter …. ； VRTK_UI Pointer为ui互动所必须组件</li></ul><h4 id="射线与场景互动"><a href="#射线与场景互动" class="headerlink" title="射线与场景互动"></a>射线与场景互动</h4><p>控制器上可以添加自定义脚本，使之可以与场景中的物体进行互动,脚本参考VRTK_ControllerPointerEvents_ListenerExample</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VRTK_ControllerPointerEvents_ListenerExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> showHoverState = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GetComponent&lt;VRTK_DestinationMarker&gt;() == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                VRTK_Logger.Error(VRTK_Logger.GetCommonMessage(VRTK_Logger.CommonMessageKeys.REQUIRED_COMPONENT_MISSING_FROM_GAMEOBJECT, <span class="string">&quot;VRTK_ControllerPointerEvents_ListenerExample&quot;</span>, <span class="string">&quot;VRTK_DestinationMarker&quot;</span>, <span class="string">&quot;the Controller Alias&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Setup controller event listeners</span></span><br><span class="line">            GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerEnter += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerIn);</span><br><span class="line">            <span class="keyword">if</span> (showHoverState)</span><br><span class="line">            &#123;</span><br><span class="line">                GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerHover += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerHover);</span><br><span class="line">            &#125;</span><br><span class="line">            GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerExit += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerOut);</span><br><span class="line">            GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerSet += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerDestinationSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DebugLogger</span>(<span class="params"><span class="built_in">uint</span> index, <span class="built_in">string</span> action, Transform target, RaycastHit raycastHit, <span class="built_in">float</span> distance, Vector3 tipPosition</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="built_in">string</span> targetName = (target ? target.name : <span class="string">&quot;&lt;NO VALID TARGET&gt;&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> colliderName = (raycastHit.collider ? raycastHit.collider.name : <span class="string">&quot;&lt;NO VALID COLLIDER&gt;&quot;</span>);</span><br><span class="line">            VRTK_Logger.Info(<span class="string">&quot;Controller on index &#x27;&quot;</span> + index + <span class="string">&quot;&#x27; is &quot;</span> + action + <span class="string">&quot; at a distance of &quot;</span> + distance + <span class="string">&quot; on object named [&quot;</span> + targetName + <span class="string">&quot;] on the collider named [&quot;</span> + colliderName + <span class="string">&quot;] - the pointer tip position is/was: &quot;</span> + tipPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerIn</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER IN&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerOut</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER OUT&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerHover</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER HOVER&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerDestinationSet</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER DESTINATION&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h3 id=&quot;配置环境&quot;&gt;&lt;a href=&quot;#配置环境&quot; class=&quot;headerlink&quot; title=&quot;配置环境&quot;&gt;&lt;/a&gt;配置环境&lt;/h3&gt;&lt;p&gt;unity 2018.4.14&lt;br&gt;VRTK 3.3.0&lt;br&gt;steam</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="错误总结" scheme="http://kennyyyyyy.github.io/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="经验" scheme="http://kennyyyyyy.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://kennyyyyyy.github.io/2021/04/25/Web/"/>
    <id>http://kennyyyyyy.github.io/2021/04/25/Web/</id>
    <published>2021-04-25T08:12:15.000Z</published>
    <updated>2021-04-26T09:49:10.622Z</updated>
    
    <content type="html"><![CDATA[<!--  more --><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>外部JavaScript脚本的调用：<code>&lt;script  src = &quot;../../路径&quot;&gt;&lt;/scripts&gt;</code></p><p>NaN：not a Number</p><p>逻辑运算（&amp;&amp;）：谁在表达式中起关键性作用，结果就是谁<br>例：<code>true &amp;&amp; 4 &amp;&amp; “aaa”</code><br>x输出 “aaa”</p><p>0 &nbsp;&nbsp; “0” &nbsp;&nbsp; “” &nbsp;&nbsp; null &nbsp;&nbsp; NaN &nbsp;&nbsp; undefined  =&gt; false</p><p>用 new 创建的对象为引用类型（object）</p><h2 id="预定义函数"><a href="#预定义函数" class="headerlink" title="预定义函数"></a>预定义函数</h2><p>parseInt():将字符转化为Int</p><p>eval(string):string为一个可计算的字符串或者是可执行的表达式</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>可以为一个类创建一个共有的模板<br>新new的对象会调用模板中的属性</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>cars = [“0”, 2, new Object()];</code>//数组中的元素可以不同</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join() : 将数组中的元素拼接成字符串，默认连接符为“,”</p><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>splice(index, howmany, [item1, … , itemx], item, …) : howmany为从index的位置开始删除元素的个数，后面的为插入的元素</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort(function(a,b){return b - a}); 数字的降序排列<br><br>sort(function(a,b){return a - b}); 数字的升序排列</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>unix时间戳，从1970.1.1到xxxx.xx.xx的毫秒数</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="round-四舍五入"><a href="#round-四舍五入" class="headerlink" title="round() 四舍五入"></a>round() 四舍五入</h3><h3 id="random-返回0-1的随机数"><a href="#random-返回0-1的随机数" class="headerlink" title="random() 返回0~1的随机数"></a>random() 返回0~1的随机数</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;!--  more --&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;外部JavaScript脚本的调用：&lt;code&gt;&amp;lt;script  src = &amp;quot;../../路</summary>
      
    
    
    
    <category term="Web" scheme="http://kennyyyyyy.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>TANKS! Unity Tutorial 项目学习记录</title>
    <link href="http://kennyyyyyy.github.io/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-13T15:25:35.000Z</published>
    <updated>2021-07-23T08:11:27.216Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="SmoothDamp"><a href="#SmoothDamp" class="headerlink" title="SmoothDamp"></a>SmoothDamp</h3><p>平滑的改变当前值至另一个值<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mathf.SmoothDamp(<span class="built_in">float</span> current, <span class="built_in">float</span> target, <span class="keyword">ref</span> <span class="built_in">float</span> currentVelocity, <span class="built_in">float</span> smoothTime, <span class="built_in">float</span> maxSpeed = Mathf.Infinity, <span class="built_in">float</span> deltaTime = Time.deltaTime);</span><br><span class="line"></span><br><span class="line"><span class="function">Vector3 <span class="title">SmoothDamp</span>(<span class="params">Vector3 current, Vector3 target, <span class="keyword">ref</span> Vector3 currentVelocity, <span class="built_in">float</span> smoothTime, <span class="built_in">float</span> maxSpeed = Mathf.Infinity, <span class="built_in">float</span> deltaTime = Time.deltaTime</span>)</span>;</span><br></pre></td></tr></table></figure></p><font color="#c77eb5" size="2"> *current*：当前位置 </font><font color="#c77eb5" size="2"> *target*：尝试达到的目标值 </font><font color="#c77eb5" size="2"> *currentVelocity*：当前速度，该值在每次调用时都会由函数修改。</font><font color="#c77eb5" size="2"> *smoothTime*：达到目标值的时间 </font><font color="#c77eb5" size="2"> *maxSpeed*：最大速度 </font><font color="#c77eb5" size="2"> *deltaTime*：默认为Time.deltatime </font><font color="#c77eb5" size="2"> *ref关键字*：相当于c的指针传参，及引用传参。 </font><h3 id="InverseTransformPoint"><a href="#InverseTransformPoint" class="headerlink" title="InverseTransformPoint"></a>InverseTransformPoint</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">InverseTransformPoint</span>(<span class="params">Vector3 position</span>)</span>;</span><br></pre></td></tr></table></figure><p>将position这个Vector3类型变量转化为 以V3的世界坐标为零点基准的情况下 position相对于V3的坐标值。</p><h3 id="Physics"><a href="#Physics" class="headerlink" title="Physics"></a>Physics</h3><h4 id="Physics-OverlapSphere"><a href="#Physics-OverlapSphere" class="headerlink" title="Physics.OverlapSphere"></a>Physics.OverlapSphere</h4><p>检测范围内的Collider<br><code> public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal);</code></p><font color="#c77eb5" size="2"> *position*：圆心 </font><font color="#c77eb5" size="2"> *radius*：检测半径 </font><font color="#c77eb5" size="2"> *layerMask*：检测层级 </font><font color="#c77eb5" size="2"> *queryTriggerInteraction*：判断是否应该检测Trigger </font><h3 id="Rigidbody"><a href="#Rigidbody" class="headerlink" title="Rigidbody"></a>Rigidbody</h3><h4 id="targetRigidbody-AddExplosionForce"><a href="#targetRigidbody-AddExplosionForce" class="headerlink" title="targetRigidbody.AddExplosionForce"></a>targetRigidbody.AddExplosionForce</h4><p>爆炸力将随着到物体的距离变小。<br><code> public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)); </code></p><font color="#c77eb5" size="2"> *explosionForce*：爆炸的力量（会根据距离变化）</font><font color="#c77eb5" size="2"> *explosionPosition*：爆炸中心 </font><font color="#c77eb5" size="2"> *explosionRadius*：爆炸半径 </font><font color="#c77eb5" size="2"> *upwardsModifier*：可以调整爆炸的位置，让物体有被炸起来向上的效果，但爆炸本身的位置不变 </font><font color="#c77eb5" size="2"> *ForceMode*：对物体施加力的方法 </font><h2 id="Manual"><a href="#Manual" class="headerlink" title="Manual"></a>Manual</h2><h3 id="相机的两种投影方式"><a href="#相机的两种投影方式" class="headerlink" title="相机的两种投影方式"></a>相机的两种投影方式</h3><p><img src="/images/Tanks项目学习记录/00.jpg" alt="相机的两种投影方式(prejection)"></p><p>透视投影(Perspective)(左): 正交投影的观察体是长方体，它使用一组平行投影将三维对象投影到投影平面上去，即场景中的物体没有近大远小的效果。</p><p>正交投影(Orthographic)(右): 透视投影的观察体是视锥体，它使用一组由投影中心产生的放射投影线，将三维对象投影到投影平面上去，即屏幕中的物体存在透视效果</p><h3 id="Aodio-Mixer"><a href="#Aodio-Mixer" class="headerlink" title="Aodio Mixer"></a>Aodio Mixer</h3><p>类似于Windows的音量合成器，但更为复杂<br>可以用来进行多种音效的混合表现<br>要用可百度学习</p><h2 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h2><h3 id="移动和旋转问题"><a href="#移动和旋转问题" class="headerlink" title="移动和旋转问题"></a>移动和旋转问题</h3><p>有问题的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 move = Vector3.forward * m_MovementInputValue * Time.deltaTime * m_Speed;</span><br><span class="line">m_Rigidbody.MovePosition(m_Rigidbody.position + move);</span><br></pre></td></tr></table></figure><p>此代码会导致物体旋转后会继续以世界坐标的z轴为前后方向，而导致旋转看起来不起作用，像坐标轴没有跟着旋转一样</p><hr><p>正确的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 move = transform.forward * m_MovementInputValue * Time.deltaTime * m_Speed;</span><br><span class="line">m_Rigidbody.MovePosition(m_Rigidbody.position + move);</span><br></pre></td></tr></table></figure><p>修改后一切正常</p><hr><div class="panel panel-warning">    <div class="panel-title">Vector3.forward和transform.forward的区别</div>    <div class="panel-body">        <p>Vector3.forward的值永远是世界坐标（0,0,1），<br>而transform.forward是世界坐标对应的物体坐标的轴的向量</p>    </div>    </div><h2 id="代码记录"><a href="#代码记录" class="headerlink" title="代码记录"></a>代码记录</h2><h3 id="相机的平滑运动"><a href="#相机的平滑运动" class="headerlink" title="相机的平滑运动"></a>相机的平滑运动</h3><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>移动相关</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FindAveragePosition();</span><br><span class="line"></span><br><span class="line">    transform.position = Vector3.SmoothDamp(transform.position, m_DesiredPosition, <span class="keyword">ref</span> m_MoveVelocity, m_DampTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 找到多个Player的中间位置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FindAveragePosition</span>(<span class="params"></span>)                      </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3 averagePos = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录还存在的Player的数量</span></span><br><span class="line">    <span class="built_in">int</span> numTargets = <span class="number">0</span>;                                 </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_Targets.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_Targets[i].gameObject.activeSelf)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录Player的位置和</span></span><br><span class="line">        averagePos += m_Targets[i].position;            </span><br><span class="line">        numTargets++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到中间位置</span></span><br><span class="line">    <span class="keyword">if</span> (numTargets &gt; <span class="number">0</span>)                              </span><br><span class="line">        averagePos /= numTargets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证相机的y轴不移动</span></span><br><span class="line">    averagePos.y = transform.position.y;               </span><br><span class="line"></span><br><span class="line">    m_DesiredPosition = averagePos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>缩放相关</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Zoom</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">float</span> requiredSize = FindRequiredSize();</span><br><span class="line">    m_Camera.orthographicSize = Mathf.SmoothDamp(m_Camera.orthographicSize, requiredSize, <span class="keyword">ref</span> m_ZoomSpeed, m_DampTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 找到需要的相机的最大大小</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回相机的合适大小<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">float</span> <span class="title">FindRequiredSize</span>(<span class="params"></span>)                    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获得相机将要到达的位置的相对坐标</span></span><br><span class="line">    Vector3 desiredLocalPos = transform.InverseTransformPoint(m_DesiredPosition);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> size = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得还存活的Player的所需要的屏幕最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_Targets.Length; i++)                                      </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_Targets[i].gameObject.activeSelf)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转化Player的坐标为相对值</span></span><br><span class="line">        Vector3 targetLocalPos = transform.InverseTransformPoint(m_Targets[i].position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Player中心位置与Player位置的差值</span></span><br><span class="line">        Vector3 desiredPosToTarget = targetLocalPos - desiredLocalPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算x/y轴的相对大小，并取最大值</span></span><br><span class="line">        size = Mathf.Max (size, Mathf.Abs (desiredPosToTarget.y));                  </span><br><span class="line"></span><br><span class="line">        size = Mathf.Max (size, Mathf.Abs (desiredPosToTarget.x) / m_Camera.aspect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加缓冲区</span></span><br><span class="line">    size += m_ScreenEdgeBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止屏幕缩小</span></span><br><span class="line">    size = Mathf.Max(size, m_MinSize);                                              </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><h3 id="炮弹的爆炸和伤害判定"><a href="#炮弹的爆炸和伤害判定" class="headerlink" title="炮弹的爆炸和伤害判定"></a>炮弹的爆炸和伤害判定</h3><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>爆炸相关</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得爆炸范围内的坦克collider</span></span><br><span class="line">    Collider[] colliders = Physics.OverlapSphere(transform.position, m_ExplosionRadius, m_TankMask);<span class="comment">//获得爆炸范围内的坦克collider</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Rigidbody targetRigidbody = colliders[i].GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!targetRigidbody)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对范围内的tank的刚体施加一个力</span></span><br><span class="line">        targetRigidbody.AddExplosionForce(m_ExplosionForce, transform.position, m_ExplosionRadius);<span class="comment">//将</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Tank的血量属性</span></span><br><span class="line">        TankHealth tankHealth = targetRigidbody.GetComponent&lt;TankHealth&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tankHealth)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算伤害</span></span><br><span class="line">        <span class="built_in">float</span> damage = CalculateDamage(targetRigidbody.position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//造成伤害</span></span><br><span class="line">        tankHealth.TakeDamage(damage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//粒子效果和声音的播放</span></span><br><span class="line">    m_ExplosionParticles.transform.parent = <span class="literal">null</span>;</span><br><span class="line">    m_ExplosionParticles.Play();</span><br><span class="line">    m_ExplosionAudio.Play();</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">    Destroy(m_ExplosionParticles.gameObject, m_ExplosionParticles.main.duration);</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>计算伤害</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">float</span> <span class="title">CalculateDamage</span>(<span class="params">Vector3 targetPosition</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算Tank和炸弹的向量</span></span><br><span class="line">    Vector3 explosionToTarget = targetPosition - transform.position;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得距离</span></span><br><span class="line">    <span class="built_in">float</span> explosionDistance = explosionToTarget.magnitude;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算相对距离比例</span></span><br><span class="line">    <span class="built_in">float</span> relativeDistance = (m_ExplosionRadius - explosionDistance) / m_ExplosionRadius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算伤害</span></span><br><span class="line">    <span class="built_in">float</span> damage = relativeDistance * m_MaxDamage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排除Tank在边缘时 相对比例 为负数的情况</span></span><br><span class="line">    damage = Mathf.Max(<span class="number">0</span>, damage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> damage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>     </div></div>    </div><h2 id="子弹的对象池模式"><a href="#子弹的对象池模式" class="headerlink" title="子弹的对象池模式"></a>子弹的对象池模式</h2><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>子弹</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShellExplosion</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPooler</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ...一些其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成时的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSpawning</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="comment">/* 初始化相关 */</span></span><br><span class="line">        StartCoroutine(Spawning());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用协程，一定时间后重置</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Spawning</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> m_TimeToFalse;</span><br><span class="line">        m_ExplosionParticles.transform.parent = gameObject.transform;</span><br><span class="line">        m_ExplosionParticles.transform.position = gameObject.transform.position;</span><br><span class="line">        gameObject.transform.position = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>对象池</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShellPool</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对象池</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> tag:名称</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> prefab;预制体</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> size:对象池的大小</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pool</span>                          </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> tag;</span><br><span class="line">        <span class="keyword">public</span> GameObject prefab;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象池的父物体</span></span><br><span class="line">    <span class="keyword">public</span> Transform parentTransform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Pool&gt; poolList;</span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, Queue&lt;GameObject&gt;&gt; poolDictionary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ShellPool shellPoolInsatance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shellPoolInsatance == <span class="literal">null</span>)</span><br><span class="line">            shellPoolInsatance = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (shellPoolInsatance != <span class="keyword">this</span>)</span><br><span class="line">            Destroy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化生成所有对象池的物体，并添加到对象池字典中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        poolDictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Queue&lt;GameObject&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> pool <span class="keyword">in</span> poolList)</span><br><span class="line">        &#123;</span><br><span class="line">            Queue&lt;GameObject&gt; tPool = <span class="keyword">new</span> Queue&lt;GameObject&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pool.size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                GameObject tShell = Instantiate(pool.prefab, parentTransform,<span class="literal">true</span>);</span><br><span class="line">                tShell.SetActive(<span class="literal">false</span>);</span><br><span class="line">                tPool.Enqueue(tShell);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            poolDictionary.Add(pool.tag, tPool);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 从对象池中生成（获得）物体</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;tag&quot;&gt;</span>物体名称<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;position&quot;&gt;</span>生成位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rotation&quot;&gt;</span>生成旋转<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回生成的对象<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">SpawnFromPool</span>(<span class="params"><span class="built_in">string</span> tag, Vector3 position, Quaternion rotation</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断是否存在需要生成的物体</span></span><br><span class="line">        <span class="keyword">if</span>(!poolDictionary.ContainsKey(tag))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(tag + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GameObject theSpawnObj = poolDictionary[tag].Dequeue();</span><br><span class="line">        Debug.Log(theSpawnObj);</span><br><span class="line"></span><br><span class="line">        theSpawnObj.SetActive(<span class="literal">true</span>);</span><br><span class="line">        theSpawnObj.transform.position = position;</span><br><span class="line">        theSpawnObj.transform.rotation = rotation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得IPooler接口，并调用初始化函数</span></span><br><span class="line">        IPooler poolSpawn = theSpawnObj.GetComponent&lt;IPooler&gt;();</span><br><span class="line">        <span class="keyword">if</span> (poolSpawn != <span class="literal">null</span>)</span><br><span class="line">            poolSpawn.OnSpawning();</span><br><span class="line"></span><br><span class="line">        poolDictionary[tag].Enqueue(theSpawnObj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> theSpawnObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>IPooler</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口，方便生成物体后的初始化函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IPooler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSpawning</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><h3 id="游戏循环模式-协程完成"><a href="#游戏循环模式-协程完成" class="headerlink" title="游戏循环模式(协程完成)"></a>游戏循环模式(协程完成)</h3><p><img src="/images/Tanks项目学习记录/游戏循环.jpg" alt="循环模式"><br><img src="/images/Tanks项目学习记录/流程控制.jpg" alt="Tanks的流程控制"></p><h3 id="游戏管理模式"><a href="#游戏管理模式" class="headerlink" title="游戏管理模式"></a>游戏管理模式</h3><p>一些游戏物体的代码不需要继承MonoBehaviour（无需挂载），只当实例化后赋予其GameObject或直接更具里面的信息实例化一个物体。例如此例中的Tank 或者 一些随机地图的部分地图信息</p><h3 id="可能的心得-……"><a href="#可能的心得-……" class="headerlink" title="可能的心得(……..)"></a>可能的心得(……..)</h3><ul><li>协程内调用多个协程，只会在上一个协程调用完成后，下一个协程才会开始</li><li>回合制的游戏可以使用协程控制游戏流程，开始、游玩、结束，都很清晰明了</li><li>写代码时因该将所有功能块写成函数，可以让代码结构更清晰</li><li>尽量将可能的变量全定义在类的开头，理由同上</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h2&gt;&lt;h3 id=&quot;SmoothDamp&quot;&gt;&lt;a href=&quot;#SmoothDamp&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>部署网站的记录</title>
    <link href="http://kennyyyyyy.github.io/2021/04/13/Demo/"/>
    <id>http://kennyyyyyy.github.io/2021/04/13/Demo/</id>
    <published>2021-04-13T08:56:13.000Z</published>
    <updated>2021-09-16T08:46:56.393Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="网页属性"><a href="#网页属性" class="headerlink" title="网页属性"></a>网页属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建时间</span><br><span class="line">categories: 分类</span><br><span class="line">tags:标签</span><br><span class="line">- Tag0</span><br><span class="line">- Tag1</span><br><span class="line">- Tag2</span><br><span class="line">sticky: 100数字越大优先级越高</span><br><span class="line">pic:指定预览图片，图片位置为同级目录下的同名文件夹</span><br><span class="line">comments: <span class="literal">true</span>是否开放评论</span><br><span class="line">toc: <span class="literal">true</span>是否生成目录</span><br><span class="line">only:在什么位置显示，如果没有就全部显示</span><br><span class="line">- home</span><br><span class="line">- category</span><br><span class="line">- tag</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>提示信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% alertbox success <span class="string">&quot;成功&quot;</span> %&#125;</span><br><span class="line">&#123;% alertbox danger <span class="string">&quot;危险&quot;</span> %&#125;</span><br><span class="line">&#123;% alertbox info <span class="string">&quot;消息&quot;</span> %&#125;</span><br><span class="line">&#123;% alertbox warning <span class="string">&quot;警告&quot;</span> %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="折叠相关"><a href="#折叠相关" class="headerlink" title="折叠相关"></a>折叠相关</h3><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>折叠的折叠框</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% collapse 折叠框的标题 %&#125;</span><br><span class="line"></span><br><span class="line">被折叠的内容 1</span><br><span class="line">被折叠的内容 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;% endcollapse %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl active">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>预先打开的折叠框</span></div>    <div class="xContent pre-open"><div class="inner">        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% collapse 折叠框的标题 open %&#125;</span><br><span class="line"></span><br><span class="line">被折叠的内容 1</span><br><span class="line">被折叠的内容 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;% endcollapse %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><div class="panel panel-info">    <div class="panel-title">提示框</div>    <div class="panel-body">        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% colorpanel TYPE 面板框的标题 %&#125;</span><br><span class="line"></span><br><span class="line">面板里的内容 1</span><br><span class="line">面板里的内容 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;% endcolorpanel %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>type是框的类型<br>·successs<br>·danger<br>·info<br>·warning</p>    </div>    </div><h3 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h3><p>图片需要放在source文件夹下的images下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](/images/图片名称.jpg)  </span><br><span class="line"></span><br><span class="line">![图片描述](/images/文件夹/图片名称.jpg) </span><br></pre></td></tr></table></figure></p><p><img src="/images/Demo/00.jpg" alt="图片插入"> </p><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=<span class="comment">#00ffff&gt;color=#00ffff&lt;/font&gt;</span></span><br></pre></td></tr></table></figure><font color="#00ffff">color=#00ffff</font><p><a href="https://www.5tu.cn/colors/yansebiao.html">颜色表参考</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://candinya.com/posts/Kratos-Rebirth-Manual/#%E5%AE%89%E8%A3%85%E6%8F%90%E7%A4%BA">部分参考来源</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;h3 id=&quot;网页属性&quot;&gt;&lt;a href=&quot;#网页属性&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="错误总结" scheme="http://kennyyyyyy.github.io/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="经验" scheme="http://kennyyyyyy.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
