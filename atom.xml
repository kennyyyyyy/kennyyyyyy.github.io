<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Imperio</title>
  
  <subtitle>Boy♂ Next♂ Door~</subtitle>
  <link href="http://kennyyyyyy.github.io/atom.xml" rel="self"/>
  
  <link href="http://kennyyyyyy.github.io/"/>
  <updated>2023-08-06T15:14:29.790Z</updated>
  <id>http://kennyyyyyy.github.io/</id>
  
  <author>
    <name>kennyyy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>嵌入式基础</title>
    <link href="http://kennyyyyyy.github.io/2023/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <id>http://kennyyyyyy.github.io/2023/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/</id>
    <published>2023-08-05T14:38:47.000Z</published>
    <updated>2023-08-06T15:14:29.790Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><ul><li><strong>串口</strong>：串口是一种用于在计算机和外部设备之间进行通信的接口。串口可以通过传输一位一位的数据来实现通信，常见的有RS-232串口和USB串口。在嵌入式领域，串口通常被用于连接开发板和计算机，用于传输数据、进行调试或者配置设备。串口通常包含发送线、接收线和地线等信号线。</li><li><strong>MCU</strong>：MCU（Microcontroller Unit）是一种集成了微处理器核心、存储器、输入/输出接口和其他外设模块的单芯片微型计算机系统。</li></ul><h5 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h5><ul><li><p><img src="/images/嵌入式基础/image-20230806230514052.png" alt="image-20230806230514052"></p><p>该电路中电容的作用？<font color="red">上电后让NRST保持一段时间低电平（电容电压不突变），使其复位。</font></p></li></ul><h4 id="1、单片机简介"><a href="#1、单片机简介" class="headerlink" title="1、单片机简介"></a>1、单片机简介</h4><p><img src="/images/嵌入式基础/image-20230805225149234.png" alt="image-20230805225149234"></p><h4 id="2、STM32"><a href="#2、STM32" class="headerlink" title="2、STM32"></a>2、STM32</h4><ol><li><p>ST：半导体；M：MCU/MPU；32位</p></li><li><p><a href="www.stmcu.org.cn">ST中文社区网</a>  </p></li><li><p>命名规则</p><p><img src="/images/嵌入式基础/image-20230805232639235.png" alt="image-20230805232639235"></p></li></ol><h4 id="3、最小系统和IO分配"><a href="#3、最小系统和IO分配" class="headerlink" title="3、最小系统和IO分配"></a>3、最小系统和IO分配</h4><ol><li>最小系统：保证MCU正常工作的最小电路组成单元</li><li>优先分配特定外设IO，然后分配通用IO，最后微调</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h5 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;串口&lt;/strong&gt;：串口是一种用于在计算机和</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>毕设记录</title>
    <link href="http://kennyyyyyy.github.io/2022/12/06/%E6%AF%95%E8%AE%BE%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2022/12/06/%E6%AF%95%E8%AE%BE%E8%AE%B0%E5%BD%95/</id>
    <published>2022-12-06T05:33:31.000Z</published>
    <updated>2023-05-16T15:41:55.901Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="选题描述"><a href="#选题描述" class="headerlink" title="选题描述"></a>选题描述</h4><p>主要内容：基于Unity3D引擎的一个2D平台跳跃类游戏。玩家可以在多个地图之中活动，每个地图上会存在一些对应的功能或物体。例如某个地图中存在商店，可以给玩家提供升级武器或购买道具的选项。一些地图中则存在怪物，打败怪物后会掉落金币，用于商店物品的购买。玩家可以随时存档，存档会保存当前玩家的状态数据和位置信息等，下次进入会读取上次的信息，继续游戏。</p><h4 id="策划（旧）（地图设计太难）"><a href="#策划（旧）（地图设计太难）" class="headerlink" title="策划（旧）（地图设计太难）"></a>策划（旧）（地图设计太难）</h4><h5 id="总目标"><a href="#总目标" class="headerlink" title="总目标"></a>总目标</h5><ul><li>复刻空洞骑士</li><li>类银河恶魔城游戏设计 </li><li>项目通过GitHub来管理</li><li>资源先通过免费素材代替</li></ul><h5 id="系统设计分析"><a href="#系统设计分析" class="headerlink" title="系统设计分析"></a>系统设计分析</h5><h6 id="玩家模块设计"><a href="#玩家模块设计" class="headerlink" title="玩家模块设计"></a>玩家模块设计</h6><ol><li>移动<ul><li>正常左右移动</li><li>冲刺<ul><li>游玩过程中获得</li><li>只能水品方向冲刺</li></ul></li></ul></li><li>跳跃<ul><li>通过按键时间的长短控制跳跃高度</li><li>二段跳需要游玩过程中获得</li></ul></li><li>攻击<ul><li>攻击分为 上下左右 四个方向</li><li>攻击在一些特定的物体（无法破坏的物体，例如地面尖刺、怪物护盾等）上，会将自己击退</li></ul></li><li>基础属性<ul><li>血量：血量降到零时，玩家或死亡。可以通过血瓶回复血量，通过商店购买对应的物品提升上限</li><li>攻击力：可以通过购买对应物品升级攻击力（升级武器）</li></ul></li><li>基础物品<ul><li>血瓶：需要从NPC中购买（或地图中探索获得），血瓶可以重复使用，只存在使用次数的限制。玩家每次 存档或复活都会使使用次数回满。商店处可以购买使次数提升的物品</li></ul></li><li></li></ol><h6 id="敌人模块设计"><a href="#敌人模块设计" class="headerlink" title="敌人模块设计"></a>敌人模块设计</h6><ol><li>AI逻辑<ul><li>采用状态机来实现敌人的移动和攻击。目前考虑：普通怪物的状态机可以复用（移动，攻击、防御、死亡等），BOSS的状态机单独设计（二阶段的模式设计）</li></ul></li><li>动画<ul><li>动画采用帧动画，先找免费素材</li></ul></li></ol><h6 id="地图模块设计"><a href="#地图模块设计" class="headerlink" title="地图模块设计"></a>地图模块设计</h6><ol><li>敌人刷新<ul><li>游戏每次重新加载，地图中的敌人便会进行刷新。（重新加载包括：死亡后复活、存档后读档、传送等）</li></ul></li><li>地图传送<ul><li>一些地图当中存在传送点，玩家可以在所有已经激活的传送点之间进行传送</li></ul></li><li>商店<ul><li>商店即为NPC，地图中会存在NPC，他们会出售一些增益物品（武器升级，功能升级等）</li></ul></li><li>地图总览<ul><li>玩家所有探索过的地图区域都可以在其中预览</li><li>特定NPC出可以购买地图，能让玩家提前预览未探索的区域</li></ul></li><li>地图探索<ul><li>地图中存在一些特殊物体，可以通过攻击互动</li><li>地图中存在隐藏路径，有一些奖励</li></ul></li><li>地图设计<ul><li>钥匙与锁<ul><li>能力锁：一些地图的点需要获得某些能力之后才能到达。一些高度需要二段跳才能跳上去，一些坑需要冲刺才能通过</li><li>挑战锁：有些地方需要打败特殊敌人才能解锁（打包BOSS）</li><li>物品锁：可以通过钥匙打开一些门，开通近路</li></ul></li><li>回路探索：</li></ul></li></ol><h6 id="NPC模块设计"><a href="#NPC模块设计" class="headerlink" title="NPC模块设计"></a>NPC模块设计</h6><ol><li>NPC为地图中功能的载体（或许有任务系统），可以通过和NPC对话来调用相关的功能</li></ol><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><h3 id="（新）"><a href="#（新）" class="headerlink" title="（新）"></a>（新）</h3><p>改为类死亡细胞</p><h5 id="随机地图设计"><a href="#随机地图设计" class="headerlink" title="随机地图设计"></a>随机地图设计</h5><p>​    使用 Edgar插件，采用预先设计模板和随机连接的方式生成地图</p><h6 id="Edgar"><a href="#Edgar" class="headerlink" title="Edgar"></a>Edgar</h6><ol><li><p>制作地图模板（包括房间和连接），通过Level Graph对设计房间连接规则</p><ul><li>普通的Level Graph中房间节点无房间类型，若需要特殊房间则要为此节点单独添加模板</li><li>通过Custom Input Task 可以对其进行拓展，新增类需要继承DungeonGeneratorInputBaseGrid2D。例如新增房间类型，每种类型有对应的模板，这样就无需对每个房间单独添加，只需要选择类型即可</li><li>在room templates中，每个tile必须至少于两个tile连接</li></ul></li><li><p>Dungeon generator（地图生成器）/ Platformer generator </p><ul><li>它是一个组件，存在Level Graph字段和Post Processing字段等</li><li>定义了地图的生成规则</li></ul></li><li><p>后处理（Post Processing）</p><ul><li>用户后处理脚本需继承DungeonGeneratorPostProcessingGrid2D，并重载Run函数，后处理逻辑由Run执行</li><li>后处理的逻辑在地图生成后执行。例如将角色的位置移动至出生点、生成敌人等</li><li></li></ul></li><li><p>地图案例</p><p><img src="/images/毕设记录/image-20230226212752937.png" alt="image-20230226212752937"></p></li><li><p>现阶段问题</p><ol><li>地图模板设计</li><li>后处理逻辑</li></ol></li></ol><h5 id="角色控制"><a href="#角色控制" class="headerlink" title="角色控制"></a>角色控制</h5><ol><li><p>基础控制（走、跑、跳（二段）、冲刺），可添加额外控制（蹲、爬、滑墙、滑铲、蹬强跳等）</p><ol><li><p>跳跃</p><ul><li>跳跃检测和跳跃实现分开判断</li><li>在地面状态时重置跳跃次数</li></ul></li><li><p>滑墙</p><ul><li>通过射线检测，判断角色前方是否存在墙体，当角色不在地面且前方存在墙体时进入滑墙状态</li><li>当x轴输入方向和墙的方向一致时才进入滑墙</li><li>在滑墙状态下重置跳跃次数</li></ul></li><li><p>蹬墙跳：</p><ul><li><p>在滑墙的基础下实现</p></li><li><p>当角色在滑墙状态时，用户可以通过直接跳跃落下墙体或者通过方向加跳跃进行蹬墙跳</p></li><li><p>两种跳跃通过预设定的方向和力实现</p><p><img src="/images/毕设记录/image-20230305121338565.png" alt="滑墙状态下的跳跃"></p></li><li><p>设置canMove和canFlip两个参数，优化蹬墙跳的手感。即当在滑墙状态下输入反方向时的一小段时间内使角色无法移动和转向</p></li></ul></li><li></li></ol></li><li><p>问题：</p><ol><li>跳跃感觉在月球<ol><li>调整重力大小</li><li>跳跃直接修改速度而非添加力</li></ol></li><li>冲刺有bug<ol><li>设置其他条件，当碰到墙壁或时间结束都结束冲刺</li><li>冲刺过程中屏蔽跳跃和移动</li></ol></li><li>攻击等需要设计</li></ol></li></ol><h5 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h5><h6 id="敌人状态控制"><a href="#敌人状态控制" class="headerlink" title="敌人状态控制"></a>敌人状态控制</h6><ul><li><p>Entity</p><p>敌人实体的基类</p></li><li><p>FiniteStateMachine</p><p>管理Entity当前状态，执行对应的逻辑</p></li><li><p>State</p><p>状态类，每个状态有对应的逻辑</p></li><li><p>状态转换图</p><ul><li><p>enemy1：近战</p><p><img src="/images/毕设记录/image-20230308202413591.png" alt="Enemy1状态"></p></li><li><p>enemy2：远程</p><p><img src="/images/毕设记录/image-20230311110302165.png" alt="enemy2状态"></p></li></ul></li></ul><h6 id="Player-状态机（分层状态机）"><a href="#Player-状态机（分层状态机）" class="headerlink" title="Player 状态机（分层状态机）"></a>Player 状态机（分层状态机）</h6><p><img src="/images/毕设记录/FSM.png" alt="FSM"></p><ul><li><p>Ledge Climb：</p><p>分为三个状态，在动画状态机中用sub-state machine完成动画状态转换</p></li><li></li></ul><h5 id="Input-System"><a href="#Input-System" class="headerlink" title="Input System"></a><a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/index.html">Input System</a></h5><ul><li>Descirption:The Input System package implements a system to use any kind of Input Device to control your Unity content. It’s intended to be a more powerful, flexible, and configurable replacement for Unity’s classic Input Manager (the <code>UnityEngine.Input</code> class).</li><li>InputSystem对大部分常用的输入设备都定义了详细的控制类，其中具体的控制项则基于InputControl基类派生出的各种处理类，包括但不仅限于AxisControl，ButtonControl，TouchControl等。可以很方便的对多个设备的输入进行处理</li></ul><h5 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h5><ul><li>子状态机（Sub-State Machine）</li></ul><h4 id="战斗系统"><a href="#战斗系统" class="headerlink" title="战斗系统"></a>战斗系统</h4><p>目标是一个框架，能够方便的装备和取消装备，且敌人也能如此</p><h6 id="武器"><a href="#武器" class="headerlink" title="武器"></a>武器</h6><p>让武器成为有限状态机的一个完全独立的实体，每个武器对应一个单一的攻击状态</p><p>每个武器类决定攻击状态如何和武器交互</p><p><img src="/images/毕设记录/image-20230329180813857.png" alt="weapon"></p><ul><li><p>武器结构如图</p><p><img src="/images/毕设记录/image-20230407140004089.png" alt="武器结构"></p><p>分为角色（base）和武器（weapon），base控制角色动画，weapon控制武器动画，并添加有碰撞器，用于攻击检测</p></li></ul><p>sprite 切换回调</p><p><code>SpriteRenderer.RegsiterSpriteChangeCallback(UnityAction&lt;SpriteRenderer&gt; callback);</code></p><h5 id="Entity重构"><a href="#Entity重构" class="headerlink" title="Entity重构"></a>Entity重构</h5><p>将所有Entity公用的方法和变量抽象成另一个类，其他Entity中增加一个对其的引用，增加代码复用性，并方便管理</p><p><img src="/images/毕设记录/image-20230405163600882.png" alt="新的Entity关系"></p><ul><li>Movement：控制移动</li><li>CollisionSenses：控制物理检测部分</li><li>Combat：控制战斗和受伤部分，继承IDamageable、IKnockbackable等接口，并有collider用于被攻击的触发检测</li><li>Stats：用于记录所有的数据状态，如health、mana等</li><li>ParticleManagert：例子效果管理</li><li>Death：死亡</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;选题描述&quot;&gt;&lt;a href=&quot;#选题描述&quot; class=&quot;headerlink&quot; title=&quot;选题描述&quot;&gt;&lt;/a&gt;选题描述&lt;/h4&gt;&lt;p&gt;主要内容：基于Unity3D引擎的一个2D平台跳跃类游戏。玩家可以在多个地图</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity功能模块整理</title>
    <link href="http://kennyyyyyy.github.io/2022/11/21/Unity%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E6%95%B4%E7%90%86/"/>
    <id>http://kennyyyyyy.github.io/2022/11/21/Unity%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E6%95%B4%E7%90%86/</id>
    <published>2022-11-21T01:20:21.000Z</published>
    <updated>2022-11-21T01:55:56.284Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><hr><h5 id="Unity中的功能模块整理"><a href="#Unity中的功能模块整理" class="headerlink" title="Unity中的功能模块整理"></a>Unity中的功能模块整理</h5><h6 id="1、UGUI"><a href="#1、UGUI" class="headerlink" title="1、UGUI"></a>1、UGUI</h6><h6 id="2、Animation-System"><a href="#2、Animation-System" class="headerlink" title="2、Animation System"></a>2、Animation System</h6><h6 id="3、Terrain-System"><a href="#3、Terrain-System" class="headerlink" title="3、Terrain System"></a>3、Terrain System</h6><h6 id="4、Humanoid-Character"><a href="#4、Humanoid-Character" class="headerlink" title="4、Humanoid Character"></a>4、Humanoid Character</h6><h6 id="5、Particle-System"><a href="#5、Particle-System" class="headerlink" title="5、Particle System"></a>5、Particle System</h6><h6 id="6、Timeline"><a href="#6、Timeline" class="headerlink" title="6、Timeline"></a>6、Timeline</h6><h6 id="7、Partical-Simulation"><a href="#7、Partical-Simulation" class="headerlink" title="7、Partical Simulation"></a>7、Partical Simulation</h6><h6 id="8、Timemap"><a href="#8、Timemap" class="headerlink" title="8、Timemap"></a>8、Timemap</h6><h6 id="9、Light-Probe"><a href="#9、Light-Probe" class="headerlink" title="9、Light Probe"></a>9、Light Probe</h6><h6 id="10、Audio-amp-Video"><a href="#10、Audio-amp-Video" class="headerlink" title="10、Audio &amp; Video"></a>10、Audio &amp; Video</h6><h6 id="11-Path-Finding"><a href="#11-Path-Finding" class="headerlink" title="11 Path Finding"></a>11 Path Finding</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;hr&gt;
&lt;h5 id=&quot;Unity中的功能模块整理&quot;&gt;&lt;a href=&quot;#Unity中的功能模块整理&quot; class=&quot;headerlink&quot; title=&quot;Unity中的功能模块整理&quot;&gt;&lt;/a&gt;Unity中的功能模块整理&lt;/h5&gt;</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关</title>
    <link href="http://kennyyyyyy.github.io/2022/11/06/Unity%E7%9B%B8%E5%85%B3/"/>
    <id>http://kennyyyyyy.github.io/2022/11/06/Unity%E7%9B%B8%E5%85%B3/</id>
    <published>2022-11-06T05:46:42.000Z</published>
    <updated>2023-04-05T09:14:26.595Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><hr><h4 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h4><h5 id="Toolkit"><a href="#Toolkit" class="headerlink" title="Toolkit"></a>Toolkit</h5><ul><li><p>可视化UI编辑器，类似于网页前端的编写</p></li><li><p>缺点（暂时，官方已在优化）</p><ol><li>不依赖于GameObject工作流，难以制作放置在3D世界中的可互动的UI；</li><li>不支持Shader，特效制作不方便；</li><li>不支持Animator，无法制作实时循环动画（自带了Transition动画系统）。</li></ol></li></ul><h5 id="Tilemap"><a href="#Tilemap" class="headerlink" title="Tilemap"></a>Tilemap</h5><ul><li><p>问题1：摄像机视角中会出现虚线</p><p>解决办法：修改Tilemap Renderer中的材质，材质属性如下</p><p><img src="../images/Unity相关/image-20230304120613934.png" alt="材质截图"></p></li></ul><h5 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h5><ol><li><p>SendMessage</p><p>调用GameObject挂载的Script里对应的函数</p><p>SendMessage (“函数名”,参数，SendMessageOptions) </p><p><strong>缺点</strong></p><ol><li>过于依赖反射机制(reflection)来查找消息对应的被调用函数</li><li>频繁使用<strong>反射会影响性能</strong></li><li>更会大大<strong>增加代码的维护成本 — 字符串标识</strong>对应方法</li><li><strong>无视访问权限, 能够调用private的方法</strong> — 若有一个是有方法在声明的类中没有被使用，那正常情况下都会把它认为是废代码从而删除，这时<strong>隐患</strong>就出现了</li></ol></li><li><p>AddTorque</p><p><code>public void AddTorque(Vector3 torque, ForceMode mode = ForceMode.Force);</code></p><p><strong>功能</strong>：对刚体施加一个旋转力。</p><p><strong>参数介绍</strong>：</p><p>torque 决定旋转力的大小和旋转轴的方向，旋转方向参照左手定则</p><p>mode 决定作用力的模式，缺省方式为ForceMode.Force</p></li><li><p>Transform</p><ul><li>transform.parent.GetComponent 只找直属父级</li><li>transform.GetComponentInParrent 一直往上查找所有父级，直到找到</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;hr&gt;
&lt;h4 id=&quot;UI&quot;&gt;&lt;a href=&quot;#UI&quot; class=&quot;headerlink&quot; title=&quot;UI&quot;&gt;&lt;/a&gt;UI&lt;/h4&gt;&lt;h5 id=&quot;Toolkit&quot;&gt;&lt;a href=&quot;#Toolkit&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>3D数学基础：图形与游戏开发</title>
    <link href="http://kennyyyyyy.github.io/2022/10/07/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    <id>http://kennyyyyyy.github.io/2022/10/07/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</id>
    <published>2022-10-07T11:38:59.000Z</published>
    <updated>2022-11-05T06:58:49.566Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="2、笛卡尔坐标系"><a href="#2、笛卡尔坐标系" class="headerlink" title="2、笛卡尔坐标系"></a>2、笛卡尔坐标系</h4><h4 id="3、多坐标系"><a href="#3、多坐标系" class="headerlink" title="3、多坐标系"></a>3、多坐标系</h4><h5 id="3-2-一些有用的坐标系"><a href="#3-2-一些有用的坐标系" class="headerlink" title="3.2 一些有用的坐标系"></a>3.2 一些有用的坐标系</h5><h6 id="3-2-1-世界坐标系"><a href="#3-2-1-世界坐标系" class="headerlink" title="3.2.1 世界坐标系"></a>3.2.1 世界坐标系</h6><p>​    世界坐标系建立了描述其他坐标系所需要的参考框架，能够用世界坐标系描述其他坐标系的位置，而不能用更大的、外部的坐标系来描述世界坐标系。</p><p>​    世界坐标系的典型问题都是关于<strong>初始位置和环境</strong>的，如：</p><ul><li>每个物体的位置和方向；</li><li>摄像机的位置和方向；</li><li>世界中没一点的地形是什么（如山丘、湖泊等）；</li><li>个物体从哪里来，到哪里去（NPC的运动策略）。</li></ul><h6 id="3-2-2-物体坐标系"><a href="#3-2-2-物体坐标系" class="headerlink" title="3.2.2 物体坐标系"></a>3.2.2 物体坐标系</h6><p>​    物体坐标系是特定物体相关联的坐标系，每个物体都有独立的坐标系，当物体移动或改变方向时，该物体相关联的坐标系也会移动或改变方向。</p><p>​    世界坐标系也叫模型坐标系。</p><ul><li>周围有需要相互作用的物体吗？（我要攻击他吗？）</li><li>哪个方向？前面？左边？</li></ul><h6 id="3-2-3-摄像机坐标系"><a href="#3-2-3-摄像机坐标系" class="headerlink" title="3.2.3 摄像机坐标系"></a>3.2.3 摄像机坐标系</h6><p>​    摄像机坐标系是和观察者密切相关的坐标系。可以被看做是一种特殊的“物体“坐标系，该”物体“坐标系定义在摄像机的屏幕可视区域。</p><ul><li>3D空间中的给定点在摄像机前方吗？</li><li>某个物体是否在屏幕上？</li><li>两个物体，谁在前？</li></ul><h6 id="3-2-4-惯性坐标系"><a href="#3-2-4-惯性坐标系" class="headerlink" title="3.2.4 惯性坐标系"></a>3.2.4 惯性坐标系</h6><p>​    为了简化世界坐标系到物体坐标系的转换，引入的新的坐标系。惯性坐标系的原点和物体坐标系的原点重合，轴和世界坐标系的轴平行。</p><p>​    从世界坐标系到惯性坐标系只需要平移，从惯性坐标系到物体坐标系只需要旋转。</p><h4 id="4、向量与标量"><a href="#4、向量与标量" class="headerlink" title="4、向量与标量"></a>4、向量与标量</h4><h4 id="5、向量运算"><a href="#5、向量运算" class="headerlink" title="5、向量运算"></a>5、向量运算</h4><h5 id="5-2-符号约定"><a href="#5-2-符号约定" class="headerlink" title="5.2 符号约定"></a>5.2 符号约定</h5><ul><li>标量：斜体小写字母 <em>a, b, c, d, e</em></li><li>向量：粗体小写 <strong>a, b, c, d, e</strong></li><li>矩阵：粗体大写 <strong>A, B, C, D</strong></li></ul><h5 id="5-10-向量点乘"><a href="#5-10-向量点乘" class="headerlink" title="5.10 向量点乘"></a>5.10 向量点乘</h5><h6 id="5-10-1-运算法则"><a href="#5-10-1-运算法则" class="headerlink" title="5.10.1 运算法则"></a>5.10.1 运算法则</h6><p>​    向量点乘记为 <strong>a</strong>·<strong>b</strong>，为对应分量乘积的和，结果为标量。</p><p>​    [a1,a2…an-1,an]·[b1,b2…bn-1,bn] = a1b1 + a2b2 + … + an bn</p><h6 id="5-10-2-几何解释"><a href="#5-10-2-几何解释" class="headerlink" title="5.10.2 几何解释"></a>5.10.2 几何解释</h6><p>​    <strong>a</strong>·<strong>b</strong> = |<strong>a</strong>| |<strong>b</strong>|cosθ</p><p>​    θ = arccos((<strong>a</strong>·<strong>b</strong>)/(|<strong>a</strong>||<strong>b</strong>|))</p><p>​    根据θ的大小，可以判断两向量的方向。可用于判断怪物与人物的位置关系。</p><h6 id="5-10-3-向量投影"><a href="#5-10-3-向量投影" class="headerlink" title="5.10.3 向量投影"></a>5.10.3 向量投影</h6><p>​    给定两个向量 <strong>v</strong> 和 <strong>n</strong> ，基于向量 <strong>n</strong>, 可以将<strong>v</strong>分解为平行和垂直<strong>n</strong>的两个向量 <strong>v1</strong>和 <strong>v2</strong></p><p>​    <strong>v1</strong> = <strong>n</strong>|<strong>v1</strong>|/|<strong>n</strong>|</p><p>​    <img src="/images/3D数学基础：图形与游戏开发/image-20221012141458886.png" style="zoom:50%;"></p><p>​    <img src="/images/3D数学基础：图形与游戏开发/image-20221012141522918.png" alt="image-20221012141522918" style="zoom:50%;"></p><h5 id="5-11-向量叉乘"><a href="#5-11-向量叉乘" class="headerlink" title="5.11 向量叉乘"></a>5.11 向量叉乘</h5><h6 id="5-10-1-运算法则-1"><a href="#5-10-1-运算法则-1" class="headerlink" title="5.10.1 运算法则"></a>5.10.1 运算法则</h6><p>​    [<em>x1, y1, z1</em>]x[<em>x- y2, z2</em>] = [<em>y1z2 - z1y2</em>, <em>z1x2 - x1z2</em>, <em>x1y2 - y1x2</em>]</p><p>​    叉乘的运算优先级和点乘一样，叉乘优先计算。</p><h6 id="5-10-2-几何解释-1"><a href="#5-10-2-几何解释-1" class="headerlink" title="5.10.2 几何解释"></a>5.10.2 几何解释</h6><p>​    叉乘得到的向量垂直于原来的两个向量平面</p><p>​    |<strong>a</strong> x <strong>b</strong>| = |<strong>a</strong>| |<strong>b</strong>| sinθ</p><p>​    叉乘的结果的模值等于以<strong>ab</strong>为边的平行四边形的面积</p><h5 id="5-12-线性代数公式"><a href="#5-12-线性代数公式" class="headerlink" title="5.12 线性代数公式"></a>5.12 线性代数公式</h5><p>​    <img src="/images/3D数学基础：图形与游戏开发/image-20221012143830523.png" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;2、笛卡尔坐标系&quot;&gt;&lt;a href=&quot;#2、笛卡尔坐标系&quot; class=&quot;headerlink&quot; title=&quot;2、笛卡尔坐标系&quot;&gt;&lt;/a&gt;2、笛卡尔坐标系&lt;/h4&gt;&lt;h4 id=&quot;3、多坐标系&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="图形学" scheme="http://kennyyyyyy.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="http://kennyyyyyy.github.io/2022/10/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://kennyyyyyy.github.io/2022/10/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2022-10-01T17:01:40.000Z</published>
    <updated>2022-12-07T06:45:36.231Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h5 id="Socket编程GitHub"><a href="#Socket编程GitHub" class="headerlink" title="Socket编程GitHub"></a>Socket编程<a href="https://github.com/kennyyyyyy/Linux-Network-Programming">GitHub</a></h5><h6 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h6><ul><li><p>Socket地址结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> sin_len;<span class="comment">//结构体长度</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">//指定该地址家族，设为AF——INET，表示使用的是IPv4协议</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;<span class="comment">//端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//IPv4 地址</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">//一般设为0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/Linux网络编程/image-20221202011444543.png" alt="man 7 ip"></p></li><li><p>字节序（大端/小端）</p><p><img src="/images/Linux网络编程/image-20221202011643976.png" alt="字节序"></p><ul><li><p>字节序转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//h代表host；n代表network；s代表short；l代表long</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>地址转换函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;<span class="comment">//将点分十进制转换为地址结构</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;<span class="comment">//点分十进制-&gt;32位整数</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_network</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;<span class="comment">//地址结构转换成点分十进制IP</span></span><br><span class="line"><span class="function">struct in_addr <span class="title">inet_makeaddr</span><span class="params">(<span class="keyword">in_addr_t</span> net, <span class="keyword">in_addr_t</span> host)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_lnaof</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_netof</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>套接字类型</p><ul><li>流式套接字：TCP</li><li>数据包套接字：UDP</li><li>原始套接字</li></ul></li><li><p>测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="number">0x12345678</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)&amp;val;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%0x %0x %0x %0x\n&quot;</span>, p[<span class="number">0</span>], p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> val2 = htonl(val);</span><br><span class="line">        p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)&amp;val2;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%0x %0x %0x %0x\n&quot;</span>, p[<span class="number">0</span>], p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cp = <span class="string">&quot;192.168.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> num = inet_addr(cp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, ntohl(num));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Makefile 多文件编译</span><br><span class="line">CXX = gcc</span><br><span class="line">CXX_FLAGS = -Wall -g</span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">NOTDIR_SRC  = <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(SRC)</span>)</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, ./bin/%.o, <span class="variable">$(NOTDIR_SRC)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="comment"># 多目标</span></span><br><span class="line">TARGET_LIST = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %, <span class="variable">$(NOTDIR_SRC)</span>)</span></span><br><span class="line"><span class="section">all:<span class="variable">$(TARGET_LIST)</span></span></span><br><span class="line"><span class="variable">$(TARGET_LIST)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">        @echo <span class="variable">$@</span></span><br><span class="line">        <span class="variable">$(CXX)</span> -o ./bin/<span class="variable">$@</span> ./bin/<span class="variable">$@</span>.o</span><br><span class="line">        @echo <span class="variable">$(TARGET_LIST)</span></span><br><span class="line"><span class="section">./bin/%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CXX)</span> -c  <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span>  </span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">        -rm -f ./bin/*</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="/images/Linux网络编程/image-20221202144939842.png" alt="测试结果"></p></li></ul></li></ul><h6 id="TCP-cs模型"><a href="#TCP-cs模型" class="headerlink" title="TCP cs模型"></a>TCP cs模型</h6><p><img src="/images/Linux网络编程/image-20221202145048263.png" alt="cs模型结构"></p><h6 id="简单的客户端和服务端"><a href="#简单的客户端和服务端" class="headerlink" title="简单的客户端和服务端"></a>简单的客户端和服务端</h6><ul><li><p>服务端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line">        <span class="keyword">do</span>  \</span><br><span class="line">        &#123;   \</span><br><span class="line">            perror(m);  \</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE); \</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"><span class="keyword">if</span>((listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">ERR_EXIT(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建套接字地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">//servaddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); </span></span><br><span class="line"><span class="comment">//inet_aton()&quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定地址</span></span><br><span class="line"><span class="keyword">if</span>(bind(listenfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">ERR_EXIT(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//监听，等待连接请求</span></span><br><span class="line"><span class="keyword">if</span>(listen(listenfd, SOMAXCONN) &lt; <span class="number">0</span>)</span><br><span class="line">ERR_EXIT(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peeraddr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> peerlen = <span class="keyword">sizeof</span>(peeraddr);</span><br><span class="line"><span class="keyword">int</span> conn;</span><br><span class="line">    <span class="comment">//从已完成连接中会的第一个连接，若无连接，则阻塞（被动套接字）</span></span><br><span class="line"><span class="keyword">if</span>((conn = accept(listenfd, (struct sockaddr*)&amp;peeraddr, &amp;peerlen)) &lt; <span class="number">0</span>)</span><br><span class="line">ERR_EXIT(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> recvbud[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据交换</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(recvbud, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbud));</span><br><span class="line"><span class="keyword">int</span> ret = read(conn, recvbud, <span class="keyword">sizeof</span>(recvbud));</span><br><span class="line"><span class="built_in">fputs</span>(recvbud, <span class="built_in">stdout</span>);</span><br><span class="line">write(conn, recvbud, ret);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//断开连接</span></span><br><span class="line">close(conn);</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line">        <span class="keyword">do</span>  \</span><br><span class="line">        &#123;   \</span><br><span class="line">            perror(m);  \</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE); \</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sock;</span><br><span class="line"><span class="keyword">if</span>((sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>) )&lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">ERR_EXIT(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">servaddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务端发起连接（主动套接字）</span></span><br><span class="line"><span class="keyword">if</span>(connect(sock, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr) )&lt; <span class="number">0</span>)</span><br><span class="line">ERR_EXIT(<span class="string">&quot;Connect&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> sendbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> recvbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(fgets(sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">write(sock, sendbuf, <span class="built_in">strlen</span>(sendbuf));</span><br><span class="line">read(sock, recvbuf, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line"><span class="built_in">fputs</span>(recvbuf, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line"><span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="/images/Linux网络编程/image-20221202160710011.png" alt="服务端"></p><p><img src="/images/Linux网络编程/image-20221202160726885.png" alt="客户端"></p></li><li><p>REUSEADDR</p><p>服务端断开连接的一段时间内会处于TIME_WAIT状态，再此状态下无法进行绑定连接。</p><ul><li><p>服务端尽可能使用REUSERADDR</p></li><li><p>绑定前尽可能调用setsockopt来设置REUSERADDR套接字选项</p></li><li><p>使用REUSERADDR选项可以使得不必等待TIME_WAIT状态结束就可以重启服务器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set REUSEADDR opt</span></span><br><span class="line"><span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>)</span><br><span class="line">    ERR_EXIT(<span class="string">&quot;setsocektopt&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>处理多个客户端的连接：通过一个连接一个进程来处理并发</p><p>服务端在获得连接时创建子进程进行消息处理</p><p>客户端关闭后退出循环，并关闭进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_service</span><span class="params">(<span class="keyword">int</span> conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> recvbud[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//数据交换</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(recvbud, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbud));</span><br><span class="line">        <span class="keyword">int</span> ret = read(conn, recvbud, <span class="keyword">sizeof</span>(recvbud));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client closed.&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fputs</span>(recvbud, <span class="built_in">stdout</span>);</span><br><span class="line">        write(conn, recvbud, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> conn;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从已完成连接中会的第一个连接，若无连接，则阻塞（被动套接字）</span></span><br><span class="line">    <span class="keyword">if</span> ((conn = accept(listenfd, (struct sockaddr *)&amp;peeraddr, &amp;peerlen)) &lt; <span class="number">0</span>)</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip = %s port = %d\n&quot;</span>, inet_ntoa(peeraddr.sin_addr), ntohs(peeraddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="comment">//子进程不需要关注listenfd，父进程不需要关注conn</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        do_service(conn);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端发送消息（一对一）</p><p>使用多进程向处理消息发送和接收</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要逻辑</span></span><br><span class="line"><span class="comment">//子进程处理消息接收，父进程处理消息发送</span></span><br><span class="line"><span class="comment">//服务端和客户端父子进程逻辑对调</span></span><br><span class="line"><span class="comment">//若接收进程为子进程时，则接收到断开连接消息时，只会结束子进程，因此采用信号，来发送消息，结束父进程</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    ERR_EXIT(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> recvbud[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(recvbud, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbud));</span><br><span class="line">        <span class="keyword">int</span> ret = read(sock, recvbud, <span class="keyword">sizeof</span>(recvbud));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;peer closed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fputs</span>(recvbud, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    kill(pid, SIGUSR1);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGUSR1, handler);</span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(sock, sendbuf, <span class="built_in">strlen</span>(sendbuf));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收信号后的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;received a sign = %d\n&quot;</span>, sign);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="流协议与粘包"><a href="#流协议与粘包" class="headerlink" title="流协议与粘包"></a>流协议与粘包</h6><ul><li><p>流式协议：基于字节流，无边界</p></li><li><p>粘包问题</p><p><img src="/images/Linux网络编程/image-20221202222355082.png" alt="粘包"></p></li><li><p>粘包解决办法</p><ul><li>本质是在应用层维护消息与消息的边界<ul><li>固定包的长度</li><li>包结尾加上分隔符 \r\n (ftp)</li><li>包头加上包的长度</li><li>其他复杂应用层协议</li></ul></li></ul></li><li><p>readn &amp; writen</p><p>对 read 和 wirte 函数进行封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取消息，只有读取了count大小的数据或无数据可读时才会退出循环</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft = count;</span><br><span class="line"><span class="keyword">ssize_t</span> nread;</span><br><span class="line"><span class="keyword">char</span> *bufp = (<span class="keyword">char</span>*) buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">nread = read(fd, bufp, nleft);</span><br><span class="line"><span class="keyword">if</span>(nread &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> count - nleft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bufp += nread;</span><br><span class="line">nleft -= nread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据，只有在发送了count大小的数据才退出</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">written</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft = count;</span><br><span class="line"><span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"><span class="keyword">char</span> *bufp = (<span class="keyword">char</span>*) buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">nwritten = write(fd, bufp, nleft);</span><br><span class="line"><span class="keyword">if</span>(nwritten &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nwritten == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bufp += nwritten;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包头添加长度解决粘包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据包结构，包含数据长度和数据体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_service</span><span class="params">(<span class="keyword">int</span> conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">packet</span> <span class="title">recvbuf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">        <span class="comment">//读取包头的长度消息</span></span><br><span class="line">        <span class="keyword">int</span> ret = readn(conn, &amp;recvbuf.len, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client closed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len = ntohl(recvbuf.len);</span><br><span class="line">        <span class="comment">//读取包体内容</span></span><br><span class="line">        ret = readn(conn, recvbuf.buf, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client closed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fputs</span>(recvbuf.buf, <span class="built_in">stdout</span>);</span><br><span class="line">        written(conn, &amp;recvbuf, <span class="number">4</span> + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>read、write与recv、send</p><p><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</code></p><p><code>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</code> </p><p><code>ssize_t read(int fd, void *buf, size_t count);</code> </p><p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p><ul><li><p>recv与read一样，都能从套接口缓冲区中获得数据</p></li><li><p>recv只能用于套接口IO，read能用于所有的IO</p></li><li><p>recv可以通过选项指定接收数据的行为</p><ul><li><strong>MSG_OOB</strong>：接收紧急指针发送的数据（out-of-band）</li><li><strong>MSG_PEEK</strong>：接收缓冲区的数据，但不清除缓冲区的数据</li></ul></li><li><p>封装recv_peek函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取到数据就返回</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv_peek</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = recv(sockfd, buf, len, MSG_PEEK);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp; errno == EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过包尾添加对应字符解决粘包问题（\n）</p><p>使用recv_peek实现readline</p><p>使用recv_peek读取缓存区中的内容，直到读取到 <code>\n</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> maxline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *bufp = buf;</span><br><span class="line">    <span class="keyword">int</span> nleft = maxline;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//读取一行数据</span></span><br><span class="line">        ret = recv_peek(sockfd, bufp, nleft);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nread = ret;</span><br><span class="line">        <span class="comment">//判断读取的数据中是否存在\n</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nread; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存在结尾标志，清空缓存区，返回</span></span><br><span class="line">            <span class="keyword">if</span>(bufp[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = readn(sockfd, bufp, i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(ret != i + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nread &gt; nleft)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不存在结尾标志，继续往后读取</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        ret = readn(sockfd, bufp, nread);</span><br><span class="line">        <span class="keyword">if</span>(ret != nread)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;    </span><br><span class="line">        bufp += nread;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="Socket相关函数"><a href="#Socket相关函数" class="headerlink" title="Socket相关函数"></a>Socket相关函数</h6><ul><li><p><strong>getsockname</strong> ：获得连接套接字本地的sockaddr</p><p><code>int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">loacladdr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(loacladdr);</span><br><span class="line"><span class="keyword">if</span>(getsockname(sock, (struct sockaddr*)&amp;loacladdr, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    ERR_EXIT(<span class="string">&quot;getsockname&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ip = %s port = %d\n&quot;</span>, inet_ntoa(loacladdr.sin_addr), ntohs(loacladdr.sin_port));</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>getpeername</strong>：获得连接套接字对方的sockaddr</p><p><code>int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></p></li><li><p><strong>gethostname</strong></p><p><code>int gethostname(char *name, size_t len);</code></p><p>0 for success</p><p>-1 for failure</p></li><li><p><strong>gethostbyname</strong></p><p><code>struct hostent *gethostbyname(const char *name);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>  *h_name;            <span class="comment">/* official name of host */</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;         <span class="comment">/* alias list */</span></span><br><span class="line">    <span class="keyword">int</span>    h_addrtype;        <span class="comment">/* host address type */</span></span><br><span class="line">    <span class="keyword">int</span>    h_length;          <span class="comment">/* length of address */</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list;       <span class="comment">/* list of addresses */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>h_addr</strong>  equals  <strong>h_addr_list[0]</strong></p></li><li><p><strong>gethostbyaddr</strong></p><p><code>struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);</code></p></li><li><p><strong>close和shutdown</strong></p><ul><li>close：close终止了数据传送的两个方向。</li><li>shutdown：可以有选择的终止某个方向的数据传送或终止数据传送的两个方向。</li><li>shutdown how = 1 可以保证对等方接收到一个EOF字符，而不管其他进程是否已经打开了套接字，而close不能保证。close只有等套接字的引用计数变为零，即所有的进程都关闭了才发送。 </li><li>使用<code>shutdown(sock, SHUT_WR);</code>代替 <code>close(sock);</code> 可以保证接受完缓冲区中的数据</li></ul></li><li><p><strong>getsockopt</strong></p><p><code>int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);</code></p><p><code>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</code></p><ul><li>功能：获取/设置一个套接字的选项</li><li><p>参数：</p><ul><li>socket：文件描述符</li><li>level：协议层次<ul><li>SOL_SOCKET 套接字层次</li><li>IPPROTO_IP ip层次</li><li>IPPROTO_TCP TCP层次</li></ul></li><li>option_name：选项的名称（套接字层次）<ul><li>SO_BROADCAST 是否允许发送广播信息</li><li>SO_REUSEADDR 是否允许重复使用本地地址</li><li>SO_SNDBUF 获取发送缓冲区长度</li><li>SO_RCVBUF 获取接收缓冲区长度   </li><li>SO_RCVTIMEO 获取接收超时时间</li><li>SO_SNDTIMEO 获取发送超时时间</li></ul></li><li>option_value：获取到的选项的值</li><li>option_len：value的长度   </li></ul></li><li><p>返回值：</p><ul><li>成功：0</li><li>失败：-1</li></ul></li></ul></li><li><p>recv和recvfrom</p><ul><li>两者可以相互替换，知识recvfrom可以接收对端的地址信息，在udp中可以很方便的进行回复操作</li></ul></li></ul><h6 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h6><ul><li><p>进程中的指令已经执行完成，但是进程PCB结构还没有回收。<br>即子进程先于父进程退出后，子进程的PCB需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程。</p></li><li><p>父进程未结束，子进程结束，但父进程没有处理子进程的退出状态（当子进程先于父进程结束，父进程没有获取子进程的退出码，子进程的PCB会保留一段时间等待父进程在PCB中获取退出码，，且该进程不可执行，此时子进程变成僵尸进程）。<br>直到父进程获取到子进程的退出状态，子进程的PCB才会被移除。</p></li><li><p>采用信号的方式对僵尸进程进行忽略</p><p><code>signal(SIGCHLD, SIG_IGN)</code></p></li><li><p>捕捉SIGCHLD信号来避免僵尸进程</p><p><code>signal(SIGCHLD, handle_sigchld)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_sigchld</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//捕捉到SIGCHLD状态后调用wait等待子进程状态</span></span><br><span class="line">    <span class="comment">//wait(NULL);//只等待一个信号就会返回</span></span><br><span class="line">    <span class="keyword">while</span>(waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>); <span class="comment">//接收到信号后，循环等待子进程，直到没有子进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6><ul><li><p>TCP的十一种状态</p><p>还有一种状态为 CLOSING，其产生原因是双方同时关闭</p><p><img src="/images/Linux网络编程/image-20221203191932559.png" alt="TCP的十一种状态" style="zoom: 67%;"></p></li><li><p>SIGPIPE信号</p><ul><li><p>收到FIN信号的套接字还可以接收数据，接收到FIN只代表对方不在发送数据</p></li><li><p>在收到RST段之后，即在接收到FIN之后，再调用wirte就会产生SIGPIPE信号，对于这个信号，一般忽略处理</p><p><code>signal(SIGPIPE, GIS_IGN)</code></p></li></ul></li></ul><h6 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h6><ul><li><p>阻塞IO</p><p><img src="/images/Linux网络编程/image-20221203211022074.png" alt="阻塞IO"></p></li><li><p>非阻塞IO</p><p>将套接口设置为非阻塞模式</p><p><code>fcntl(fd, F_SETFL, flag|0_NCNBLOCK)</code></p><p><img src="/images/Linux网络编程/image-20221203211604927.png" alt="非阻塞IO"></p></li><li><p>I/O复用（select和poll）</p><ul><li><p>select</p><p><img src="/images/Linux网络编程/image-20221203212032485.png" alt="select"></p></li></ul></li><li><p>信号驱动I/O</p><p><img src="/images/Linux网络编程/image-20221203213430216.png" alt="信号驱动I/O"></p></li><li><p>异步I/O：效率最高</p><p><img src="/images/Linux网络编程/image-20221203213740909.png" alt="image-20221203213740909"></p></li><li><p>I/O超时设置方法</p><ul><li><p>alarm</p><ul><li>使用alarm函数，超时之后会发送一个SIGALRM信号，捕捉信号就可以将阻塞函数打断，进行后续处理</li></ul></li><li><p>套接字选项</p><ul><li><p>SO_SNDTIMEO</p></li><li><p>SO_RCVTIMEO</p></li><li><p><code>setsockopt(sock, SOL_SOCKET, SO_RECVTIMEO, 5)</code></p><p>设置接收时间为5，超时后会产生错误代码 errno = EWOULDBLOCK</p></li></ul></li></ul></li></ul><h6 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h6><ul><li><p>select模型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//将fd从set中一处</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//判断fd是否再set中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//将fd放入set中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//将集合清空</span></span><br></pre></td></tr></table></figure><ul><li><p>用select来管理多个I/O，一旦其中一个或多个I/O检测到感兴趣时间，select返回，返回值为事件个数和哪些事件，然后遍历并处理这些事件。</p></li><li><p>nfds：读、写、异常集合中的文件描述符的最大值+1（select为遍历所有事件来检测）</p></li><li><p>readfds：可读fd集合</p></li><li><p>writefds：可写fd集合</p></li><li><p>exceptfds：异常fd集合</p></li><li><p>timeout：超时时间结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>select模型处理标准输入和sock I/O</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cli</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化ready集合</span></span><br><span class="line">fd_set rset;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nready;</span><br><span class="line"><span class="keyword">int</span> maxfd;</span><br><span class="line"><span class="keyword">int</span> fd_stdin = fileno(<span class="built_in">stdin</span>);</span><br><span class="line">maxfd = fd_stdin &gt; sock ? fd_stdin : sock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> sendbuf[<span class="number">1204</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> recvbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//将标准输入I/O和sock加入集合</span></span><br><span class="line">FD_SET(fd_stdin, &amp;rset);</span><br><span class="line">FD_SET(sock, &amp;rset);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用select，获得ready集合</span></span><br><span class="line">nready = select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//错误和未有ready可以处理</span></span><br><span class="line"><span class="keyword">if</span>(nready == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ERR_EXIT(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nready == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//sock I/O 有数据处理</span></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(sock, &amp;rset))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret = readline(sock, recvbuf, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ERR_EXIT(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server closed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fputs</span>(recvbuf, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标准输入有数据处理</span></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(fd_stdin, &amp;rset))</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(fgets(sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">written(sock, sendbuf, <span class="built_in">strlen</span>(sendbuf));</span><br><span class="line"><span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>select模型 读、写、异常事件发生的条件</p><ul><li>可读<ul><li>套接口缓冲区有数据可读</li><li>连接的读一半关闭，即接收到FIN，读操作返回0</li><li>监听套接口，已完成链接队列不为空</li><li>套接口上发生了一个错误待处理，错误可以通过getsockopt指定SO_ERROR选项来处理</li></ul></li><li>可写<ul><li>套接口发送缓冲区有数据</li><li>连接的写一半关闭，即接收到RST，再次调用write</li><li>套接口上发生了一个错误待处理，错误可以通过getsockopt指定SO_ERROR选项来处理</li></ul></li><li>异常<ul><li>套接口存在带外数据（out-of-band）</li></ul></li></ul></li><li><p>使用select实现单进程处理服务器并发。</p><p>即使用select来监听所有套接口是否有事件待处理，当套接口存在事件待处理才调用相关函数（accept、read等），这样就不会产生阻塞。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr_in peeraddr;</span><br><span class="line">socklen_t peerlen;</span><br><span class="line"><span class="built_in">int</span> conn;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="built_in">int</span> maxidx = <span class="number">0</span>;<span class="comment">//当前client的最大下标</span></span><br><span class="line"><span class="built_in">int</span> client[FD_SETSIZE];<span class="comment">//保存所有的已连接套接口，即客户端</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)<span class="comment">//初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    client[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> nready;<span class="comment">//检测到的需要处理的个数</span></span><br><span class="line"><span class="built_in">int</span> maxfd = listenfd;<span class="comment">//最大描述值</span></span><br><span class="line">fd_set rset;<span class="comment">//接收返回事件集合</span></span><br><span class="line">fd_set allset;<span class="comment">//总事件集合</span></span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_ZERO(&amp;allset);</span><br><span class="line">FD_SET(listenfd, &amp;allset);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//因为selcet会改变rset的值，所以使用allset记录所有的需要监听的事件</span></span><br><span class="line">    rset = allset;</span><br><span class="line">    nready = <span class="keyword">select</span>(maxfd + <span class="number">1</span>, &amp;rset, NULL, NULL, NULL);</span><br><span class="line">    <span class="keyword">if</span>(nready == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未检测到ready事件（即select超时）</span></span><br><span class="line">    <span class="keyword">if</span>(nready == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//若监听套接口存在事件处理，即有客户端发起连接</span></span><br><span class="line">    <span class="keyword">if</span>(FD_ISSET(listenfd, &amp;rset))</span><br><span class="line">    &#123;</span><br><span class="line">        peerlen = <span class="keyword">sizeof</span>(peeraddr);</span><br><span class="line">        <span class="comment">//获得连接套接口</span></span><br><span class="line">        <span class="keyword">if</span> ((conn = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;peeraddr, &amp;peerlen)) &lt; <span class="number">0</span>)</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历客户端数组，保存至空位，并更新最大下标</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(client[i] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                client[i] = conn;</span><br><span class="line">                maxidx = i &gt; maxidx ? i : maxidx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端数组满了，输出错误信息</span></span><br><span class="line">        <span class="keyword">if</span>(i == FD_SETSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">&quot;too many clients\n&quot;</span>);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将套接口加入待处理集合中</span></span><br><span class="line">        FD_SET(conn, &amp;allset);</span><br><span class="line">        <span class="comment">//更新最大描述符</span></span><br><span class="line">        maxfd = conn &gt; maxfd ? conn : maxfd;</span><br><span class="line">        printf(<span class="string">&quot;ip = %s port = %d\n&quot;</span>, inet_ntoa(peeraddr.sin_addr), ntohs(peeraddr.sin_port));</span><br><span class="line"><span class="comment">//更新待处理事件数</span></span><br><span class="line">        <span class="keyword">if</span>(--nready &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历客户端数组，处理所有接收数据</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= maxidx; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        conn = client[i];</span><br><span class="line">        <span class="keyword">if</span>(conn == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(conn, &amp;rset))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> recvbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">int</span> ret = readline(conn, recvbuf, <span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ERR_EXIT(<span class="string">&quot;client readline&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(<span class="string">&quot;client %d close\n&quot;</span>, conn);</span><br><span class="line">                FD_CLR(conn, &amp;allset);</span><br><span class="line">                client[i] = <span class="number">-1</span>;</span><br><span class="line">                close(conn);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fputs(recvbuf, stdout);</span><br><span class="line">            written(conn, recvbuf, strlen(recvbuf));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>select 实现超时</p><ul><li><p>read_timeout </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测超时，不含读操作</span></span><br><span class="line"><span class="comment">//未超时返回0， 失败返回-1，超时返回-1 &amp;&amp; errno = ETIMEDOUT</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_timeout</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> wait_seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        fd_set read_fdset;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">        </span><br><span class="line">        FD_ZERO(&amp;read_fdset);</span><br><span class="line">        FD_SET(fd, &amp;read_fdset);</span><br><span class="line"></span><br><span class="line">        timeout.tv_sec = wait_seconds;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检测读集合中是否有事件</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = select(fd + <span class="number">1</span>, read_fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//超时</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            errno = ETIMEDOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fd产生可读事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- write_timeout  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_timeout</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> wait_seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set write_fdset;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">        </span><br><span class="line">        FD_ZERO(&amp;write_fdset);</span><br><span class="line">        FD_SET(fd, &amp;write_fdset);</span><br><span class="line"></span><br><span class="line">        timeout.tv_sec = wait_seconds;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = select(fd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;write_fdset, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            errno = ETIMEDOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- accept_timeout  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存在超时检测的连接功能</span></span><br><span class="line"><span class="comment">//wait_seconds 为0时，为正常的阻塞accpet</span></span><br><span class="line"><span class="comment">//成功返回连接套接字， 超时返回-1 &amp;&amp; errno == ETIMEOUT， 否则连接失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept_timeout</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr_in *addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> wait_seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set accept_fdset;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">        FD_ZERO(&amp;accept_fdset);</span><br><span class="line">        FD_SET(fd, &amp;accept_fdset);</span><br><span class="line"></span><br><span class="line">        timeout.tv_sec = wait_seconds;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = select(fd + <span class="number">1</span>, &amp;accept_fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errno = ETIMEDOUT;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(addr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = accept(fd, (struct sockaddr*)addr, &amp;addrlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- connect_timeout  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将fd设置为非阻塞模式</span></span><br><span class="line"><span class="comment">//1 for active</span></span><br><span class="line"><span class="comment">//0 for enable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_nonblock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> <span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//获取之前的标记</span></span><br><span class="line">    <span class="keyword">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flags == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据参数设置更改标记</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>)</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        flags &amp;= ~O_NONBLOCK;</span><br><span class="line">    <span class="comment">//设置</span></span><br><span class="line">    ret = fcntl(fd, F_SETFL, flags);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接超时</span></span><br><span class="line"><span class="comment">//成功返回0， 超时返回-1 &amp;&amp; errno == ETIMEOUT， 否则连接失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect_timeout</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr_in *addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> wait_seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存在超时事件，将fd设置为非阻塞模式</span></span><br><span class="line">    <span class="keyword">if</span>(wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        set_nonblock(fd, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = connect(fd, (struct  sockaddr*) addr, addrlen);</span><br><span class="line">    <span class="comment">//连接正在处理中</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span> &amp;&amp; errno == EINPROGRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set connect_fdset;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">        FD_ZERO(&amp;connect_fdset);</span><br><span class="line">        FD_SET(fd, &amp;connect_fdset);</span><br><span class="line"></span><br><span class="line">        timeout.tv_sec = wait_seconds;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接，套接字即为可写</span></span><br><span class="line">            ret = select(fd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;connect_fdset, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            errno = ETIMEDOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ret等于0有两种情况</span></span><br><span class="line">            <span class="comment">//一种是简历连接成功，一种是套接字产生错误</span></span><br><span class="line">            <span class="comment">//所以需要调用getsockopt来获取</span></span><br><span class="line">            <span class="keyword">int</span> err;</span><br><span class="line">            <span class="keyword">socklen_t</span> socklen = <span class="keyword">sizeof</span>(err);</span><br><span class="line">            <span class="keyword">int</span> sockoptret = getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen);</span><br><span class="line">            <span class="keyword">if</span>(sockoptret == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(err == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                errno = err;</span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改回阻塞模式</span></span><br><span class="line">    <span class="keyword">if</span>(wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        set_nonblock(fd, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><ul><li><p>select限制</p><p>用select实现并发服务器，最大并发数受以下限制</p><ul><li><p>一个进程能打开的最大文件描述符限制，可以通过调整内核参数更改。最大值和内存大小有关</p><p><code>int getrlimit(int resource, struct rlimit *rlim);int setrlimit(int resource, const struct rlimit *rlim);</code></p><p>指令更改<code>ulimit -n number</code></p></li><li><p>select中的fd_set集合容量的限制（FD_SIZE），需要重新编译内核才能修改</p></li></ul></li></ul><h6 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h6><ul><li><p>poll函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>参数列表<ul><li>fds ：pollfd数组</li><li>nfds：数组中数据的个数</li><li>timeout：超时事件，-1为永远等待</li></ul></li><li>events的类型定义在头文件 poll.h 中<ul><li><strong>POLLIN / POLLRDNORM</strong> ：可读</li><li><strong>POLLPRI</strong>：特殊事件可读（exceptional condition）（存在带外数据等）</li><li><strong>POLLOUT / POLLWANORM</strong>：可写</li><li><strong>POLLRDHUP</strong>：流套接字对等端关闭连接</li><li><strong>POLLERR</strong>：错误</li><li><strong>POLLHUP</strong>：关闭</li><li><strong>POLLNVAL</strong>：非法请求</li><li><strong>POLLRDBAND / POLLWRBAND</strong>：优先数据可读 / 写</li></ul></li></ul></li><li><p>poll的使用与select基本一致</p><p>区别是poll不需要额外的集合来保存需要检测的事件和返回的文件描述符，所有的相关数据都保存在响应的结构体中。</p><p>且</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nready;</span><br><span class="line">client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    nready = poll(client, maxidx + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(nready == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nready == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">    &#123;</span><br><span class="line">        peerlen = <span class="keyword">sizeof</span>(peeraddr);</span><br><span class="line">        <span class="keyword">if</span> ((conn = accept(listenfd, (struct sockaddr *)&amp;peeraddr, &amp;peerlen)) &lt; <span class="number">0</span>)</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; POLLSIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(client[i].fd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                client[i].fd = conn;</span><br><span class="line">                client[i].events = POLLIN;</span><br><span class="line">                maxidx = i &gt; maxidx ? i : maxidx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == POLLSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;too many clients\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip = %s port = %d\n&quot;</span>, inet_ntoa(peeraddr.sin_addr), ntohs(peeraddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(--nready &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; POLLSIZE; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        conn = client[i].fd;</span><br><span class="line">        <span class="keyword">if</span>(conn == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(client[i].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> recvbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">int</span> ret = readline(conn, recvbuf, <span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ERR_EXIT(<span class="string">&quot;client readline&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client %d close\n&quot;</span>, conn);</span><br><span class="line">                client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                close(conn);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fputs</span>(recvbuf, <span class="built_in">stdout</span>);</span><br><span class="line">            <span class="comment">// sleep(3);</span></span><br><span class="line">            written(conn, recvbuf, <span class="built_in">strlen</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h6><ul><li><p>epoll的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>epoll_event.events事件定义：与poll大部分一致<ul><li>EPOLLET：设置关联文件描述符的边缘触发行为。epoll的默认行为是级别触发的。有关边缘和级别触发事件分布体系结构的更多详细信息</li></ul></li><li>epoll_create 和 epoll_create1。底层 数据结构更改，现在的epoll不使用哈希表，而是用红黑树，所以不需要size的参数</li><li>flags<ul><li>EPOLL_CLOEXEC：当进程执行exec后 ，文件描述符会被关闭（<strong>close-on-exec</strong>）</li></ul></li><li><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code><ul><li>event：文件描述符 fd 所关心的事件</li><li>op：存在三种方式<ul><li>EPOLL_CTL_ADD：向epoll添加文件描述符</li><li>EPOLL_CTL_MOD：修改文件描述符的event</li><li>EPOLL_CTL_DEL：删除epoll中的文件描述符</li></ul></li></ul></li><li><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code><ul><li>events：返回值，包含可用事件</li><li>maxevents：最大容量</li><li>timeout：超时时间，-1 表示不超时</li></ul></li></ul></li><li><p>epoll的两种模式</p><ul><li>EPOLLLT ： 电平触发<ul><li>完全靠kernel epoll驱动，应用程序只需要处理从epoll_wait返回的fds，这些fds我们认为它们处于就绪状态。</li></ul></li><li>EPOLLET ： 边沿触发<ul><li>此模式下，系统仅仅通知应用程序哪些fds变成了就绪状态，一旦fd变成就绪状态，epoll将不再关<br>注这个fd的任何状态信息，（从epoll队列移除）直到应用程序通过读写操作触发EAGAIN状态，<br>epoll认为这个fd又变为空闲状态，那么epoll又重新关注这个fd的状态变化（重新加入epoll队列）</li><li>随着epoll_wait的返回，队列中的fds是在减少的，所以在大并发的系统中，EPOLLET更有优势。但是对程序员的要求也更高。</li></ul></li></ul></li><li><p>epoll使用案例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组保存客户端文件描述符</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; clients;</span><br><span class="line"><span class="comment">//创建epoll实例</span></span><br><span class="line"><span class="keyword">int</span> epollfd;</span><br><span class="line">epollfd = <span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将连接套接字加入epoll中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.data.fd = listenfd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, listenfd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存所有ready的列表</span></span><br><span class="line"><span class="function">vector&lt;struct epoll_event&gt; <span class="title">events</span><span class="params">(<span class="number">16</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> conn;</span><br><span class="line"><span class="keyword">int</span> nready;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">socklen_t</span> peerlen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peeraddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用epoll_wait返回所有ready文件描述符，保存在events数组中</span></span><br><span class="line">    <span class="comment">//static_cast为强制类型转换</span></span><br><span class="line">    nready = <span class="built_in">epoll_wait</span>(epollfd, &amp;*events.<span class="built_in">begin</span>(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(events.<span class="built_in">size</span>()), <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nready == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nready == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组扩容</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">size_t</span>)nready == events.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        events.<span class="built_in">resize</span>(events.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历events数组中的所有ready文件描述符</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nready; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是监听套接口</span></span><br><span class="line">        <span class="keyword">if</span>(events[i].data.fd == listenfd)</span><br><span class="line">        &#123;</span><br><span class="line">            peerlen = <span class="built_in"><span class="keyword">sizeof</span></span>(peeraddr);</span><br><span class="line">            <span class="keyword">if</span> ((conn = <span class="built_in">accept</span>(listenfd, (struct sockaddr *)&amp;peeraddr, &amp;peerlen)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip = %s port = %d\n&quot;</span>, <span class="built_in">inet_ntoa</span>(peeraddr.sin_addr), <span class="built_in">ntohs</span>(peeraddr.sin_port));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>, ++count);</span><br><span class="line">            clients.<span class="built_in">push_back</span>(conn);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置该套接口为非阻塞模式</span></span><br><span class="line">            <span class="built_in">set_nonblock</span>(conn, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将新连接的套接口放入epoll中</span></span><br><span class="line">            event.data.fd = conn;</span><br><span class="line">            event.events = EPOLLIN | EPOLLET;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, conn, &amp;event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//非监听套接口</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            conn = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span>(conn == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//存在可读事件</span></span><br><span class="line">            <span class="keyword">if</span>(events[i].events &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> recvbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> ret = <span class="built_in">readline</span>(conn, recvbuf, <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ERR_EXIT</span>(<span class="string">&quot;client readline&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//对方断开连接</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client %d close\n&quot;</span>, conn);</span><br><span class="line">                    <span class="built_in">close</span>(conn);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条用ctl将该文件描述符从epoll中删除，并且从clients数组中删除</span></span><br><span class="line">                    event = events[i];</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, conn, &amp;event);</span><br><span class="line">                    clients.<span class="built_in">erase</span>(<span class="built_in">remove</span>(clients.<span class="built_in">begin</span>(), clients.<span class="built_in">end</span>(), conn), clients.<span class="built_in">end</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line"><span class="comment">//回复</span></span><br><span class="line">                <span class="built_in">fputs</span>(recvbuf, stdout);</span><br><span class="line">                <span class="built_in">written</span>(conn, recvbuf, <span class="built_in">strlen</span>(recvbuf));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="epoll和poll、select的区别"><a href="#epoll和poll、select的区别" class="headerlink" title="epoll和poll、select的区别"></a>epoll和poll、select的区别</h6><ul><li>epoll不会随着监听fd数目的增长而降低效率</li><li>select、poll的实现是采用遍历查询的方式处理；epoll是基于回调来实现的，当fd有期望的事件发生就通过回调函数将其加入epoll的就绪队列中。</li><li>内核/用户空间内存拷贝问题，如何让内核把fd消息通知给用户空间呢？在这个问题上select/poll采取了内存拷贝方法。而epoll采用了共享内存的方式。</li><li>epoll的epoll_event结构体会保存事件的相关信息，不用遍历所有的fd集合查询</li></ul><h6 id="UDP-模型"><a href="#UDP-模型" class="headerlink" title="UDP 模型"></a>UDP 模型</h6><p><img src="/images/Linux网络编程/image-20221206181754980.png" alt="UDP 模型"></p><p><img src="/images/Linux网络编程/image-20221206192819344.png" alt="image-20221206192819344"></p><h6 id="简单的客户端和服务端实现"><a href="#简单的客户端和服务端实现" class="headerlink" title="简单的客户端和服务端实现"></a>简单的客户端和服务端实现</h6><ul><li><p>服务端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_srv</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> recvbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peeraddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> peerlen;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        peerlen = <span class="keyword">sizeof</span>(peeraddr);</span><br><span class="line">        <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">        <span class="comment">//接收数据，并包含地址信息</span></span><br><span class="line">        n = recvfrom(sock, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>, (struct sockaddr*)&amp;peeraddr, &amp;peerlen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;reacvfrom&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过接收的地址信息将消息发回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fputs</span>(recvbuf, <span class="built_in">stdout</span>);</span><br><span class="line">            sendto(sock, recvbuf, n, <span class="number">0</span>, (struct sockaddr*)&amp;peeraddr, peerlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//n = 0 不代表连接关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">if</span>((sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化端口和地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定地址</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sock, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    echo_srv(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cli</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="comment">//初始化服务器的地址</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> sendbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> recvbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//获取输入</span></span><br><span class="line"><span class="keyword">while</span>(fgets(sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//发送给服务端</span></span><br><span class="line">sendto(sock, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">        recvfrom(sock, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fputs</span>(recvbuf, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line"><span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//udp 客户端不需要对端口进行绑定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">if</span>((sock = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">echo_cli(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>udp发送失败回得到一个异步错误（icmp错误），在接收时才能知道</p></li><li><p>通过connect解决：使套接字连接到远程地址，此时调用sendto不需要远程地址，即可以直接调用send</p></li></ul><h6 id="udp实现聊天室"><a href="#udp实现聊天室" class="headerlink" title="udp实现聊天室"></a>udp实现聊天室</h6><p><img src="/images/Linux网络编程/image-20221207144448433.png" alt="架构"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h5 id=&quot;Socket编程GitHub&quot;&gt;&lt;a href=&quot;#Socket编程GitHub&quot; class=&quot;headerlink&quot; title=&quot;Socket编程GitHub&quot;&gt;&lt;/a&gt;Socket编程&lt;a href=&quot;htt</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://kennyyyyyy.github.io/tags/Linux/"/>
    
    <category term="Socket" scheme="http://kennyyyyyy.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>操作系统/计网/数据库</title>
    <link href="http://kennyyyyyy.github.io/2022/09/22/%E5%85%AB%E8%82%A1/"/>
    <id>http://kennyyyyyy.github.io/2022/09/22/%E5%85%AB%E8%82%A1/</id>
    <published>2022-09-22T09:33:32.000Z</published>
    <updated>2022-12-01T12:01:21.816Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><hr><h6 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h6><ul><li>进程：一个在内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。</li><li>线程：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</li><li>区别<ul><li>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</li><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</li><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。</li></ul></li></ul><h6 id="谷歌浏览器为什么是多进程"><a href="#谷歌浏览器为什么是多进程" class="headerlink" title="谷歌浏览器为什么是多进程"></a>谷歌浏览器为什么是多进程</h6><ul><li><p>浏览器存在单进程架构和多进程架构</p></li><li><p>单进程架构</p><ul><li>所有的功能模块都是运行在同一个进程里的。可能会导致 不稳定、不流畅、不安全。</li></ul></li><li><p>对进程架构</p><ul><li>具备更好的容错性，提供安全性和沙盒性。</li><li>谷歌浏览器的进程：<ul><li>浏览器进程（Browser Process），浏览器的主进程，负责包括地址栏、前进后退按钮、处理网络访问、文件访问等。</li><li>渲染进程（Renderer Process），控制显示网站的选项卡内的所有内容。</li><li>插件进程（Plugin Process），控制网站使用的所有插件。</li><li>GPU（GPU Process），与其他进程隔离处理GPU任务，由于GPU处理来自多个应用程序的请求并将它们绘制在同一表面上，因此将其分为不同的过程。</li><li>网络进程（NetWork Process），负责页面的网络资源加载，之前是放在浏览器进程中的一个线程运行，现在独立出来。</li></ul></li></ul></li><li><p><a href="https://deepu.tech/memory-management-in-programming/">编程语言中的内存管理</a></p><ul><li><p>当软件在计算机上的目标操作系统上运行时，它需要访问计算机<strong>RAM</strong>（随机存取存储器）：</p><ul><li>加载自己需要执行的<strong>字节码</strong></li><li>存储被执行的程序使用的<strong>数据值</strong>和<strong>数据结构</strong></li><li>加载程序执行所需的任何<strong>运行时系统</strong></li></ul><p>当软件程序使用内存时，除了用于加载字节码的空间外，它们还使用两个内存区域，堆栈和堆内存</p></li><li><p><strong>Stack</strong></p><ul><li><strong>静态内存分配</strong>，后进先出 ( <strong>LIFO</strong> ).</li><li><strong>多线程应用程序</strong>的每个线程可以有一个<strong>堆栈</strong>。</li><li>堆栈的内存管理由操作系统完成。</li><li>存储在堆栈上的典型数据是<strong>局部变量</strong>（值类型或原语、原语常量）、<strong>指针</strong>和<strong>函数帧</strong>。</li></ul></li><li><p><strong>Heap</strong></p><ul><li>堆用于<strong>动态内存分配，与堆栈不同，程序需要使用指针</strong>在堆中查找数据。</li><li>储存具有<strong>动态大小的数据</strong>。</li><li>堆在程序的线程之间共享。</li><li>存储在堆上的典型数据是<strong>全局变量</strong>、<strong>引用类型</strong>（如对象、字符串、映射和其他复杂数据结构）。</li></ul></li><li><p>JAVA和C++的区别（GC）</p><ul><li><p><strong>Mark &amp; Sweep GC</strong>（JVM(Java/Scala/Groovy/Kotlin)<strong>、</strong>JavaScript）</p><p>遍历所有的被引用的对象，并标记。清理所有的未被标记的对象</p><p><img src="/images/八股/AZaR0LP.gif" alt="标记清除 GC"></p></li><li><p>引用计数GC（c++）</p><p>在这种方法中，每个对象都会获得一个引用计数，该计数会随着对其引用的更改而递增或递减，并且当计数变为零时完成垃圾收集。</p><ul><li>无法处理循环引用</li></ul></li></ul></li></ul></li><li><p><a href="https://www.geeksforgeeks.org/memory-management-in-operating-system/">操作系统中的内存管理</a></p><ul><li><p>主存储器（Main Memory）</p><p>主存储器是计算机运行的核心，是CPU和 I/O 设备共享的快速存储库，也称为RAM。</p><p>是易失性内存，断电时数据回丢失</p><p><img src="/images/八股/1white-660x453.png" alt></p></li><li><p>内存管理</p><p>在不同进程之间细分内存的任务称为内存管理，用于管理进程执行期间主存和磁盘之间的操作，主要目的时实现内存的高效利用</p><ul><li>在进程执行之前和之后分配和取消分配内存。</li><li>跟踪进程使用的内存空间。</li><li>尽量减少碎片问题。</li><li>正确使用主存。</li><li>在执行流程时保持数据完整性。</li></ul></li><li><p>逻辑地址和物理地址</p><ul><li>逻辑地址：虚拟地址，由cpu生成。可以定义进程的大小，更改逻辑地址</li><li>物理地址：真实地址，由MMU计算.</li></ul></li><li><p>静态加载和动态加载</p><p>将进程加载到主内存中是由加载程序完成的。</p><ul><li>静态加载：将整个程序加载到固定地址，需要较多的内存空间</li><li>动态加载：在动态加载中，例程在调用之前不会加载。所有例程都以可重定位加载格式驻留在磁盘上。动态加载的优点之一是永远不会加载未使用的例程。</li></ul></li><li><p>静态链接和动态链接</p><p>要执行链接任务，需要使用链接器。链接器是一种程序，它接受一个或多个由编译器生成的目标文件，并将它们组合成一个单一的可执行文件。</p><ul><li>静态链接：在静态链接中，链接器将所有必需的程序模块组合成单个可执行程序。所以没有运行时依赖。</li><li>动态链接：在动态链接中，每个适当的库例程引用都包含“存根”。存根是一小段代码。执行存根时，它会检查所需的例程是否已在内存中。如果不可用，则程序将例程加载到内存中。</li></ul></li><li><p>分页</p></li></ul></li><li><p><a href="https://medium.com/@akhandmishra/operating-system-process-and-process-management-108d83e8ce60">进程和进程管理</a></p><ul><li><p>进程生命周期</p><p><img src="/images/八股/0gbMa8zMgZTDImMU6.png" alt="进程生命周期"></p><ul><li>new：进程首次启动/创建时的初始状态。</li><li>ready：进程在就绪队列中等待分配给处理器。</li><li>running：一旦被分配给处理器，就改为运行态。</li><li>terminated：完成或遇到错误，进入终止状态。等待从主存中删除。</li></ul></li></ul></li></ul><h4 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h4><ul><li><p>流媒体传输协议</p></li><li><p>传输层协议：</p><ul><li><p>TCP：面向连接的、可靠的、基于字节流的</p><p>SYN：同步序列号；ACK：确认字符；seq：序列号</p><ul><li><p>三次握手：</p><ol><li>Client =&gt; Server : SYN = 1, seq = x</li><li>Server =&gt; Client : SYN = 1, ACK = 1, seq = y, ack = x + 1</li><li>Client =&gt; Server : ACK = 1, seq = x + 1, ack = y + 1</li></ol></li><li><p>四次挥手：</p><ol><li>Client =&gt; Server : FIN = 1, seq = x</li><li>Server =&gt; Cilent : ACK = 1, seq = y, ack = x + 1</li><li>Server =&gt; Client : FIN = 1, ACK = 1, seq = z, ack = x + 1；服务端关闭</li><li>Client =&gt; Server : ACK = 1, seq = x + 1, ack = z + 1</li><li>等待两倍报文最大生存时间后客户端关闭</li></ol></li></ul></li><li><p>UDP：无连接的、不可靠的、面向数据报的</p></li><li><p>区别：</p><ul><li>TCP是一对一的传输，UDP支持一对一、一对多、多对多的交互通信</li><li>TCP首部长度长，开销较大；UDP首部8个字节，固定不变，开销较小</li></ul></li></ul></li><li><p>Socket通信：</p><p><a href="https://www.bilibili.com/video/av33813135/?vd_source=54dc3dfdd22adc8b2340096bbe891dad">网络编程</a></p><ol><li><p>流程：服务端监听，客户端请求，确认连接进行通信</p></li><li><p>c++下的Socket</p><ol><li><p>创建Socket</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">af:一个地址家族，通常为AF_INET</span></span><br><span class="line"><span class="comment">type:套接字类型，SOCK_STREAM表示创建面向流连接的套接字;为SOCK_DGRAM，表示创建面向无连接的数据包套接字;为SOCK_RAW，表示创建原始套接字.</span></span><br><span class="line"><span class="comment">protocol:套接字所用协议，不指定可以设置为0</span></span><br><span class="line"><span class="comment">返回值就是一个socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">int</span> ytpe, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>绑定端口和地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockeSrv为socket；addrSrv为结构体指针，包含端口和IP地址信息；第三个参数为缓冲区长度，一般为sizeof计算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_family = AF_INET;</span><br><span class="line">addrSrv.sin_port = <span class="built_in">htons</span>(<span class="number">8088</span>); <span class="comment">//1024~65535中的端口号</span></span><br><span class="line">addrSrv.sin_addr.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;154.152.70.22&quot;</span>); </span><br><span class="line"><span class="comment">//通过inet_addr函数将字符串转化为整型(in_addr_t)</span></span><br><span class="line"><span class="built_in">bind</span>(sockSrv, (LPSOCKADDR)&amp;addrSrv, <span class="built_in"><span class="keyword">sizeof</span></span>(SOCKADDR_IN));</span><br></pre></td></tr></table></figure></li><li><p>服务端监听</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1:socket</span></span><br><span class="line"><span class="comment">2:等待连接队列长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">listen</span>(sockSrv, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>服务端接收客户端请求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1：socekt</span></span><br><span class="line"><span class="comment">2:包含客户端端口IP信息的sockaddr_in结构体指针</span></span><br><span class="line"><span class="comment">3：接收参数addr的长度</span></span><br><span class="line"><span class="comment">返回值为socket。可以在客户端和服务端接受和发送数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">accept</span>(sockSrv, (SOCKADDR*)&amp;addrClient, <span class="built_in"><span class="keyword">sizeof</span></span>(SOCKADDR));</span><br></pre></td></tr></table></figure></li><li><p>关闭连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">colsesocket</span><span class="params">(SOCKET s)</span></span></span><br></pre></td></tr></table></figure></li><li><p>客户端发送连接请求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1:socket</span></span><br><span class="line"><span class="comment">2:结构体执政，包括主机的IP地址</span></span><br><span class="line"><span class="comment">3：缓冲区大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">connect</span>(sockCLient, (SOCKADDR*)&amp;addrSrv, <span class="built_in"><span class="keyword">sizeof</span></span>(addrSrv));</span><br></pre></td></tr></table></figure></li><li><p>接收消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1: 建立好连接的socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">recv</span>(sockClient, buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>发送消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">send</span>(sockClient, buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>通信</p><p><img src="/images/八股/image-20221130172037684.png" alt="image-20221130172037684"></p><ul><li><p>Application 层        </p><ul><li>对数据进行编码</li><li>发送者信息</li></ul></li><li><p>TCP 层</p><ul><li>全双工通信（可以接收和发送）、可靠的（确认和重传、数据校验、分片和排序）、stream流的、协议（protocal）</li><li><p>stream 流 ：即连续的，有前后、有顺序的。<strong>在任意指定时刻，可读的数据量都是不确定的</strong></p><ul><li>如何优化包传输/即包大小</li></ul></li><li><p>packet 包：不连续的，以包为发送单位。</p></li></ul></li><li><p>IP 层</p><ul><li>对端的身份的定位</li></ul></li></ul></li><li><p>Domain Name Service DNS：域名解析服务</p><ul><li>将网址翻译成一个能够在互联网上找到相应的服务器的IP地址。</li></ul></li><li><p><a href="https://blog.csdn.net/YoYuanZhizheng/article/details/122904884">网络编程模型</a></p><ul><li><p>select</p><ul><li><p>单线程模型，阻塞操作</p></li><li><p>只能同时处理一个client的连接，没有处理多个连接的能力</p></li></ul><p><img src="/images/八股/image-20221130225729388.png" alt="image-20221130225729388"></p></li><li><p>多线程模型</p><ul><li>每个client对应一个线程连接</li><li>管理线程过多，效率过低</li></ul><p><img src="/images/八股/image-20221130230326372.png" alt="image-20221130230326372"></p></li><li><p>多路复用模型(epoll)</p><ul><li>一个线程可以对应多个连接</li><li>相当于线程池</li></ul><p><img src="/images/八股/image-20221130231630577.png" alt="image-20221130231630577"></p></li><li><p>一个线程处理多个连接（epoll）</p><ul><li>ready list 保存所有的就绪fd的指针</li><li>每次挂起操作只会从ready list中查找就绪的fd</li></ul><p><img src="/images/八股/image-20221201005424487.png" alt="image-20221201005424487"></p></li><li><p>io uring</p><ul><li>submission：提交的请求操作列表</li><li>complete：请求操作的返回结果</li><li>用户态可访问的无锁环形队列</li></ul><p><img src="/images/八股/image-20221201010248312.png" alt="image-20221201010248312"></p></li></ul></li></ul><ul><li><p><a href="https://www.cloudflare.com/zh-cn/learning/ddos/glossary/hypertext-transfer-protocol-http/">HTTP</a>：超文本传输协议</p><ul><li><p><a href="https://kamranahmed.info/blog/2016/08/13/http-in-depth">发展过程</a></p><ul><li><p>HTTP/0.9</p><ul><li>只有 GET</li><li>没有标题/响应的必须是HTML</li></ul></li><li><p>HTTP/1.0</p><ul><li><p>增加了HOST</p></li><li><p>可以处理其他格式的响应（图像、视频等）</p></li><li><p>添加了跟多的方法（POST、HEAD）</p></li><li><p>添加了状态码以识别响应</p></li><li><p>响应格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>137582</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache 0.84</span><br><span class="line"></span><br><span class="line">(response body)</span><br><span class="line">(connection closed)</span><br></pre></td></tr></table></figure><p>不能有多个请求，对于任意的下一个请求，都需要新建一个连接</p></li></ul></li><li><p>HTTP/1.1</p><ul><li>添加了新的方法（PUT、PATCH、OPTIONS、DELETE）</li><li>持久连接：一个链接可以处理多个请求</li><li>引入了对流水线（pipelining）的支持，即客户端可以发送多个请求，不需要等待服务器的响应，而服务器必须按接收顺序发送响应</li></ul></li><li><p>HTTP/2</p><ul><li>二进制 替换 文本 </li><li>多路复用：通过单个连接处理多个http请求</li><li>使用HPACK进行header压缩：文字值使用霍夫曼代码编码，标头表由客户端和服务器以及客户端和服务器维护在后续请求中省略任何重复的标头。</li><li>Server Push ：单个请求可以有多个响应</li><li>请求优先级</li><li>安全  </li></ul></li></ul></li><li><p>状态代码</p><ul><li>1xx 信息性</li><li>2xx 成功</li><li>3xx Redirection</li><li>4xx 客户端错误</li><li>5xx 服务器错误</li></ul></li></ul></li></ul><h4 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h4><ul><li><p>数据对齐</p><p>1.数据或结构体、类中的数据成员的存储起始地址为有效对齐值N的倍数。</p><p>2.结构体或类或联合体最终的大小应为有效对齐值N的倍数（圆整）。</p><p>基本数据类型</p><p>char: 1；short：2；int：4；float：4；long：4；long long：8；double：8；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cl</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> aa;</span><br><span class="line">    <span class="keyword">short</span> aaa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sizeof(Cl) = 12</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> aa;</span><br><span class="line">    <span class="keyword">int</span> aaa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sizeof(c2) = 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> aa;</span><br><span class="line">    <span class="keyword">double</span> aaa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sizeof(c3) = 16;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> aa;</span><br><span class="line">    <span class="keyword">short</span> aaa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sizeof(c4) = 24;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li><p>关系型数据库：</p><ul><li><p>优点：</p><ul><li>结构简单、易于维护：都是使用表结构，格式一致；数据库设计和规范化过程也简单易行和易于理解。</li><li>使用方便、灵活：使用标准查询语言SQL，允许用户几乎毫无差别地从一个产品到另一个产品存取信息。与关系数据库接口的应用软件具有相似的程序访问机制，提供大量标准的数据存取方法。</li><li>复杂操作：可以进行join等复杂查询；</li><li>保持数据的一致性；</li><li>由于以标准为前提，数据更新的开销小（相同的字段基本都是只有一处）；</li><li>存在很多实际成果和专业技术信息（成熟的技术）。</li></ul></li><li><p>缺点：</p><ul><li>数据类型表达能力差：关系数据模型不直接支持复杂的数据类型。</li><li>复杂读写功能差。</li><li>支持长事务能力差：由于RDBMS记录锁机制的颗粒度限制，对于支持多种记录类型的大段数据的登记和查询来说，简单的记录级的锁机制是不够</li><li>环境应变能力差：在要求系统频繁改变的环境下，关系系统的成本高且修改困难。</li><li>读写性能：面对海量数据的高并发读写需求，效率就会变得很差，硬盘I/O是一个很大的瓶颈；</li><li>扩展方式：固定的表结构，灵活度稍欠，如字段不固定时的应用；</li></ul></li><li><p>存储过程：</p><ul><li><p>优点：</p><p>1、重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。</p><p>2、减少网络流量：存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。</p><p>3、安全性：参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。</p></li><li><p>缺点：</p><p>1、更改比较繁琐：如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则仍需要更新程序集中的代码以添加参数、更新 GetValue() 调用。</p><p>2、可移植性差：由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。如果应用程序的可移植性在您的环境中非常重要，则需要将业务逻辑封装在不特定于 RDBMS 的中间层中。</p></li></ul></li></ul></li><li><p><a href="https://github.com/Vonng/ddia">设计数据密集型应用</a></p><ul><li><p>要求</p><ul><li><p>可靠性（Reliability）</p><p>系统在 <strong>困境</strong>（adversity，比如硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。</p></li><li><p>可伸缩性（Scalability）</p><p>有合理的办法应对系统的增长（数据量、流量、复杂性）。</p></li><li><p>可维护性（Maintainability）</p><p>许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。</p></li></ul></li></ul></li></ul><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/composite">设计模式</a></li><li><a href="https://gpp.tkchu.me/introduction.html">游戏设计模式</a></li></ul><h4 id="图形学-大概"><a href="#图形学-大概" class="headerlink" title="图形学(大概)"></a>图形学(大概)</h4><ul><li><p><a href="https://www.freesion.com/article/97131313052/">mipmap</a>：<strong>多级渐远纹理</strong></p><p>一系列的纹理图像，后一个纹理图像是前一个的二分之一。</p><p>当物体距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个纹理。</p><ul><li></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h4&gt;&lt;hr&gt;
&lt;h6 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; clas</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://kennyyyyyy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="计算机网络" scheme="http://kennyyyyyy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="数据库" scheme="http://kennyyyyyy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C/C++方向</title>
    <link href="http://kennyyyyyy.github.io/2022/09/21/CC++%E6%96%B9%E5%90%91/"/>
    <id>http://kennyyyyyy.github.io/2022/09/21/CC++%E6%96%B9%E5%90%91/</id>
    <published>2022-09-21T12:09:10.000Z</published>
    <updated>2022-11-30T09:14:13.596Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h6 id="C中如何调用C-函数"><a href="#C中如何调用C-函数" class="headerlink" title="C中如何调用C++函数"></a>C中如何调用C++函数</h6><ol><li><p>对于非成员函数，将 C++ 函数声明为 <code>extern &quot;C&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ code</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">f</span>(i);</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于成员函数，需要简单包装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">double</span> <span class="title">call_C_f</span><span class="params">(C* p, <span class="keyword">int</span> i)</span> <span class="comment">// wrapper function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;<span class="built_in">f</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c code</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">call_C_f</span><span class="params">(struct C* p, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(struct C* p, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="built_in">call_C_f</span>(p, i);</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若要调用重载函数，则需要提供不同名字的包装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++ code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">f_i</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="built_in">f</span>(i) &#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">f_d</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123; <span class="built_in">f</span>(d) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_i</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_d</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fff</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f_i</span>(i);</span><br><span class="line">    <span class="built_in">f_d</span>(d);</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>计网</p><h5 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a><a href="https://www.bilibili.com/video/av33813135/?vd_source=54dc3dfdd22adc8b2340096bbe891dad">网络编程</a></h5><ul><li>cache(缓存): cost/benefit<ul><li>cost: 需要缓存的数据会给系统带来的代价</li></ul></li><li></li></ul><p>内存管理 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h6 id=&quot;C中如何调用C-函数&quot;&gt;&lt;a href=&quot;#C中如何调用C-函数&quot; class=&quot;headerlink&quot; title=&quot;C中如何调用C++函数&quot;&gt;&lt;/a&gt;C中如何调用C++函数&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于非</summary>
      
    
    
    
    
    <category term="C/C++" scheme="http://kennyyyyyy.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>知识点记录(Unity/C#)</title>
    <link href="http://kennyyyyyy.github.io/2022/08/19/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2022/08/19/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</id>
    <published>2022-08-19T14:13:21.000Z</published>
    <updated>2022-11-28T03:07:57.671Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h5 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h5><ol><li><p><strong>从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Material material = Render.materials;</span><br><span class="line">material.shader = targetShader;</span><br><span class="line"><span class="comment">//修改 Shader 中参数的值：</span></span><br><span class="line">material.SetFloat(“参数名”，值); </span><br><span class="line">material.SetColor(“参数名”，颜色值); </span><br><span class="line">material.SetTexture(“参数名”，贴图); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Shader 中参数的值：</span></span><br><span class="line">material.GetFloat(“参数名”);</span><br><span class="line">material.GetColor(“参数名”); </span><br><span class="line">material.GetTexture(“参数名”); </span><br></pre></td></tr></table></figure></li></ol><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ol><li><p><strong>给定一个数组，有n(n &gt;= 0)个元素，找到数组中第二大的元素</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1 5 9 2 1 6 4 2 3 9</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetScendNum</span>(<span class="params"><span class="built_in">int</span>[] number, <span class="built_in">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> first=number[<span class="number">0</span>],second=number[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(number[i]&gt;first)&#123;</span><br><span class="line">            second=first;</span><br><span class="line">            first=number[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i]&gt;second)</span><br><span class="line">                second=number[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 若第二和第一相等，则将当前值赋予第二</span></span><br><span class="line">                second = first==second ? number[i] : second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给定一个可包含重复数字的序列 nums ，按序列内字典升序返回所有不重复的全排列。</strong></p><p><strong>其中序列内字典升序指的是， 序列内从左到右的非降序排列，例如 nums=[1,2,3], 则因为[1,2,3] &lt; [1,3,2], [3,1,2] &lt; [3,2,1]， [1,2,3]要先于[1,3,2]输出，[3,1,2]要先于[3,2,1]输出</strong></p><ol><li><p>使用STL库用来计算排列组合关系的算法：next_permutation和prev_permutation。</p><p>即按字典序(lexicographical)来找到下一个或前一个的排列组合。例：{2，1，3}的下一个是{2，3，1}，前一个是{1，3，2}。字典序即两个组合从左往右依次比较，若某一位A比B小，则A的字典序在B之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">UniquePerm</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">    res.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h5 id="oop的四个特征"><a href="#oop的四个特征" class="headerlink" title="oop的四个特征 "></a><strong>oop的四个特征 </strong></h5><p><strong>抽象、封装、继承、多态</strong></p><ul><li>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。</li><li>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。这也体现了大自然中一般与特殊的关系。继承性很好的解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。</li><li>封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。</li><li><p>多态性是指的是同一接口的不同实现方式，多态允许基类的指针指向子类方法。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p><ul><li><p>多态的作用：</p><ul><li>不必编写每一子类的功能调用，可以直接把不同子类当父类看，屏蔽子类间的差异，提高代码的通用率/复用率</li></ul></li></ul></li><li>父类引用可以调用不同子类的功能，提高了代码的扩充性和可维护性</li></ul><h5 id="迭代器和数组的区别"><a href="#迭代器和数组的区别" class="headerlink" title="迭代器和数组的区别"></a><strong>迭代器和数组的区别</strong></h5><p>迭代器：<strong>迭代器</strong>（iterator）有时又称<strong>光标</strong>（cursor）是程序设计的<a href="https://baike.baidu.com/item/软件设计模式">软件设计模式</a>，可在容器对象（container，例如<a href="https://baike.baidu.com/item/链表">链表</a>或<a href="https://baike.baidu.com/item/数组">数组</a>）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。</p><ul><li><p><a href="https://blog.csdn.net/lx2054807/article/details/107981276?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107981276-blog-123304449.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107981276-blog-123304449.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=2">C#</a> </p><ul><li><p>迭代器模式 指按照一定顺序来访问一个集合对象中的每个元素, 但是同时不会暴露集合对象的内部结构. C#中内置的迭代器模式就是Foreach语句, 它可以顺序遍历容器中的每个元素. 而迭代器的具体实现主要是靠IEnumerable 和IEnumerator.</p></li><li><p><strong>IEnumerator</strong></p><p>IEnumerator接口其实就是<a href="https://so.csdn.net/so/search?q=foreach&amp;spm=1001.2101.3001.7020">foreach</a>的具体实现, 它只定义了三个函数, 如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们实现一个最简单的IEnumerator接口只需要实现这三个函数即可. MoveNext()表示向集合中的下一个元素移动, 如果有下一个元素返回true, 没有就返回false. Current是一个只读属性, 返回当前迭代器所指元素. Reset()表示重置迭代器到第一个元素.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIEnumerator</span>: <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        count = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的IEnumerator, 如果用Foreach输出, 可以得到从9到0的十个计数. 而具体的实现过程还需要IEnumerable.</p></li><li><p><strong>IEnumerable</strong></p><p>IEnumerable可以粗略的理解为可迭代(遍历)的, 如果接口继承了IEnumerable, 那么就可以使用Foreach语句进行迭代操作. 这个接口只定义了一个函数, 如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数需要返回一个我们刚才定义的IEnumerator, 即告知上层调用方可以枚举.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIEnumerable</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个时候我们的迭代器已经实现, 可以使用Foreach语句进行迭代操作.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> VARIABLE <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">MyIEnumerable</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(VARIABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在有一个完整的迭代器了, 但是有一个问题, 很多时候我们需要的迭代器并不复杂, 如上面的计数装置, 如果每次都需要实现IEnumerator和IEnumerable十分不方便, 显得头重脚轻, 这时我们可以使用yield.</p></li><li><p><strong>yield</strong></p><p>yield是为了方便使用迭代器而产生的语法糖, 他可以直接使用在返回类型为IEnumerable或IEnumerator的函数中直接实现迭代器操作. 它有两种用法yield break 和yield return (something) 效果和break与return一样. 当使用yield return在foreach语句中进行迭代器操作时, 每一次执行到yield return时都会返回后面定义的something并且记录函数内的信息, 下一次运行时继续.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> VARIABLE <span class="keyword">in</span> <span class="title">myIEnumerable</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(VARIABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable <span class="title">myIEnumerable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  这里我们在i = 5的时候使用了yield break终止了迭代器操作, 如果去掉它, 这个函数就和我们刚才定义的迭代器作用一样, 产生了9到0, 共10个数的倒数.</p><ul><li><p><strong>协程(coroutine)</strong></p><p>除了foreach语句, Unity中另一种迭代器模式就是协程, 它是根据每一次IEnumerator的MoveNext()方法调用进行迭代的, 有些类似于Unity的Update方法. 同时它可以结合Unity的yield return new WaitForSeconds(time)等等接口实行迭代器+定时器模式.<br>使用和停止协程比较简单, 都只要传入IEnumerator就可以.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Coroutine <span class="title">StartCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br></pre></td></tr></table></figure><p>使用协程的方法实现我们的从9数到0.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StartCoroutine(myCoroutine());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">myCoroutine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(i);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">myCoroutine(</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  值得注意的是unity里有很多可以和yield结合使用的语句块, 如上的代码不仅实现了从9数到0, 还实现了每隔1秒数一次, 数到0后继续从头开始数, 当然还有很多其他有趣的功能可以通过coroutine和yield实现.</p></li></ul></li></ul><h5 id="泛型的作用。"><a href="#泛型的作用。" class="headerlink" title="泛型的作用。"></a><strong>泛型的作用。</strong></h5><p><strong>泛型和传统类型Boxing/UnBoxing的区别</strong></p><ol><li><p>泛型：即通过参数化类型来实现在同一份代码上操作多种数据类型。泛型编程是一种编程范式，它利用“参数化类型”将类型抽象化，从而实现更为灵活的复用。</p></li><li><p>作用：减少拆装箱，确保类型安全</p></li><li><p>区别：</p><ul><li>装箱：值类型转引用类型。开辟一块内存空间进行存放数据。</li><li>拆箱：引用类型转值类型。</li></ul></li><li><p>写一个泛型类 C 使其继承自 CBase</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CBase</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">C</span>&lt;<span class="title">T</span>&gt; : <span class="title">CBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">C1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">CBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><ol><li><p><strong>当你接手一个新项目，当运行一段时间后，发现内存占用高且帧率低，如何解决</strong></p><p>性能优化：</p></li></ol><h5 id="C-语法"><a href="#C-语法" class="headerlink" title="C#语法"></a>C#语法</h5><h6 id="C-特性（Attribute）"><a href="#C-特性（Attribute）" class="headerlink" title="C# 特性（Attribute）"></a><strong>C# 特性（Attribute）</strong></h6><p><strong>特性（Attribute）</strong>是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。</p><p><strong>特性（Attribute）</strong>用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：<em>预定义</em>特性和<em>自定义</em>特性。</p><p>规定特性（Attribute）的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">attribute(positional_parameters, name_parameter = value, ...)</span>]</span><br><span class="line">element</span><br><span class="line">    </span><br><span class="line"><span class="comment">//特性（Attribute）的名称和值是在方括号内规定的，放置在它所应用的元素之前。</span></span><br><span class="line"><span class="comment">//positional_parameters 规定必需的信息，name_parameter 规定可选的信息。</span></span><br></pre></td></tr></table></figure><p><strong>预定义特性（Attribute）</strong></p><p>.Net 框架提供了三种预定义特性：</p><ul><li><p>AttributeUsage：描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。</p><p>规定该特性的语法如下：<br>[AttributeUsage( validon, AllowMultiple=allowmultiple，Inherited=inherited)]</p><ol><li>参数 validon规定特性可被放置的语言元素。它是枚举器AttributeTargets的值的组合。默认值是AttributeTargets.All。</li><li>参数allowmultiple(可选的)为该特性的AllowMultiple属性(property)提供一个布尔值。如果为true，则该特性是多用的。默认值是false(单用的)</li><li>参数inherited(可选的)为该特性的Inherited 属性(property)提供一个布尔值。如果为true，则该特性可被派生类继承。默认值是false(不被继承)。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AttributeUsage(AttributeTargets.Class)//只能使用在类上</span></span><br><span class="line"><span class="comment"> * AttributeUsage(AttributeTargets.Method)//只能使用在方法上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//AttributeTargets.Method|AttributeTargets.Class表示可以在类上用也可以在方法上用</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)</span>]<span class="comment">//AllowMultiple =true可以在方法上写多个[C1]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">C1</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">C2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用</span></span><br><span class="line">    [<span class="meta">C1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStr</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Conditional：我们可以将一些函数隔离出来，使得它们只有在定义了某些环节变量或者设置了某个值之后才能发挥作用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若把 #define DEBUG 注释，则Message方法不会执行。即Conditional特性只会只会在其包含的”DEBUG“定义后才能执行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Conditional(<span class="meta-string">&quot;DEBUG&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Message</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass.Message(<span class="string">&quot;In Function 1.&quot;</span>);</span><br><span class="line">        function2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass.Message(<span class="string">&quot;In Function 2.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass.Message(<span class="string">&quot;In Main function.&quot;</span>);</span><br><span class="line">        function1();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Obsolete：它标记了不应被使用的程序实体。当一个新方法被用在一个类中，但若仍然想要保持类中的旧方法，可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Obsolete(</span></span><br><span class="line"><span class="meta">   message</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line">[<span class="meta">Obsolete(</span></span><br><span class="line"><span class="meta">   message,</span></span><br><span class="line"><span class="meta">   iserror</span></span><br><span class="line"><span class="meta">)</span>]</span><br></pre></td></tr></table></figure><ul><li>参数 <em>message</em>，是一个字符串，描述项目为什么过时以及该替代使用什么。</li><li>参数 <em>iserror</em>，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">   [<span class="meta">Obsolete(<span class="meta-string">&quot;Don&#x27;t use OldMethod, use NewMethod instead&quot;</span>, true)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OldMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;It is the old method&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;It is the new method&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      OldMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当使用OldMethod方法时，编译器会报错，错误信息为Obsolete的内容</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h6><ol><li><p>密封类：不能被继承</p><ul><li>关键字：sealed</li></ul></li><li><p>接口类：接口定义了所有类继承]接口时应遵循的语法合同</p><ul><li>Interface</li></ul></li><li><p>抽象类：不能被实例化，可以包含非抽象成员</p><ul><li><p>abstract</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法只需要声明</span></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">GetName</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 抽象属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h6 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><a href="https://blog.csdn.net/qq_42455262/article/details/125223803">深拷贝</a></h6><ul><li><p>利用反射实现：此方式比较耗费性能，而且遇到对象中有值为null就会报错</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">DeepCopy</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//如果是字符串或值类型则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">string</span> || obj.GetType().IsValueType) <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">object</span> retval = Activator.CreateInstance(obj.GetType());</span><br><span class="line">  FieldInfo[] fields = obj.GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);</span><br><span class="line">  <span class="keyword">foreach</span> (FieldInfo field <span class="keyword">in</span> fields)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; field.SetValue(retval, DeepCopy(field.GetValue(obj))); &#125;</span><br><span class="line">    catch &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T)retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>二进制序列化实现：性能相对较高，遇到对象为null不会报错，需要在拷贝对象上标记[serializable]特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">DeepCopyByBinary</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">object</span> retval;</span><br><span class="line">    <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryFormatter bf = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">        bf.Serialize(ms, obj);</span><br><span class="line">        ms.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">        retval = bf.Deserialize(ms);</span><br><span class="line">        ms.Close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T)retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>xml序列化实现：遇到对象为null不会报错</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">DeepCopy</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">object</span> retval;</span><br><span class="line">    <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">    &#123;</span><br><span class="line">        XmlSerializer xml = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(T));</span><br><span class="line">        xml.Serialize(ms, obj);</span><br><span class="line">        ms.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">        retval = xml.Deserialize(ms);</span><br><span class="line">        ms.Close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T)retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>利用silverlight DataContractSerilalizer实现</p></li><li><p>利用protobuf序列化实现</p></li></ul><h5 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a><strong>反射的作用</strong></h5><p><strong>动态创建一个数据集，并获得其类型T，调用T的Create函数。</strong></p><ul><li><p>.NET的一个强大功能是它可以通过一种称为反射(reflection)的过程访问应用程序的元数据。简单地说，反射就是运行时查询类型信息的能力。可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。</p></li><li><p>反射（Reflection）有下列用途：</p><ul><li>它允许在运行时查看特性（attribute）信息。</li><li>它允许审查集合中的各种类型，以及实例化这些类型。</li><li>它允许延迟绑定的方法和属性（property）。</li><li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li></ul></li><li><p>优点：</p><ul><li>1、反射提高了程序的灵活性和扩展性。</li><li>2、降低耦合性，提高自适应能力。</li><li>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li></ul><p>缺点：</p><ul><li>1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li><li>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Rectangle r = <span class="keyword">new</span> Rectangle(<span class="number">4.5</span>, <span class="number">7.5</span>);</span><br><span class="line">        r.Display();</span><br><span class="line">        Type type = <span class="keyword">typeof</span>(Rectangle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 Rectangle 类的特性</span></span><br><span class="line">        <span class="keyword">foreach</span> (DeBugInfo attributes <span class="keyword">in</span> type.GetCustomAttributes(<span class="literal">false</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != attributes)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Bug no: &#123;0&#125;&quot;</span>, attributes.BugNo);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Developer: &#123;0&#125;&quot;</span>, attributes.Developer);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Last Reviewed: &#123;0&#125;&quot;</span>,</span><br><span class="line">                                         attributes.LastReview);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Remarks: &#123;0&#125;&quot;</span>, attributes.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Prefab"><a href="#Prefab" class="headerlink" title="Prefab"></a>Prefab</h5><p><strong>如何获得Prefab的GameObject类型，PrefabInstance和ModelPrefabInstance的区别</strong></p><h5 id="委托和事件的区别"><a href="#委托和事件的区别" class="headerlink" title="委托和事件的区别"></a><strong>委托和事件的区别</strong></h5><ol><li><p>委托类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p><p>委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 <strong>System.Delegate</strong> 类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明语法</span></span><br><span class="line"><span class="built_in">delegate</span> &lt;<span class="keyword">return</span> type&gt; &lt;<span class="built_in">delegate</span>-name&gt; &lt;parameter list&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestDelegate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    num += p;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        num *= q;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    <span class="comment">// 创建委托实例 ： 新建委托对象，传入函数签名和委托类型一致的函数</span></span><br><span class="line">        NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">        NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);</span><br><span class="line">        <span class="comment">// 使用委托对象调用方法，调用委托，传入参数</span></span><br><span class="line">        nc1(<span class="number">25</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">        nc2(<span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>事件（Event）</strong> 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。</p><p>C# 中使用事件机制实现线程间的通信。</p><p>通过事件使用委托</p><ul><li><p>事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 <strong>发布器（publisher）</strong> 类。其他接受该事件的类被称为 <strong>订阅器（subscriber）</strong> 类。事件使用 <strong>发布-订阅（publisher-subscriber）</strong> 模型。</p></li><li><p><strong>发布器（publisher）</strong> 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。</p></li><li><p><strong>订阅器（subscriber）</strong> 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilerLogHandler</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于上面的委托定义事件， 事件会在生成时调用委托</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> BoilerLogHandler BoilerEventLog;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>区别</p><ol><li><p>委托</p><ul><li>Delegate 是一个类，在任何可以声明类的地方都可以声明委托。</li><li>可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。</li></ul></li><li><p>事件</p><ul><li><p>在类的内部，它总是private 的。</p></li><li><p>在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。</p></li><li><p>使用事件不仅能获得比委托更好的封装性以外，还能限制含有事件的类型的能力。</p></li><li><p>事件应该由事件发布者触发，而不应该由事件的客户端（客户程序）来触发。</p></li></ul></li></ol></li></ol><h5 id="万向锁"><a href="#万向锁" class="headerlink" title="万向锁"></a>万向锁</h5><p>万向锁(Gimbal Lock)：一旦选择±90°作为pitch角，就会导致第一次旋转和第三次旋转等价，整个旋转表示系统被限制在只能绕竖直轴旋转，丢失了一个表示维度。</p><p>以unity为例：unity中欧拉角的旋转顺序为 y-x-z。即旋转y轴x轴和z轴都改变，旋转x轴z轴改变，旋转z轴其他轴不变。</p><p>当模型的x轴的旋转为±90度时，旋转y轴和z轴的效果是一样的，这就是万向锁。此时y轴（惯性坐标系）旋转面和z轴（模型坐标系）旋转面共面</p><p><img src="/images/笔试题记录/image-20221005214034031.png" alt></p><p>因为计算机每次执行旋转都是从[0, 0, 0]开始进行，且y轴旋转的优先级最高，此时y轴的模型坐标系和惯性坐标系的重合，因此y轴的旋转从结果上看就是惯性坐标系的旋转。</p><h5 id="Unity生命周期函数"><a href="#Unity生命周期函数" class="headerlink" title="Unity生命周期函数"></a><strong>Unity生命周期函数</strong></h5><p>Awake -&gt; OnEnable -&gt; Start -&gt; FixedUpdate -&gt; OnTrigger/OnCollision -&gt; 输入事件 -&gt; Update -&gt;  LateUpdate -&gt; 渲染(Scene -&gt; Gizmo -&gt; GUI) -&gt; OnDisable -&gt; OnDestroy</p><h5 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a><strong>AssetBundle</strong></h5><p>AssetBundle是Unity中的一种资源包，这种资源包可以是游戏内要用到的几乎所有资源，并且可以在运行时动态加载。</p><ol><li>卸载Load的asset资源，通过Resources.UnloadAsset(asset)来进行卸载；</li><li><p>压缩格式：LZMA, LZ4, 以及不压缩。</p><ol><li>LZMA是一种默认的压缩形式，这种标准压缩格式是一个单一LZMA流序列化数据文件，并且在使用前需要解压缩整个包体。能使压缩后文件达到最小，但是解压相对缓慢。</li><li>LZ4能使得压缩量更大，而且在使用资源包前不需要解压整个包体。</li><li>不压缩的方式打包后包体会很大，导致很占用空间</li></ol></li><li><p><strong>AssetBundle的卸载和加载</strong></p><ul><li><p>加载</p><ol><li><p>AssetBundle.LoadFromFile：从本地加载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundle ab = AssetBundle.LoadFromFile(<span class="string">&quot;ab包名字/所在目录/资源名称.后缀&quot;</span>);</span><br><span class="line">    GameObject gameObj= ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;资源名称&quot;</span>);</span><br><span class="line">    Instantiate(gameObj);   <span class="comment">//实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AssetBundle.LoadFromMemory：从内存加载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundle ab = AssetBundle.LoadFromMemory(File.ReadAllBytes(<span class="string">&quot;ab包名字/所在目录/资源名称.后缀&quot;</span>));</span><br><span class="line">    GameObject gameObj= ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;资源名称&quot;</span>);</span><br><span class="line">    Instantiate(gameObj);   <span class="comment">//实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AssetBundle.LoadFromMemoryAsync：从内存异步加载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundleCreateRequest request = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(<span class="string">&quot;ab包名字/所在目录/资源名称.后缀&quot;</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line">    AssetBundle ab = request.assetBundle;</span><br><span class="line">    GameObject obj = ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;资源名称&quot;</span>);</span><br><span class="line">    Instantiate(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从AB中加载资源</p><p>AssetBundle.LoadAsset(assetName) ：加载AB包中的指定对象，不包含依赖的包  AssetBundle.LoadAllAssets() ：加载AB包中所有的对象，不包含依赖的包  AssetBundle.LoadAssetAsync() ：异步加载，加载较大资源的时候  AssetBundle.LoadAllAssetsAsync() ：异步加载全部资源  AssetBundle.LoadAssetWithSubAssets() ：加载资源及其子资源</p></li></ol></li><li><p>卸载</p><ul><li>AssetBundle.Unload(true)：卸载所有资源，包含其中正被使用的资源  </li><li>AssetBundle.Unload(false)：卸载所有没被使用的资源 </li><li>Resources.UnloadUnusedAssets()：卸载未使用的资源</li></ul></li></ul></li></ol><h5 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a><strong>protobuf</strong></h5><h5 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a><strong>重写和重载的区别</strong></h5><p>​    1.定义不同—-重载是定义相同的方法名，参数不同；重写是子类重写父类的方法。</p><p>​    2.范围不同—-重载是在一个类中，重写是子类与父类之间的。</p><p>​    3.多态不同—-重载是编译时的多态性，重写是运行时的多态性。</p><p>​    4.返回不同—-重载对返回类型没有要求，而重写要求返回类型，有兼容的返回类型。</p><p>​    5.参数不同—-重载的参数个数、参数类型、参数顺序可以不同，而重写父子方法参数必须相同。</p><p>​    6.修饰不同—-重载对访问修饰没有特殊要求，重写访问修饰符的限制一定要大于被重写方法的访问修.</p><h5 id="堆-Heap-和栈-Stack"><a href="#堆-Heap-和栈-Stack" class="headerlink" title="堆(Heap)和栈(Stack)"></a><strong>堆(Heap)和栈(Stack)</strong></h5><ol><li><p>程序内存</p><ul><li><p>栈：由操作系统自动分配释放，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。：堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。</p></li><li><p>区别：</p><ul><li>管理方式不同。栈自动释放；堆手动释放，容易产生内存泄漏</li><li>空间大小不同。栈 &lt;&lt; 堆。</li><li>生长方向不同。堆的内存地址由低到高；栈的内存地址由高到低。</li><li>分配方式不同。堆都是动态分配的；栈有静态分配和动态分配。</li></ul></li></ul></li><li><p>数据结构</p><ul><li>栈：线性表。先进后出(First In Last Out).</li><li>堆：树形结构，是一种特殊的完全二叉树。满足所有节点的值总是不大于或不小于父节点的值的完全二叉树。根节点最大称为大顶堆，根节点最小称为小顶堆。</li></ul></li><li><p>值类型存储在栈中；引用类型存储在堆上。</p></li></ol><h5 id="GC"><a href="#GC" class="headerlink" title="GC"></a><strong>GC</strong></h5><p>​    什么是GC：即Garbage Collection，垃圾回收。当使用可用内存不能满足内存请求时，GC会自动进行。</p><ol><li><p><strong>C#</strong>中的GC</p><ol><li><p>GC的四个步骤。</p><ul><li><p>垃圾回收器搜索内存中的托管对象；</p></li><li><p>从托管代码中搜索被引用的对象并标记为有效；</p></li><li><p>释放没有被标记为有效的对象并收回内存；</p></li><li><p>整理内存将有效对象挪动到一起。</p></li></ul></li><li><p>GC的作用：</p><ul><li><p>提高软件系统的内聚。</p></li><li><p>降低编程复杂度，使程序员不必分散精力去处理析构。</p></li><li><p>不妨碍设计师进行系统抽象。</p></li><li><p>减少由于内存运用不当产生的Bug。</p></li><li><p>成功的将内存管理工作从程序的编写时，脱离至运行时，使不可预估的管理漏洞变为可预估的。</p></li></ul></li><li><p>什么是垃圾</p><p>只要判定一个引用类型对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。</p></li><li><p>对象代龄</p><p>CLR初始化后的第一批被创建的对象被列为0代对象。</p></li><li><p>回收方法</p><ul><li><p>Finalizer(析构函数)：一般不用，因为不确定GC调用时间，影响效率。</p></li><li><p>Dispose：继承IDisposable接口，实现Dispose方法；调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。’</p></li><li><p>Mark-Compact 标记压缩算法</p></li><li><p>Generational 分代算法</p></li></ul></li></ol></li><li><p><strong>Unity</strong>中的CG</p><ol><li>Boehm GC(非分代非压缩)<ol><li>Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGen GC的设计思想）。</li><li>Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。 </li></ol></li><li>降低GC的方法：<ol><li>使用对象池</li><li>减少string，使用StringBuilder</li><li>减少拆装箱</li><li>struct中不要有引用类型变量</li><li>主动调用GC</li></ol></li></ol></li><li><p>三色标记清除法</p><ol><li>三色：黑色、灰色、白色<ul><li><code>黑色</code>: <strong>表示对象以及被垃圾收集器访问过，且这个对象的引用都已经扫描过</strong>。黑色的对象代表以及扫描过，他是安全存活的，如果有其他对象引用指向了黑色对象，无需重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li><li><code>灰色</code>: <strong>表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描到</strong></li><li><code>白色</code>: <strong>表示对象尚未被垃圾收集器访问过</strong>。显然在可达性分析刚刚开始的阶段，所有的对象都是白色，如在分析结束的阶段，仍然是白色的对象，即代表不可达。</li></ul></li><li>步骤：<ol><li>刚开始，所有对象都在<code>白色集合</code>中</li><li>将GC Roots直接引用的对象挪到<code>灰色集合</code>中</li><li>从<code>灰色集合</code>中获取对象：<ul><li>将本对象的引用到的对象放入<code>灰色集合</code>中</li><li>将本对象放入<code>黑色集合</code>中</li></ul></li><li>重复步骤3，直到<code>灰色集合</code>为空结束</li><li>结束后，仍在<code>白色集合</code>的对象即为GC Roots不可达，可以进行回收。</li></ol></li></ol></li><li><p>三代标记清除法</p></li></ol><h5 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a><strong>Lua</strong></h5><ol><li><p>pairs和ipairs</p><ul><li><p>同：都能遍历集合，均按优先顺序输出没有key的值</p></li><li><p>异：对于又key的值</p><p><strong>ipairs</strong>从第一个数字key开始，依次输出所有的key+1的键值，遇到字母下标不会结束遍历，但不输出，如果遇到nil则退出；<br><strong>pairs</strong>无序输出字母类型key或者数字类型key的键值，遇到nil不输出，也不会停止遍历。</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span> = &#123; [<span class="number">1</span>] = <span class="string">&quot;test3&quot;</span>, [<span class="number">2</span>] = <span class="string">&quot;val1&quot;</span> , [<span class="number">5</span>] = <span class="string">&quot;val2&quot;</span>, [<span class="number">4</span>] = <span class="string">&quot;val4&quot;</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------ipairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------pairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--输出</span></span><br><span class="line"><span class="comment">-----------ipairs----------------</span></span><br><span class="line"><span class="number">1</span>       test3</span><br><span class="line"><span class="number">2</span>       val1</span><br><span class="line"><span class="comment">-----------pairs----------------</span></span><br><span class="line"><span class="number">4</span>       val4</span><br><span class="line"><span class="number">1</span>       test3</span><br><span class="line"><span class="number">2</span>       val1</span><br><span class="line"><span class="number">5</span>       val2</span><br><span class="line"><span class="comment">--结论</span></span><br><span class="line"><span class="number">1</span>、<span class="built_in">ipairs</span>会按照key的顺序输出数据，遇到不连续的数据停止输出；</span><br><span class="line"><span class="number">2</span>、<span class="built_in">pairs</span>会无序输出所有数据；</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span> = &#123; [<span class="number">3</span>] = <span class="string">&quot;test3&quot;</span>, [<span class="string">&quot;test&quot;</span>] = <span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val3&quot;</span> , [<span class="number">4</span>] = <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val4&quot;</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------ipairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------pairs----------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--输出</span></span><br><span class="line"><span class="comment">-----------ipairs----------------</span></span><br><span class="line"><span class="number">1</span>val3</span><br><span class="line"><span class="number">2</span>val4</span><br><span class="line"><span class="number">3</span>test3</span><br><span class="line"><span class="number">4</span>val2</span><br><span class="line"><span class="comment">-----------pairs----------------</span></span><br><span class="line"><span class="number">1</span>val3</span><br><span class="line"><span class="number">2</span>val4</span><br><span class="line"><span class="number">4</span>val2</span><br><span class="line">testval1</span><br><span class="line"><span class="number">3</span>test3</span><br><span class="line"></span><br><span class="line"><span class="comment">--结论</span></span><br><span class="line"><span class="number">1</span>、<span class="built_in">pairs</span>和<span class="built_in">ipairs</span>均优先输出没有key的value；</span><br><span class="line"><span class="number">2</span>、<span class="built_in">pairs</span>会输出所有的数据，不带key的值按顺序输出，带key的值无序输出；</span><br><span class="line"><span class="number">3</span>、<span class="built_in">ipairs</span>会跳过字符串的key，按顺序输出数字型key的值；</span><br></pre></td></tr></table></figure></li><li><p>__index和__newindex</p><ul><li><p>__index：(get)当在表中找不到元素时，lua会从 __index指向的表查找元素或获得方法的返回值。</p></li><li><p>__newindex：(set)对表中不存在的值进行赋值时调用。</p><p>当__newindex指向一个函数时，会执行该函数，且对本表的创建不成功；</p><p>当__newindex指向一个表时，会对指向的表进行操作，且对本表创建不成功。</p></li></ul></li><li><p>__rawset和 __rawget</p><p>可以通过rawset和rawget操作绕过原表这一过程(__index和__newindex)，直接把这个表相应的结论输出。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> table1 = &#123; x = <span class="string">&quot;val1&quot;</span> &#125;</span><br><span class="line"><span class="keyword">local</span> table2 = &#123; y = <span class="string">&quot;val2&quot;</span> &#125;</span><br><span class="line"><span class="keyword">local</span> table3 = &#123; z = <span class="string">&quot;val3&quot;</span> &#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(table1, &#123;<span class="built_in">__index</span> = table2, <span class="built_in">__newindex</span> = table3&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(table1.y)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(table1, <span class="string">&quot;y&quot;</span>))  </span><br><span class="line"></span><br><span class="line">table1.newN = <span class="string">&quot;newN&quot;</span></span><br><span class="line"><span class="built_in">print</span>(table1.newN)</span><br><span class="line"><span class="built_in">print</span>(table3.newN)</span><br><span class="line"></span><br><span class="line"><span class="built_in">rawset</span>(table1, <span class="string">&quot;newN&quot;</span>, <span class="string">&quot;newZ&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(table1.newN)</span><br><span class="line"></span><br><span class="line"><span class="comment">--输出--</span></span><br><span class="line">val2</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">newN</span><br><span class="line">newZ</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li>a</li></ol><h5 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h5><p>​    网络同步的目标时保证多台机器的游戏表现完全一致</p><ol><li><p>帧同步</p><ol><li>原理：<ul><li>帧同步的战斗逻辑在客户端；</li><li>在帧同步下，服务端只转发操作，不做任何逻辑处理；</li><li>客户端按照一定的帧速率（逻辑帧）去上传当前的操作指令，服务端将操作指令广播给所有客户端；</li><li>当客户端收到指令后执行本地代码，如果输入的指令一致，计算的过程一致，那么计算的结果肯定是一致的，这样就能保证所有客户端的同步，这就是帧同步。</li></ul></li><li>缺点：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     <ul><li>由于帧同步战斗逻辑都在客户端，服务器没有验证，外挂成本低（加速、透视、自动瞄准、数据修改等）；</li><li>网络条件较差的客户端会影响其他玩家的游戏体验。（优化方案：乐观帧锁定、渲染与逻辑帧分离、客户端预执行、指令流水线化、操作回滚等）；</li><li>不同机器浮点数精度问题、容器排序不确定性、RPC时序、随机数值计算不统一。</li></ul></li><li>乐观帧锁定：</li></ol></li><li><p>状态同步</p><ol><li><p>原理：</p><ul><li><p>状态同步的战斗逻辑在服务端；</p></li><li><p>在状态同步下，客户端更像是一个服务端数据的表现层；</p></li><li><p>一般流程：</p></li><li><ul><li>客户端上传操作到服务器；</li><li>服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态；</li><li>客户端收到状态后再根据状态显示内容。</li></ul></li></ul></li><li><p>缺点：</p><ul><li>状态同步的回放实现较为复杂；</li><li>延迟过大、客户端性能浪费、服务端压力大；</li><li>对带宽的浪费。对于对象少的游戏，可以用快照保存整个游戏的状态发送，但一旦数量多起来，数量的占用就会直线上升。（优化：增量快照同步，协议同步指定数据）</li></ul></li></ol></li><li><p>区别</p><table border="1">    <tr>        <th>属性</th>        <th>状态同步</th>        <th>帧同步</th>    </tr>    <tr>        <td>流量</td>        <td>相对高</td>        <td>相对低</td>    </tr>    <tr>        <td>回放</td>        <td>记录文件大，且实现相对复杂</td>        <td>记录文件小，且相对容易实现</td>    </tr>        <tr>        <td>安全性</td>        <td>服务器实现逻辑，安全性高</td>        <td>逻辑在客户端，防作弊难度高</td>    </tr>    <tr>        <td>服务器压力</td>        <td>逻辑在服务端，压力大</td>        <td>小</td>    </tr>    <tr>        <td>战斗校验</td>        <td></td>        <td>服务端可以重跑一遍战斗</td>    </tr>    <tr>        <td>网络卡顿表现</td>        <td>瞬移，回位</td>        <td>卡顿</td>    </tr></table></li><li><p>表现优化</p><p>表现优化用于弱化玩家对延迟的感受。</p><ol><li>插值优化：客户端采用插值，避免位置突变</li><li>客户端预测+回滚</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h5 id=&quot;Shader&quot;&gt;&lt;a href=&quot;#Shader&quot; class=&quot;headerlink&quot; title=&quot;Shader&quot;&gt;&lt;/a&gt;Shader&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;从Render获取材质，获</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>热更新（XLua框架）</title>
    <link href="http://kennyyyyyy.github.io/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://kennyyyyyy.github.io/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2022-08-16T01:41:04.000Z</published>
    <updated>2023-02-09T10:42:11.880Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><hr><h4 id="资源目录划分"><a href="#资源目录划分" class="headerlink" title="资源目录划分"></a>资源目录划分</h4><p><img src="/images/热更新/资源目录划分.png" alt="image-20221105153329320"></p><h4 id="框架内容"><a href="#框架内容" class="headerlink" title="框架内容"></a>框架内容</h4><ul><li><p>Lua</p></li><li><p>UI</p></li><li><p>实体（模型，特效）</p></li><li><p>场景</p></li><li><p>声音</p></li><li><p>网络</p></li><li><p>事件</p></li><li><p>对象池</p></li></ul><h4 id="框架开发流程"><a href="#框架开发流程" class="headerlink" title="框架开发流程"></a>框架开发流程</h4><h5 id="第一阶段：Bundle处理"><a href="#第一阶段：Bundle处理" class="headerlink" title="第一阶段：Bundle处理"></a>第一阶段：Bundle处理</h5><ul><li><p>构建</p><ul><li><p>查找BuildResources下的资源文件</p></li><li><p>使用Unity提供的BuildPipeline进行构建</p></li><li><p>meta文件不需要打入bundle包</p></li><li><p>Bundle Build策略</p><ul><li>按文件夹打包 ：每一个最小文件夹打包<ul><li>bundle数量少，小包模式：首次下载块</li><li>后期更新补丁大</li></ul></li><li>按文件打包：每一个文件一个包<ul><li>更新补丁很小</li><li>小包模式下：首次下载较慢 </li></ul></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buildTarget:构建目标平台</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Build</span>(<span class="params">BuildTarget buildTarget</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;AssetBundleBuild&gt; assetBundleBuilds = <span class="keyword">new</span> List&lt;AssetBundleBuild&gt;();    </span><br><span class="line"><span class="comment">//查找目标文件夹下的所有文件</span></span><br><span class="line">    <span class="built_in">string</span>[] files = Directory.GetFiles(PathUtil.BuildResourcesPath, <span class="string">&quot;*&quot;</span>, SearchOption.AllDirectories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> file <span class="keyword">in</span> files)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//排除meta文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.EndsWith(<span class="string">&quot;meta&quot;</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        AssetBundleBuild assetBundle = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> path = PathUtil.GetStandardPath(file);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> assetName = PathUtil.GetUnityPath(path);</span><br><span class="line">        <span class="built_in">string</span> bundleName = path.Replace(PathUtil.BuildResourcesPath, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//设置资源名字和包的名字，包的名字路径需要为相对路径</span></span><br><span class="line">        assetBundle.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; assetName &#125;;</span><br><span class="line">        assetBundle.assetBundleName = bundleName + <span class="string">&quot;.ab&quot;</span>;</span><br><span class="line"></span><br><span class="line">        assetBundleBuilds.Add(assetBundle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Directory.Exists(PathUtil.BuildOutPath))</span><br><span class="line">        Directory.Delete(PathUtil.BuildOutPath, <span class="literal">true</span>);</span><br><span class="line">    Directory.CreateDirectory(PathUtil.BuildOutPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Buildpeline导出bundle包</span></span><br><span class="line">    BuildPipeline.BuildAssetBundles(PathUtil.BuildOutPath, assetBundleBuilds.ToArray(), BuildAssetBundleOptions.None, buildTarget);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>加载</p><ul><li><p>加载对应的包，然后实例化</p><ul><li><p>代码为从文件中异步加载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载一个预制体需要加载其依赖资源</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//加载预制体ab包</span></span><br><span class="line">    AssetBundleCreateRequest assetBundleCreateRequest = AssetBundle.LoadFromFileAsync(PathUtil.BuildOutPath + <span class="string">&quot;/prefab/testbutton.prefab.ab&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> assetBundleCreateRequest;</span><br><span class="line">    <span class="comment">//加载素材ab包</span></span><br><span class="line">    AssetBundleCreateRequest assetBundleCreateRequest1 = AssetBundle.LoadFromFileAsync(PathUtil.BuildOutPath + <span class="string">&quot;/ui/background.png.ab&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> assetBundleCreateRequest1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加载对应预制体</span></span><br><span class="line">    AssetBundleRequest assetBundleRequest = assetBundleCreateRequest.assetBundle.LoadAssetAsync(PathUtil.GetUnityPath(PathUtil.BuildResourcesPath + <span class="string">&quot;Prefab/TestButton.prefab&quot;</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> assetBundleRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line">    GameObject go = Instantiate(assetBundleRequest.asset) <span class="keyword">as</span> GameObject;</span><br><span class="line">    go.transform.SetParent(transform);</span><br><span class="line">    go.SetActive(<span class="literal">true</span>);</span><br><span class="line">    go.transform.localPosition = Vector3.zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实际过程中不可能查看预制体来知晓依赖文件，因此需要用一个文件来对依赖文件信息进行存储。即版本文件，文件信息为：文件路径名|bundle名|依赖文件列表。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取文件的依赖文件列表</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;curFile&quot;&gt;</span>当前文件<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GetDependence</span>(<span class="params"><span class="built_in">string</span> curFile</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; dependence = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="built_in">string</span>[] files = AssetDatabase.GetDependencies(curFile);</span><br><span class="line">    dependence = files.Where(file =&gt; !file.EndsWith(<span class="string">&quot;.cs&quot;</span>) &amp;&amp; !file.Equals(curFile)).ToList();</span><br><span class="line">    <span class="keyword">return</span> dependence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在打包时对依赖文件路径进行记录</span></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; bundleInfos = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; dependenceInfo = GetDependence(assetName);</span><br><span class="line"><span class="built_in">string</span> bundleInfo = assetName + <span class="string">&quot;|&quot;</span> + bundleName + <span class="string">&quot;.ab&quot;</span>; </span><br><span class="line"><span class="keyword">if</span>(dependenceInfo.Count &gt; <span class="number">0</span>)</span><br><span class="line">    bundleInfo = bundleInfo + <span class="string">&quot;|&quot;</span> + <span class="built_in">string</span>.Join(<span class="string">&quot;|&quot;</span>, dependenceInfo);</span><br><span class="line">bundleInfos.Add(bundleInfo);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>解析版本文件，加载依赖，加载自身，加载资源</p><p><img src="/images/热更新/image-20221106183101232.png" alt="资源加载流程"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 异步加载资源</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 读取字典中存储的依赖资源路径</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 递归加载所有依赖资源，当所有以来资源加载完之后加载自身</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> TODO：需要解决重复加载bundle包的问题，且对于场景，不需要对资源惊醒加载</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 最后回调</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assetName&quot;&gt;</span>资源名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;action&quot;&gt;</span>完成加载后的回调<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadBundleAsync</span>(<span class="params"><span class="built_in">string</span> assetName, Action&lt;Object&gt; action = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> bundleName = BundleInfosDic[assetName].BundleName;</span><br><span class="line">    <span class="built_in">string</span> bundlePath = Path.Combine(PathUtil.BundleResourcePath, bundleName);</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; dependences = BundleInfosDic[assetName].Dependences;</span><br><span class="line">    <span class="keyword">if</span>(dependences != <span class="literal">null</span> &amp;&amp; dependences.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dependences.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">LoadBundleAsync</span>(<span class="params">dependences[i]</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AssetBundleCreateRequest assetBundleCreateRequest = AssetBundle.LoadFromFileAsync(bundlePath);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> assetBundleCreateRequest;</span><br><span class="line"></span><br><span class="line">    AssetBundleRequest assetBundleRequest = assetBundleCreateRequest.assetBundle.LoadAssetAsync(assetName);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> assetBundleRequest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问号判断前面的变量是否为空</span></span><br><span class="line">    action?.Invoke(assetBundleRequest?.asset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开放接口，方便用户调用</p><p><img src="/images/热更新/image-20221106235358622.png" alt="PathUtil路径接口"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> AssetType</span><br><span class="line">&#123;</span><br><span class="line">    Lua,</span><br><span class="line">    Music,</span><br><span class="line">    Sound,</span><br><span class="line">    Effect,</span><br><span class="line">    UI,</span><br><span class="line">    Sprite,</span><br><span class="line">    Scene</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadAsset</span>(<span class="params">AssetType assetType, <span class="built_in">string</span> assetName, Action&lt;Object&gt; action</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (assetType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AssetType.Lua:</span><br><span class="line">            LoadAsset(PathUtil.GetLuaPath(assetName), action);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AssetType.Music:</span><br><span class="line">            LoadAsset(PathUtil.GetMusicPath(assetName), action);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AssetType.Sound:</span><br><span class="line">            LoadAsset(PathUtil.GetSoundPath(assetName), action);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AssetType.Effect:</span><br><span class="line">            LoadAsset(PathUtil.GetEffectPath(assetName), action);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AssetType.UI:</span><br><span class="line">            LoadAsset(PathUtil.GetUIPath(assetName), action);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AssetType.Sprite:</span><br><span class="line">            LoadAsset(PathUtil.GetSpritePath(assetName), action);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AssetType.Scene:</span><br><span class="line">            LoadAsset(PathUtil.GetScenePath(assetName), action);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>更新</p><ul><li><p>热更新方案</p><ul><li>整包 <ul><li>策略：完整更新资源放在包内</li><li>优点：首次更新少</li><li>缺点：安装包下载时间长，首次安装久</li></ul></li><li>分包<ul><li>策略：包内放少量或不妨更新资源</li><li>优点：安装包小，下载快，安装块</li><li>缺点：首次更新时间久</li></ul></li></ul></li><li><p>热更资源流程</p><ul><li><p>Application.streamingAssets：只读</p></li><li><p>Application.persisitentDataPath：可写    </p><p><img src="/images/热更新/image-20221107123701894.png" alt="热更资源流程"></p></li></ul></li></ul></li></ul><ul><li><p>热更新代码流程</p><ul><li><p>下载文件</p></li><li><p>写入文件</p></li><li><p>解析filelist</p><p><img src="/images/热更新/image-20221107124643590.png" alt="热更代码流程"> </p></li></ul></li><li><p>检测初次安装</p><ul><li>只读目录有热更资源</li><li>可读写目录没有热更资源</li><li>判断filelist文件是否存在</li><li>最后写入filelist</li></ul></li><li><p>检查更新</p><ul><li>下载资源服务器上的filelist文件</li><li>对比文件信息和本地是否一致</li></ul></li><li><p>文件路径</p><ul><li>只读目录：Application.streamingAssetsPath/ + path</li><li>可读写目录：Application.persistentDataPath/ + path</li><li>资源服务器地址：<a href="http://127.0.0.1/AssetBundles/">http://127.0.0.1/AssetBundles/</a> + path</li></ul></li></ul><h5 id="第二阶段：C-调用Lua"><a href="#第二阶段：C-调用Lua" class="headerlink" title="第二阶段：C#调用Lua"></a>第二阶段：C#调用Lua</h5><ul><li><p>Lua加载与管理</p><ul><li><p>Lua文件加载</p><ol><li><p>执行字符串：直接使用<strong>DoString</strong>执行一个字符串</p><p><code>luaenv.DoString(“print(‘hello world’)”)</code></p></li><li><p>加载Lua文件：使用lua的require函数，lua文件需要在Resource路径下，或者需要绝对路径</p><p><code>DoString(“require ‘byfile’”);</code></p></li><li><p>自定义Loader</p><p>涉及一个接口</p><p><code>public delegate byte[] CustomLoader(ref string filepath);</code></p><p><code>public void LuaEnv.AddLoader(CustomLoader loader);</code></p><p>filepath为文件路径，返回值是lua文件的内容</p></li></ol></li><li><p>Lua文件管理</p><ol><li>异步加载</li><li>同步使用</li><li>预加载</li></ol></li><li><p>C#访问LUA</p><p><code>luaenv.Global.Get&lt;int&gt;(&quot;a&quot;)</code></p><p><code>luaenv.Global.Get&lt;string&gt;(&quot;b&quot;)</code></p><p><code>luaenv.Global.Get&lt;bool&gt;(&quot;c&quot;)</code></p></li></ul></li><li><p>Lua绑定与执行</p><ul><li><p>绑定：XLua插件的案例2为例</p><p><img src="/images/热更新/image-20221108162213528.png" alt="C#绑定lua脚本流程"></p><p>绑定脚本和方法后，可以在C#中进行lua方法的调用</p><p>结束运行前需要取消绑定</p></li><li><p>执行</p><ul><li><p>Lua中调用C#代码</p><p>所有的类和命名空间都在CS命名空间下，方法通过 ‘ : ‘ 调用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manager = CS.FrameWork.Managers.Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    Manager.UIManager:OpenUI(<span class="string">&quot;TestButton&quot;</span>, <span class="string">&quot;UI/UITest&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h5 id="第三阶段：向Lua提供接口"><a href="#第三阶段：向Lua提供接口" class="headerlink" title="第三阶段：向Lua提供接口"></a>第三阶段：向Lua提供接口</h5><h5 id="第四阶段：完善和优化"><a href="#第四阶段：完善和优化" class="headerlink" title="第四阶段：完善和优化"></a>第四阶段：完善和优化</h5><h5 id="UI管理"><a href="#UI管理" class="headerlink" title="UI管理"></a>UI管理</h5><ul><li><p>界面类型</p><ul><li><p>一极界面</p></li><li><p>二级弹窗</p></li><li><p>三级弹窗</p></li><li><p>特殊界面</p></li></ul></li><li><p>UGUI层级特点</p><ul><li>根据节点顺序渲染</li></ul></li></ul><p>为了解决UI的层级显示问题，根据Unity中的ui渲染顺序，可以设置多个父节点来对所有的UI进行一个分类的管理。每一个层级对应一个父节点。</p><p><img src="/images/热更新/image-20221111130852713.png" alt="UI层级示例"></p><ul><li><p>UI的层级设置应该放在lua热更中，方便之后对ui层级的添加和修改</p><ul><li><p>UIManger中提供设置层级的方法供lua调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetUIGroup</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; groupNames</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> groupName <span class="keyword">in</span> groupNames)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//实例化所有节点</span></span><br><span class="line">        <span class="comment">//Unity中先实例化的在上，即先渲染，因此在lua中的顺序就决定了其在unity中层级渲染顺序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--调用c#中的方法</span></span><br><span class="line">Manager.UIManager:SetUIGroup(group);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="实体管理"><a href="#实体管理" class="headerlink" title="实体管理"></a>实体管理</h5><ul><li>管理方法与UI一致</li></ul><h5 id="场景管理"><a href="#场景管理" class="headerlink" title="场景管理"></a>场景管理</h5><ul><li><p>场景加载</p><p>通过协程调用SceneManager的的异步场景加载方法<code>LoadSceneAsync(name, mode);</code></p><p>场景不能直接添加脚本，所以在场景中添加一个物体，用于添加场景的管理脚本，并调用其相关方法。</p><p>为了方便，提供一个方法用于获取场景中的管理对象上的管理脚本，即查找场景中的所有物体，然后获得名字为管理对象的脚本</p><ul><li><p>场景叠加</p><ul><li>即<code>LoadSceneMode.Additive</code>模式加载场景，即打开一个新的场景至当前场景</li></ul></li><li><p>场景切换</p><ul><li>即<code>LoadSceneMode.Additive</code>模式加载场景，即关闭当前所有场景，打开新的场景 </li></ul></li><li><p>场景激活</p><ul><li><p>即<code>SetActiveScene(name)</code></p></li><li><p>场景的setActive和InActive会有相关方法调用，因此需要添加场景激活的函数回调</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//activeSceneChanged为unity提供的事件，用于场景激活后的函数回调</span></span><br><span class="line"><span class="comment">//此函数提供两个参数分别表示激活前和激活后的场景</span></span><br><span class="line">SceneManager.activeSceneChanged += OnActiveSceneChanged;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnActiveSceneChanged</span>(<span class="params">Scene s1, Scene s2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s1.isLoaded || !s2.isLoaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SceneLogic sl1 = GetSceneLogic(s1);</span><br><span class="line">    SceneLogic sl2 = GetSceneLogic(s2); </span><br><span class="line">    sl1?.OnInActive();</span><br><span class="line">    sl2?.OnActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>场景卸载</p><p>和加载类似，通过协程调用异步卸载场景的方法。、</p></li></ul><h5 id="声音管理"><a href="#声音管理" class="headerlink" title="声音管理"></a>声音管理</h5><ul><li><p>背景音乐</p><ul><li><p>播放</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 播放音乐，需要判断需要播放的是否是当前正在播放的</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 防止重复加载</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayMusic</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MusicVolume &lt; <span class="number">0.1f</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">string</span> oldName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (musicAudio != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        oldName = musicAudio.clip.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldName == name)</span><br><span class="line">    &#123;</span><br><span class="line">        musicAudio.Play();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Manager.ResourceManager.LoadAsset(ResourceManager.AssetType.Music, name, (UnityEngine.Object obj) =&gt;</span><br><span class="line">                                      &#123;</span><br><span class="line">                                          musicAudio.clip = obj <span class="keyword">as</span> AudioClip;</span><br><span class="line">                                          musicAudio.Play();</span><br><span class="line">                                      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除播放外，其余只需要调用相关方法即可</p></li><li><p>暂停</p></li><li><p>恢复</p></li><li><p>停止</p></li><li><p>音量</p></li></ul></li><li><p>音效</p><ul><li>音量</li><li>播放</li></ul></li></ul><h5 id="事件管理"><a href="#事件管理" class="headerlink" title="事件管理"></a>事件管理</h5><p>时间管理可以对所有的事件进行一个统一的管理</p><ul><li>订阅</li><li>取消订阅</li><li>执行调用</li></ul><h5 id="对象池设计"><a href="#对象池设计" class="headerlink" title="对象池设计"></a>对象池设计</h5><p>对象类型</p><ul><li>AssetBundle</li><li>GameObject</li></ul><p>特点</p><p>使用自定义类，该类有上次使用时间，使用的对象和销毁的时间间隔 PoolObject</p><ul><li><p>对象池中存放多种类型</p><p>用一个List\<PoolObject>对所有对象进行存储</PoolObject></p></li><li><p>短时间内重复使用</p><p>在销毁的间隔时间内能以一直使用</p></li><li><p>过期自动销毁</p><p>当过了销毁时间间隔还未被使用，则将对象进行销毁</p></li></ul><p>设计原理：池内不创建对象，对象在外部创建，使用完放入对象池，</p><p>使用时再取出。即不预先创建对象，当需要时向对象池中取，池中没有则创建</p><ol><li><p>由于存在两种对象，且加载和释放的方式有不同，所以定义一个基类PoolBase和两个类继承基类</p></li><li><p>生成</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从对象池中获得物体</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> Object <span class="title">Spwan</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> go <span class="keyword">in</span> poolObjects)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(go.name == name)</span><br><span class="line">        &#123;</span><br><span class="line">            poolObjects.Remove(go);</span><br><span class="line">            <span class="keyword">return</span> go.@object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回收</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">UnSpwan</span>(<span class="params"><span class="built_in">string</span> name, Object obj</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PoolObject poolObject = <span class="keyword">new</span> PoolObject(name, obj);</span><br><span class="line">    poolObjects.Add(poolObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>对于AssetBundle，在游戏中可能存在多个物体对其的引用，只有当没有物体的引用时，才能将其放回对象池中。因此，可以定义一个数据结构对bundle的引用进行计数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BundleData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> AssetBundle Bundle;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BundleData</span>(<span class="params">AssetBundle ab</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Bundle = ab;</span><br><span class="line">        Count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h5><p>通信协议：用于服务端和客户端通信的数据格式</p><ul><li>protobuf、sproto、pbc、json等</li><li>xlua使用通信协议需要添加第三方库，此项目中直接使用的是<a href="https://github.com/chexiongsheng/build_xlua_with_libs">github</a>上的编译好的库</li></ul><p>客户端C#</p><ul><li><p>NetClient：客户端的网络消息处理类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line"><span class="comment">//主要协议相关</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> BufferSize = <span class="number">1024</span> * <span class="number">64</span>;</span><br><span class="line"><span class="comment">//基于TCP协议的客户端协议</span></span><br><span class="line"><span class="keyword">private</span> TcpClient client;</span><br><span class="line"><span class="comment">//网络数据流，用于发送和接收数据</span></span><br><span class="line"><span class="keyword">private</span> NetworkStream tcpStream;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[BufferSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析接收的数据</span></span><br><span class="line"><span class="keyword">private</span> MemoryStream memStream;</span><br><span class="line"><span class="keyword">private</span> BinaryReader binaryReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始连接</span></span><br><span class="line">client.BeginConnect(host, port, OnConnect, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">tcpStream.BeginRead(buffer, <span class="number">0</span>, BufferSize, OnRead, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取对应长度的字节数</span></span><br><span class="line"><span class="built_in">byte</span>[] data = binaryReader.ReadBytes(msgLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">tcpStream.BeginWrite(sendData, <span class="number">0</span>, sendData.Length, OnEndSend, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>NetManager：提供消息处理的中转接口，调用lua</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息队列，接收到消息就放入消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Queue</span>&lt;<span class="title">KeyValuePair</span>&lt;<span class="title">int</span>, <span class="title">string</span>&gt;&gt; messageQueue</span> = <span class="keyword">new</span> Queue&lt;KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"><span class="comment">//lua的function</span></span><br><span class="line"><span class="keyword">private</span> XLua.LuaFunction ReceiveMessage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">int</span> msgID, <span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConnectedServer</span>(<span class="params"><span class="built_in">string</span> host, <span class="built_in">int</span> port</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnNetConneted</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDisConnected</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive</span>(<span class="params"><span class="built_in">int</span> msgID, <span class="built_in">string</span> message</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>客户端Lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 提供一个基础类定义</span></span><br><span class="line"><span class="comment">--super 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span><span class="params">(super)</span></span></span><br><span class="line">    <span class="keyword">local</span> class = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">-- 存在父类则设置原表</span></span><br><span class="line">    <span class="keyword">if</span> super <span class="keyword">then</span></span><br><span class="line">        class = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;<span class="built_in">__index</span> = super&#125;);</span><br><span class="line">        class.super = super;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">--不存在则新建一个表，并有一个构造函数</span></span><br><span class="line">        class = &#123;ctor = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    class.<span class="built_in">__index</span> = class</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 为子类提供一个new方法，用于调用构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">class.new</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> instance = <span class="built_in">setmetatable</span>(&#123;&#125;, class);</span><br><span class="line">        <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span><span class="params">(inst, ...)</span></span></span><br><span class="line">            <span class="comment">-- 存在父类则递归创建构造函数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(inst.super) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">create</span>(inst.super, ...);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(inst.ctor) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">                inst.ctor(instance, ...);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">create</span>(instance, ...);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> class;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>基于Class存在一个baseMessage类，存在消息注册的方法。在该模块中会存在对消息请求和接收的处理。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--消息注册</span></span><br><span class="line"><span class="comment">-- msgName 消息名称 </span></span><br><span class="line"><span class="comment">-- msgID 消息ID</span></span><br><span class="line"><span class="comment">-- ... 参数列表的Key</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseMessage:addReqRes</span><span class="params">(msgName, msgID, ...)</span></span></span><br><span class="line">    <span class="keyword">local</span> keys = &#123;...&#125;;</span><br><span class="line">    <span class="comment">-- 消息请求</span></span><br><span class="line">    <span class="built_in">self</span>[<span class="string">&quot;req_&quot;</span>..msgName] = <span class="function"><span class="keyword">function</span><span class="params">(self, ...)</span></span></span><br><span class="line">        <span class="keyword">local</span> values = &#123;...&#125;;</span><br><span class="line">        <span class="keyword">if</span> #keys ~= #values <span class="keyword">then</span></span><br><span class="line">            Log.Error(<span class="string">&quot;参数不正确: &quot;</span>, msgName);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> sendData = &#123;&#125;;</span><br><span class="line">        <span class="comment">-- 将key和value对应</span></span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>, #keys <span class="keyword">do</span></span><br><span class="line">            sendData[keys[i]] = values[i];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">--发送消息</span></span><br><span class="line">        msgManager.sendMsg(msgID, sendData);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">--消息接收，要先对消息接收进行注册</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">self</span>[<span class="string">&quot;res_&quot;</span>..msgName] == <span class="string">&quot;function&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        msgManager.register(msgID, </span><br><span class="line">        <span class="comment">-- 收到消息的回调</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span></span><br><span class="line">            <span class="keyword">local</span> msg = Json.decode(data);</span><br><span class="line">            <span class="keyword">if</span> msg.code ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                Log.Error(<span class="string">&quot;错误码：&quot;</span>, msg.code);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">self</span>[<span class="string">&quot;res_&quot;</span>..msgName](<span class="built_in">self</span>, msg);</span><br><span class="line">        <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Log.Error(<span class="string">&quot;请注册消息返回回调：&quot;</span>..msgName);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><p>功能模块化</p><ul><li>消息注册</li><li>消息发送</li><li>消息接收  </li></ul></li><li><p>模块管理器</p><p>模块管理器即消息管理，在此类中保存所有的模块列表和所有的回调列表。所有的模块的名字需要手动添加</p><ul><li><p>模块化初始化</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 遍历名字列表msgNameList，将所有的模块实例放入模块列表中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msgManager.init</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(msgNameList) <span class="keyword">do</span></span><br><span class="line">        <span class="comment">-- 获得Message目录下的所有相关的模块</span></span><br><span class="line">        msgModelList[v] = <span class="built_in">require</span>(<span class="string">&quot;Message.&quot;</span>..v).new();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>模块获取</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取模块实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msgManager.getMsg</span><span class="params">(key)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msgModelList[key] <span class="keyword">then</span></span><br><span class="line">        Log.Error(key .. <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> msgModelList[key];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>消息接收</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 接收消息，用于在C# NetManager 中进行调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMsg</span><span class="params">(msgID, msg)</span></span></span><br><span class="line">    Log.Info(<span class="string">&quot;reveived msg id = &quot;</span> .. msgID .. <span class="string">&quot; : &quot;</span> .. msg);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(msgResponses[msgID]) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        msgResponses[msgID](msg);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Log.Error(msgID .. <span class="string">&quot; 消息不存在回调&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>消息发送</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 消息发送，调用C# NetManager中方法进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msgManager.sendMsg</span><span class="params">(msgID, sendData)</span></span></span><br><span class="line">    <span class="keyword">local</span> str = Json.encode(sendData);</span><br><span class="line">    Log.Info(<span class="string">&quot;send msg id = &quot;</span> .. msgID .. <span class="string">&quot; : &quot;</span> .. str);</span><br><span class="line">    Manager.NetManager:SendMessage(msgID, str);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>简单服务器</p><h4 id="热更新框架"><a href="#热更新框架" class="headerlink" title="热更新框架"></a>热更新框架</h4><h5 id="为什么需要更新"><a href="#为什么需要更新" class="headerlink" title="为什么需要更新"></a>为什么需要更新</h5><ol><li>修复产品问题</li><li>游戏内容扩充/删减</li></ol><h5 id="热更新是什么"><a href="#热更新是什么" class="headerlink" title="热更新是什么"></a>热更新是什么</h5><ul><li><p>普通更新流程</p><p><img src="/images/热更新/image-20221119161708686.png" alt="普通更新流程"></p><p>需要商店审核，周期长，更新需要重新安装。</p></li><li><p>热更新流程 </p><p><img src="/images/热更新/image-20221119162621384.png" alt="热更新流程 "></p><p>不需要商店审核，提交便捷，在游戏内自动完成资源下载和更新</p></li><li><p>为什么选择LUA</p><p>Unity3D        资源热更</p><p>C# 编译型语言    脚本打包成动态链接库DLL    </p><p>Lua 解释型语言    脚本运行时翻译成机器语言，不需要编译。脚本和资源都可以动态替换 </p><p><img src="/images/热更新/image-20221119163531878.png" alt="流程"></p></li></ul><h6 id="Lua热更的几个点"><a href="#Lua热更的几个点" class="headerlink" title="Lua热更的几个点"></a>Lua热更的几个点</h6><ol><li>需要导入热更插件（XLua、ToLua、SLua等） 稳定易用，不用重复造轮子</li><li>综合考量，划分项目功能结构。 需要频繁更新的部分就采用热性新，即使用Lua脚本实现</li><li>编写框架或使用成熟的热更行框架，便于之后开发流程的进行</li></ol><h5 id="Xlua框架与项目框架"><a href="#Xlua框架与项目框架" class="headerlink" title="Xlua框架与项目框架"></a>Xlua框架与项目框架</h5><p>引入xLua插件， 制定整体架构，选择对应的技术方案</p><h6 id="lua框架—主程所考虑的"><a href="#lua框架—主程所考虑的" class="headerlink" title="lua框架—主程所考虑的"></a>lua框架—主程所考虑的</h6><ol><li>游戏类型：强联网、若联网</li><li>功能划分与Scene场景规划：背包，战斗等</li><li>特殊需求</li><li>制定模块系统：版本更新检测系统、登录等。C#仅调用lua的主要接口，lua脚本中的功能或操作均在lua中处理</li></ol><h6 id="中后期项目的热更重构建议"><a href="#中后期项目的热更重构建议" class="headerlink" title="中后期项目的热更重构建议"></a>中后期项目的热更重构建议</h6><ol><li>核心数据Lua存储</li><li>配置文件挪到Lua</li><li>网络交互使用Lua封装和调用</li><li>业务功能模块不在绑定C#</li><li>每个UI功能使用Lua处理</li><li>战斗等复合功能模块，增加辅助Lua处理</li><li>原框架核心功能部分改成Lua实现，部分打上LUACALLCSHARP标签</li><li>实现Lua模块间的通信。 </li></ol><h6 id="XLua框架"><a href="#XLua框架" class="headerlink" title="XLua框架"></a>XLua框架</h6><p><img src="/images/热更新/image-20221119183806517.png" alt="Xlua框架执行流程"></p><h5 id="框架基本功能"><a href="#框架基本功能" class="headerlink" title="框架基本功能"></a>框架基本功能</h5><h6 id="资源目录结构划分"><a href="#资源目录结构划分" class="headerlink" title="资源目录结构划分"></a>资源目录结构划分</h6><p>以资源类型划分一级目录</p><ul><li>Custom：用户自定义功能</li><li>Font：字体</li><li>Module：所有功能模块，每个功能对应Lua脚本</li><li>Prefab：预制体</li><li>Sound：音效等</li><li>Sprite：图片</li><li>Texture：纹理</li></ul><h6 id="功能模块的引用与操作"><a href="#功能模块的引用与操作" class="headerlink" title="功能模块的引用与操作"></a>功能模块的引用与操作</h6><ol><li><p>功能预制体资源</p><ul><li><p>按照功能将模块封装为预制体</p></li><li><p>存放于Module目录对应的目录下</p></li><li><p>Tag设置为uiComponent</p></li></ul></li><li><p>功能脚本资源</p><ul><li>功能名.lua （逻辑脚本）<ul><li>Create() 加载并创建功能模块预制体</li><li>Awake() 完成View脚本的初始化和逻辑脚本初始化</li><li>BottonClickHander() 按钮对应方法的调用</li></ul></li><li>功能名View.lua （试图脚本）<ul><li>Create() 指向模块路径和模块名</li><li>SetUICompenent() 绑定模块下的物体 按钮 图片 预制体</li><li>StartInit() 按钮功能监听</li></ul></li></ul></li></ol><h6 id="配置文件的使用"><a href="#配置文件的使用" class="headerlink" title="配置文件的使用"></a>配置文件的使用</h6><h6 id="图片与预制体资源的动态获取"><a href="#图片与预制体资源的动态获取" class="headerlink" title="图片与预制体资源的动态获取"></a>图片与预制体资源的动态获取</h6><h6 id="单机Demo热更新制作规划"><a href="#单机Demo热更新制作规划" class="headerlink" title="单机Demo热更新制作规划"></a>单机Demo热更新制作规划</h6><ol><li><p>ARPG游戏DEMO的需求分析</p></li><li><p>正式确定DEMO的功能模块</p><p><img src="/images/热更新/image-20221120171602129.png" alt="功能模块分析"></p></li><li><p>功能模块与技术支持</p><p>功能模块</p><p><img src="/images/热更新/image-20221120172833796.png" alt="功能模块需求"></p><p>技术支撑</p><p><img src="/images/热更新/image-20221120173635985.png" alt="1"></p></li></ol><ol><li>准备开发</li></ol><h5 id="战斗系统分析"><a href="#战斗系统分析" class="headerlink" title="战斗系统分析"></a>战斗系统分析</h5><ol><li><p>需求分析</p><p><img src="/images/热更新/image-20221217210406239.png" alt="image-20221217210406239"></p><ol><li>形式：回合制、即时战斗</li><li>如何开始：攻击怪物、靠近怪物</li><li>如何结束：打败敌人、退出地图</li></ol></li><li><p>配置表与数据结构</p><p>需要较为完整的配置表才能更好的进行代码逻辑的编写</p><p><img src="/images/热更新/image-20221217210547055.png" alt="image-20221217210547055"></p></li><li><p>模块支撑</p><ol><li><p>分析</p><p><img src="/images/热更新/image-20221217210712333.png" alt="image-20221217210712333"></p><ol><li>场景管理：进入战场，场景切换</li><li>怪物管理：怪物刷新、怪物相关任务</li><li>战斗计算：战斗过程处理</li><li>战斗结算：进行结算</li><li>战斗动画：管理动画</li><li>特效管理：管理特效</li></ol></li><li><p>普攻实现</p><ol><li>攻击距离</li><li>攻击判定</li><li>攻击力动态计算</li><li>数值与公式</li></ol></li><li><p>技能实现</p><ol><li>回复术：回复生命值/魔法值等（对Player属性的修改）</li><li>buff：存在时间，可以对多种属性进行增益或减益</li><li>火球术：伤害类技能，直接碰撞检测等 </li></ol></li></ol></li></ol><h5 id="网游功能模块分析"><a href="#网游功能模块分析" class="headerlink" title="网游功能模块分析"></a>网游功能模块分析</h5><ol><li><p>模块分析</p><p><img src="/images/热更新/image-20221218151849593.png" alt="image-20221218151849593"></p></li><li><p>框架技术</p><p><img src="/images/热更新/image-20221218152309588.png" alt="image-20221218152309588"></p></li><li><p>网络请求</p><p><img src="/images/热更新/image-20221218155737845.png" alt="image-20221218155737845"></p></li></ol><h6 id="网络模块分析"><a href="#网络模块分析" class="headerlink" title="网络模块分析"></a>网络模块分析</h6><ol><li>Net模块工作原理</li><li>Net模块功能分析</li><li>Net模块使用操作</li></ol><ul><li>短链接<ul><li>缺点：连接操作频繁</li><li>优点：服务器管理成本低，对服务器压力小</li></ul></li><li>C#端与Http请求回调<ul><li>IP地址问题</li><li>接收Lua回调方法</li><li>使用Post请求</li><li>响应后将回调方法加入C#CallLua列表</li></ul></li></ul><h6 id="一次业务请求逻辑流程"><a href="#一次业务请求逻辑流程" class="headerlink" title="一次业务请求逻辑流程"></a>一次业务请求逻辑流程</h6><ol><li><p>方式一</p><p><img src="/images/热更新/image-20221220142727994.png" alt="image-20221220142727994"></p></li><li><p>方式二：主数据的 更新交给框架处理，不需要再业务逻辑开发的过程中处理</p><p><img src="/images/热更新/image-20221220143029015.png" alt="image-20221220143029015"></p></li></ol><h6 id="背包模块分析"><a href="#背包模块分析" class="headerlink" title="背包模块分析"></a>背包模块分析</h6><p>​    <img src="/images/热更新/image-20221220185056104.png" alt="image-20221220185056104"></p><ol><li>需求分析 <ol><li>滑动列表多物体处理：只显示框内的物体，对在列表外的物体进行隐藏</li></ol></li><li>数据流</li><li>数据结构</li><li>配置文件</li></ol><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p><img src="/images/热更新/image-20221220210827243.png" alt="image-20221220210827243"></p><h5 id="框架概念"><a href="#框架概念" class="headerlink" title="框架概念"></a>框架概念</h5><h6 id="框架目标"><a href="#框架目标" class="headerlink" title="框架目标"></a>框架目标</h6><p><img src="/images/热更新/image-20221221164620711.png" alt="image-20221221164620711"></p><ol><li><p>可靠性</p><ul><li>bug为什么多</li><li>公共功能架构解决</li></ul></li><li><p>安全性</p><ul><li>核心是数据安全</li><li>加密</li><li>身份验证</li><li>只相信服务器的运算 </li></ul></li><li><p>可扩展和和维护</p><p>功能和功能之间需要进行合理的划分，之间不能直接进行调用，要方便后续的功能开发</p><ul><li>功能不断增加</li><li>功能需要维护</li><li>功能划分</li><li>松耦合</li></ul></li><li><p>可定制和可伸缩</p><ul><li>可根据需求进行调整：不同项目侧重不同——框架扩充</li><li>可根据新技术对现有框架进行扩展</li><li>不同项目自定义模块方法</li><li>lua插件本体也可以更换</li></ul></li><li><p>客户体验</p><p>方便开发</p><ul><li>开发模板</li><li>开发工具 ：配置文件等</li></ul></li></ol><h6 id="为什么需要热更框架"><a href="#为什么需要热更框架" class="headerlink" title="为什么需要热更框架"></a>为什么需要热更框架</h6><ol><li><p>被动因素</p><ul><li>XLua：和Tween/easyTouch等插件不一样，使用的是lua语言进行项目开发，从根本上改变了原有框架</li></ul></li><li><p><img src="/images/热更新/image-20221221230049180.png" alt="image-20221221230049180"></p></li></ol><h6 id="热更框架目标"><a href="#热更框架目标" class="headerlink" title="热更框架目标"></a>热更框架目标</h6><ol><li>引擎部分</li></ol><p>   <img src="/images/热更新/image-20221221230854494.png" alt="image-20221221230854494"></p><ul><li>内部采用打包时间作为版本号</li></ul><ol><li><p>C#部分</p><p><img src="/images/热更新/image-20221221232227664.png" alt="image-20221221232227664"></p></li><li><p>Lua部分：使代码功能模式化  </p><p><img src="/images/热更新/image-20221221233018384.png" alt="image-20221221233018384"></p></li></ol><h5 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h5><h6 id="框架项目目录结构"><a href="#框架项目目录结构" class="headerlink" title="框架项目目录结构"></a>框架项目目录结构</h6><ol><li><img src="/images/热更新/image-20221222162432848.png" alt="image-20221222162432848"><ul><li>Ant：自定义组件C#脚本</li><li>AssetBundlesLocal：热更新资源目录</li><li>Editor：编辑器开发目录</li><li>EditorPrefab：自定义组件预制体</li><li>Lua：lua脚本存放目录</li><li>Plugins：插件目录</li><li>Resources：内部资源目录</li><li>Xlua：xlua插件目录</li></ul></li></ol><h6 id="重点功能模块"><a href="#重点功能模块" class="headerlink" title="重点功能模块"></a>重点功能模块</h6><p><img src="/images/热更新/image-20221222190624759.png" alt="image-20221222190624759"></p><h6 id="功能模块调用关系"><a href="#功能模块调用关系" class="headerlink" title="功能模块调用关系"></a>功能模块调用关系</h6><p><img src="/images/热更新/image-20221222190725350.png" alt="image-20221222190725350"></p><ul><li><p>重点功能模块</p><ul><li><p>UIGameLoading</p><p><img src="/images/热更新/image-20221222191306345.png" alt="image-20221222191306345"></p></li><li><p>AppBoot</p><p><img src="/images/热更新/image-20221222191735997.png" alt="image-20221222191735997"></p></li><li><p>LuaTools</p><p><img src="/images/热更新/image-20221222192558778.png" alt="image-20221222192558778"></p></li><li><p>LuaBehaviour</p><p><img src="/images/热更新/image-20221222193754710.png" alt="image-20221222193754710"></p></li><li><p>ResourceManager</p><p><img src="/images/热更新/image-20221222194608256.png" alt="image-20221222194608256"></p></li><li><p>SystemTool</p><p><img src="/images/热更新/image-20221222195018653.png" alt="image-20221222195018653"></p></li></ul></li><li><p>重点脚本</p><ul><li><p>ui.lua</p><p><img src="/images/热更新/image-20221222195137140.png" alt="image-20221222195137140"></p></li><li><p>main.lua</p><p><img src="/images/热更新/image-20221222195215642.png" alt="image-20221222195215642"></p></li><li><p>网络模块</p><p><img src="/images/热更新/image-20221222195944179.png" alt="image-20221222195944179"></p></li><li><p>list.lua</p><p><img src="/images/热更新/image-20221222200020222.png" alt="image-20221222200020222"></p></li><li><p>GameMainData</p><p><img src="/images/热更新/image-20221222200037417.png" alt="image-20221222200037417"></p></li><li><p>event.lua</p><p>事件系统，可以订阅和调用</p><p><img src="/images/热更新/image-20221222200306912.png" alt="image-20221222200306912"></p></li><li><p>plugin.lua</p><p>插件资源管理，方便管理</p><p><img src="/images/热更新/image-20221222200444582.png" alt="image-20221222200444582"></p></li><li><p>public.lua</p><p>公共资源管理，存放公共方法</p><p><img src="/images/热更新/image-20221222200455483.png" alt="image-20221222200455483"></p></li><li><p>tools.lua</p><p><img src="/images/热更新/image-20221222200902127.png" alt="image-20221222200902127"></p></li></ul></li></ul><h5 id="框架功能设计"><a href="#框架功能设计" class="headerlink" title="框架功能设计"></a>框架功能设计</h5><ol><li><p>业务功能管理 </p><ul><li><p>ui.lua</p><p><img src="/images/热更新/image-20230106085705394.png" alt="image-20230106085705394"></p></li><li><p>UIGameLoading</p><p><img src="/images/热更新/image-20230106145150649.png" alt="image-20230106145150649"></p></li></ul></li><li><p>网络请求管理 </p><ul><li><p>net.lua</p><p><img src="/images/热更新/image-20230106101826176.png" alt="image-20230106101826176"></p></li><li></li></ul></li></ol><h5 id="资源打包策略"><a href="#资源打包策略" class="headerlink" title="资源打包策略"></a>资源打包策略</h5><ol><li><p>资源打包前提</p><p><img src="/images/热更新/image-20230204220246369.png" alt="image-20230204220246369"></p></li><li><p>资源打包流程</p><p><img src="/images/热更新/image-20230205142823955.png" alt="image-20230205142823955"></p></li><li><p>资源打包策略</p><p><img src="/images/热更新/image-20230205144440952.png" alt="image-20230205144440952"></p><p><img src="/images/热更新/image-20230205145249992.png" alt="image-20230205145249992"></p></li><li><p>相关类和函数</p><p>AssetImporter：</p><p><strong>属性</strong></p><ul><li>assetBundleName / assetBundleVariant：获取或设置AssetBundle Name / Property；</li></ul><p><strong>静态方法</strong></p><ul><li>GetAtPath()：通过静态方法GetAtPath获取指定路径（相对路径）下的资源的导入器</li></ul></li></ol><h5 id="资源管理策略"><a href="#资源管理策略" class="headerlink" title="资源管理策略"></a>资源管理策略</h5><ol><li><p>ab包加载</p><ol><li><p>编辑器开发</p><p>使用unity资源数据库类管理</p><p><code>AssetDatabase.LoadAssetAtPath&lt;AudioClip&gt;(&quot;Assets/AssetBundlesLocal/&quot; + path + &quot;/&quot; + name + &quot;.wav&quot;)</code></p></li><li><p>真机环境(PC、安卓)</p><ul><li>判断内存中是否加载需要的资源</li><li>若不存在相应资源，则判断是否存在对应的ab包</li><li>若存在，则从ab包中读取对应的资源</li><li>若不存在，则先load这个ab包，放入对应容器，然后加载资源</li></ul></li><li><p>优点</p><ol><li>可以避免重复加载同一个ab包</li><li>每一个资源都不会重复加载</li><li>通过ab包名和资源名就可以获取相应的资源。ab包名对应路径</li></ol></li><li><p>ab包加载路径</p><ol><li><p>真机</p><p>在从资源服务器判断热更后，下载ab包，将其存放在客户端的PersistentData目录下</p></li><li><p>编辑器</p><p>要将ab包复制到PersistentData目录下</p></li></ol></li><li><p>预加载资源</p><p>有一些资源需要在运行前加载到内存中</p><p>有些资源需要在某功能开始前加载</p><ol><li><p>依赖关系</p><p>一个预制体，使用了text，text使用了字体</p><p>字体和预制体都被打包未ab包</p><p>则这个预制体ab依赖于字体的ab</p><p>要使用这个预制体，则需要预加载字体ab</p><ul><li>按照功能划分ab包，一个功能的所有依赖都打包到同一个ab包中</li><li>公共部分打包为公共ab包，所有使用它的模块共同依赖这个ab包</li></ul></li><li><p>预加载常驻内存资源</p><ul><li>提供加载方法，一般用于字体，shader等资源</li></ul></li><li><p>预加载模块资源</p></li></ol></li><li><p>资源维护与清理</p><ol><li>维护<ol><li>allAssetBundle[path] ：存储所有ab包的容器（字典），每一个ab在内存中的引用。ab包被清理后，对应的值也会被清理</li><li>ab.Unload(true)：清理ab包，并清理ab包中每一个资源的引用</li><li>ab.Unload(false)：仅清理ab包，不清理资源的引用。可能会导致内存泄露</li></ol></li><li>清理<ol><li>C#端，判断内存中是否存在ab包，存在则Unload</li><li>lua端根据需要的时候调用</li></ol></li></ol></li><li><p>资源清理策略</p><ol><li><p>如何清理</p><p>调用清理方法</p></li><li><p>调用时机</p><ol><li><p>功能模块关闭后直接调用清理</p><p>对于ab包容量不大，资源数适中，在load时不卡顿</p></li><li><p>根据实际情况决定时机</p><p>对于ab包容量大，资源数较多，load时有卡顿</p></li></ol></li><li><p>策略一：从源头</p><ol><li>在ab包划分时：功能划分，资源划分，公共资源部分确定（常驻）</li><li>资源本生容量控制：在显示效果牺牲不大的情况下降低资源配置</li></ol></li><li><p>二：补救，通过配置文件决定如何清理</p><ol><li>延迟清理：在模块关闭一定时间后再清理</li><li>根据需要<ol><li>时间段：某个时间段内不清理</li><li>等级：某些等级对某些模块的使用更频繁</li><li>其他：vip、等</li></ol></li></ol></li></ol></li></ol></li></ol><h5 id="开发工具设计"><a href="#开发工具设计" class="headerlink" title="开发工具设计"></a>开发工具设计</h5><ol><li><p>编译器工具</p><p>通过自定义扩展编辑器功能</p></li><li><p>常规工具</p><p>独立运行的exe程序</p></li><li><p>准换工具</p><p>json转换为lua</p><p>excel转换为json</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;hr&gt;
&lt;h4 id=&quot;资源目录划分&quot;&gt;&lt;a href=&quot;#资源目录划分&quot; class=&quot;headerlink&quot; title=&quot;资源目录划分&quot;&gt;&lt;/a&gt;资源目录划分&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/热更新/资源目</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="Lua" scheme="http://kennyyyyyy.github.io/tags/Lua/"/>
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
    <category term="xlua" scheme="http://kennyyyyyy.github.io/tags/xlua/"/>
    
  </entry>
  
  <entry>
    <title>Lua学习</title>
    <link href="http://kennyyyyyy.github.io/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/"/>
    <id>http://kennyyyyyy.github.io/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-08-12T02:30:23.000Z</published>
    <updated>2022-11-05T06:58:27.144Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><a href="https://www.runoob.com/manual/lua53doc/contents.html">Lua5.3参考手册</a></p><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><ol><li><p><strong>变量</strong></p><ul><li>动态类型 弱类型 大小写敏感 默认全局 带GC</li><li>类型：nil、boolean、number、string、function、userdata(用户自定义类型)、tread、table</li><li></li></ul></li></ol><ol><li><p><strong>语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 赋值 --</span></span><br><span class="line">a,b = <span class="string">&quot;hello&quot;</span>, <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of a = &quot;</span>, <span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of b = &quot;</span>, <span class="built_in">type</span>(b))</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    多行注释 d </span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"><span class="comment">-- 交换 --</span></span><br><span class="line">a,b = b,a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分支 if  boolean: false、nil。 0 != false</span></span><br><span class="line"><span class="keyword">if</span> b == <span class="number">15</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b = 15&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> b ~= <span class="number">16</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b != 15&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)        </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 循环： 有break 无continue</span></span><br><span class="line"><span class="comment">-- for 起始，终值，增值</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> ,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- while</span></span><br><span class="line">d = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> d &lt;= <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line">    d = d + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- repeat until (do while)</span></span><br><span class="line"></span><br><span class="line">ans = <span class="number">15</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;guess the password (little than 100)&quot;</span>)</span><br><span class="line">    a =<span class="built_in">tonumber</span>(<span class="built_in">io</span>.<span class="built_in">read</span>())</span><br><span class="line">    <span class="keyword">if</span> a == ans <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You are right!&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elseif</span> a &gt; ans <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(a,<span class="string">&quot;Too big&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(a,<span class="string">&quot;Too small&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">until</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数学运算  + -  *  /(//)    %   ^</span></span><br><span class="line"><span class="comment">--         加 减 乘 除(取整) 取余 幂</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;5^3 = &quot;</span>, <span class="number">5</span>^<span class="number">3</span>)</span><br><span class="line"><span class="comment">-- 关系运算 &gt; &lt; &gt;= &lt;= == ~=(不等)</span></span><br><span class="line"><span class="comment">-- 逻辑运算 and(&amp;&amp;) or(||) not(!)</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>数据结构 Table</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table</span></span><br><span class="line"><span class="comment">-- 下标从一开始</span></span><br><span class="line"><span class="comment">-- 可以看作为键值对，没有键值，则默认的位置下标为键值(去掉中间存在键值的)</span></span><br><span class="line"><span class="comment">-- table.key or talbe[&quot;key&quot;]</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,pos =&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;ddd&quot;</span>, [<span class="string">&quot;z&quot;</span>] = <span class="string">&quot;zz&quot;</span>&#125;, x = <span class="number">123</span>, y = <span class="number">456</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;x&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a.y)</span><br><span class="line"><span class="built_in">print</span>(a.pos.z)  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(k) == <span class="built_in">table</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(k) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">print</span>(key, <span class="string">&quot;:&quot;</span>, val)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(k, <span class="string">&quot;:&quot;</span>, v);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>function 函数</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- function </span></span><br><span class="line"><span class="comment">-- 有多个值返回的，从第一个返回的值开始接收，多余的丢弃</span></span><br><span class="line">add = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a + b    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a - b, a * b, <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ans1, ans2 = func(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(ans1, ans2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 高阶函数 第一类(first class)</span></span><br><span class="line"><span class="comment">-- 即返回值或参数为函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span><span class="params">(f, a, b)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;f(a,b)&quot;</span>, f(a,b))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p(func, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 变参 #v == length(v)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">local</span> args = &#123;...&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(args) <span class="keyword">do</span></span><br><span class="line">        sum = sum + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> #args, sum</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>运算符</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 运算符</span></span><br><span class="line"><span class="comment">-- # 求长度 : 用于普通数组，用于表不准确，存在未定义事件(下标不连续，不是整数等)，无法计算长度</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">nil</span>, x = <span class="string">&quot;ss&quot;</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接符 .. 性能消耗大</span></span><br><span class="line">a = <span class="string">&quot;ab&quot;</span></span><br><span class="line">b = <span class="string">&quot;cd&quot;</span></span><br><span class="line">c = a..b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑运算符 and or not (与其他语言基本一致)</span></span><br><span class="line"><span class="comment">-- 优先级 and &gt; or</span></span><br><span class="line"><span class="comment">-- 右结合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>^<span class="number">3</span>^<span class="number">2</span>) <span class="comment">-- &lt;--(2^(3^2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 位运算 &amp;  |  ~  ~    &gt;&gt; &lt;&lt;</span></span><br><span class="line"><span class="comment">--       与 或 非 异或  位运算</span></span><br><span class="line"><span class="comment">-- 3 0011</span></span><br><span class="line"><span class="comment">-- 5 0101</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>~<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>函数库：例</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &quot;&quot;有转译， [[]]无转义</span></span><br><span class="line">a = <span class="string">&quot;a\nb\\c 0b110&quot;</span></span><br><span class="line">b = <span class="string">[[d \ \ \ \ \ cdca\c\]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">&quot;,&quot;</span>, b)</span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">upper</span>(a))</span><br><span class="line"><span class="built_in">print</span>(b:<span class="built_in">upper</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">--string 正则匹配与标准不完全一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--table</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(a, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(a, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(a)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&quot;:&quot;</span>, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">table</span>.<span class="built_in">concat</span>(a, <span class="string">&quot;+&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--math</span></span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>协程</strong></p><p><img src="/images/Lua学习/协程执行流程.png" alt="协程执行流程"></p><p><img src="/images/Lua学习/协程状态转换.png" alt="协程状态转换"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 协程：与Unity协程基本一致，执行到yield，下次执行从yeild后继续</span></span><br><span class="line"><span class="comment">-- thread 线程 协程 进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--type(co) = thread</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;coroutine running...&quot;</span>)</span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;coroutine continue...&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 运行协程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br><span class="line">        v1,v2 = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;v1 = &quot;</span>, v1, <span class="string">&quot;v2 = &quot;</span>, v2)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line">a1,a2,a3 = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a1, a2, a3)   <span class="comment">-- a1：执行结果(成功/失败) a2，a3(yield返回值)</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">-- 第二次调用时传入的参数会作为yeild的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- type(func) == function</span></span><br><span class="line">func = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>OO 面向对象</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 简易面向对象实现代码</span></span><br><span class="line"><span class="comment">-- 定义对象</span></span><br><span class="line"><span class="keyword">local</span> Monster = &#123;</span><br><span class="line">    name = <span class="string">&quot;Monster&quot;</span>,</span><br><span class="line">    HP = <span class="number">100</span>,</span><br><span class="line">    pos = &#123;x = <span class="number">10</span>, y = <span class="number">10</span>&#125;,</span><br><span class="line">    TakeDamage = <span class="function"><span class="keyword">function</span><span class="params">(self, damage)</span></span></span><br><span class="line">        <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">local</span> Monster2 = &#123;HP = <span class="number">200</span>&#125;</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">-- 增加方法,传入对象</span></span><br><span class="line"><span class="comment">    Monster.TakeDamage = function(self, damage)</span></span><br><span class="line"><span class="comment">        self.HP = self.HP - damage    </span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    function Monster:TakeDamage(damage)</span></span><br><span class="line"><span class="comment">        self.HP = self.HP - damamge</span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line">Monster.TakeDamage(Monster2, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(Monster.HP)</span><br><span class="line"><span class="built_in">print</span>(Monster2.HP)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Monster.TakeDamage(Monster, 10),即将Monster作为TakeDamage的第一个参数</span></span><br><span class="line">Monster:TakeDamage(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">------------------------------------------</span></span><br><span class="line"><span class="comment">-- 定义类</span></span><br><span class="line"><span class="comment">-- 通过原表</span></span><br><span class="line">CMonster = &#123;</span><br><span class="line">    name = <span class="string">&quot;Monster&quot;</span>,</span><br><span class="line">    HP = <span class="number">1000</span>,</span><br><span class="line">    TakeDamage = <span class="function"><span class="keyword">function</span><span class="params">(self, damage)</span></span></span><br><span class="line">        <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjMonster = &#123;pos = &#123;x = <span class="number">10</span>, y = <span class="number">10</span>&#125;&#125;</span><br><span class="line"><span class="comment">-- 设置原表  -- 该值或加值，调用的是__newindex</span></span><br><span class="line"><span class="built_in">setmetatable</span>(</span><br><span class="line">    ObjMonster, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">__index</span> = CMonster,</span><br><span class="line">        <span class="built_in">__newindex</span> = CMonster   <span class="comment">-- 若__newindex = CMonster 则修改会影响原表</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(ObjMonster.HP)</span><br><span class="line">ObjMonster.HP = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义new 方法，用于新建对象</span></span><br><span class="line">CMonster = &#123;</span><br><span class="line">    name = <span class="string">&quot;Monster&quot;</span>,</span><br><span class="line">    HP = <span class="number">1000</span>,</span><br><span class="line">    TakeDamage = <span class="function"><span class="keyword">function</span><span class="params">(self, damage)</span></span></span><br><span class="line">        <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line">    <span class="keyword">end</span> ,</span><br><span class="line">    Show = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">self</span>.name, <span class="string">&quot;:&quot;</span>, <span class="built_in">self</span>.HP, <span class="string">&quot;:&quot;</span>, <span class="built_in">self</span>.x, <span class="string">&quot;;&quot;</span>, <span class="built_in">self</span>.y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 设置CMonster的__index， 设置原表时就不需要新建一个表来设置__index了</span></span><br><span class="line">CMonster.<span class="built_in">__index</span> = CMonster </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CMonster:new</span><span class="params">(name, hp, x, y)</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    obj.HP = hp</span><br><span class="line">    obj.x = x</span><br><span class="line">    obj.y = y</span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, CMonster)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置CMonster的原表，使其调用可以直接使用 () 来调用new或其他函数  </span></span><br><span class="line"><span class="built_in">setmetatable</span>(CMonster, &#123;<span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, name, hp, x, y)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>:new(name, hp, x, y)</span><br><span class="line"><span class="keyword">end</span>&#125;)</span><br><span class="line"></span><br><span class="line">obj1 = CMonster(<span class="string">&quot;mon&quot;</span>, <span class="number">300</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">obj1:Show()</span><br><span class="line">obj1:TakeDamage(<span class="number">250</span>)</span><br><span class="line">obj1:Show()</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>类的继承的简单实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 继承</span></span><br><span class="line"><span class="comment">-- 引用上一个文件的CMonster类</span></span><br><span class="line"><span class="keyword">local</span> Cm = <span class="built_in">require</span>(<span class="string">&quot;t6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> obj1 = Cm(<span class="string">&quot;Monster&quot;</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">obj1:Show()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个新类</span></span><br><span class="line"><span class="keyword">local</span> MMonster = &#123;</span><br><span class="line">    MP = <span class="number">200</span>,</span><br><span class="line">    Attack = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Attacking...&quot;</span>)</span><br><span class="line">        <span class="built_in">self</span>.MP = <span class="built_in">self</span>.MP - <span class="number">10</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义其原表未Cm，即模拟继承的效果</span></span><br><span class="line"><span class="built_in">setmetatable</span>(MMonster, &#123;</span><br><span class="line">    <span class="built_in">__index</span> = Cm,</span><br><span class="line">    <span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, name, HP)</span></span></span><br><span class="line">        <span class="keyword">local</span> obj = Cm(name, HP)</span><br><span class="line">        <span class="built_in">setmetatable</span>(obj, &#123;<span class="built_in">__index</span> = MMonster&#125;)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多态的实现，即在新类中定义原表中存在的方法，模拟多态的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MMonster:Show</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;M Monster:&quot;</span>, <span class="built_in">self</span>.name, <span class="built_in">self</span>.HP, <span class="built_in">self</span>.MP)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mm = MMonster(<span class="string">&quot;MMonster1&quot;</span>, <span class="number">100</span>)</span><br><span class="line">mm:Show()</span><br><span class="line">mm:TakeDamage(<span class="number">10</span>)</span><br><span class="line">mm:Show()</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>简单封装的实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 实现Monster类，并进行封装</span></span><br><span class="line"><span class="keyword">local</span> Monster = &#123;&#125;</span><br><span class="line">Monster.HP = <span class="number">100</span></span><br><span class="line">Monster.x = <span class="number">1000</span></span><br><span class="line">Monster.y = <span class="number">10</span></span><br><span class="line">Monster.<span class="built_in">type</span> = <span class="string">&quot;Monster&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:GetHP</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>.HP</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:TakeDamage</span><span class="params">(damage)</span></span></span><br><span class="line">    <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:SetHP</span><span class="params">(hp)</span></span></span><br><span class="line">    <span class="built_in">self</span>.HP = hp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;HP = Monster.HP, x = Monster.x, y = Monster.y&#125;    <span class="comment">-- 默认值</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, Monster)</span><br><span class="line">    <span class="comment">-- __index 定义新表，表示哪些属性可以被obj访问</span></span><br><span class="line">    Monster.<span class="built_in">__index</span> = &#123;GetHP = Monster.GetHP, TakeDamage = Monster.TakeDamage, <span class="built_in">type</span> = Monster.<span class="built_in">type</span>&#125;</span><br><span class="line">    <span class="comment">-- __newindex 访问不存在的域时的调用 例如 obj.type = “ddd&quot; 三个分别对应function的三个参数 </span></span><br><span class="line">    Monster.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(tab, key, value)</span></span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&quot;type&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Forbiden orerate.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">rawset</span>(tab, key, value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Monster</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 引用并测试</span></span><br><span class="line"><span class="keyword">local</span> CMonster = <span class="built_in">require</span>(<span class="string">&quot;t9&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> cm = CMonster:new()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cm:GetHP())</span><br><span class="line">cm:TakeDamage(<span class="number">10</span>)</span><br><span class="line">cm.<span class="built_in">type</span> = <span class="string">&quot;Player&quot;</span>  <span class="comment">-- Forbiden orerate.</span></span><br><span class="line"><span class="comment">--cm:SetHP(100)     -- attempt to call a nil value (method &#x27;SetHP&#x27;) 无法访问，即设置为私有了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cm.z)<span class="comment">-- nil</span></span><br><span class="line">cm.z = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(cm.z)<span class="comment">-- 20</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>闭包</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 闭包：通过一系方法,将函数内部的变量(局部变量)转化为全局变量</span></span><br><span class="line"><span class="comment">-- 如下，</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span><span class="params">()</span></span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cn = Counter()</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/manual/lua53doc/contents.html&quot;&gt;Lua5.3参考手册&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;语法：&quot;&gt;&lt;a href=&quot;#语法：&quot; cla</summary>
      
    
    
    
    
    <category term="Lua" scheme="http://kennyyyyyy.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://kennyyyyyy.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://kennyyyyyy.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2022-05-12T02:30:23.000Z</published>
    <updated>2022-11-05T06:58:13.554Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p><strong>时间复杂度</strong>：指执行算法所需要的工作量。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，即考察输入值大小趋近无穷时的情况。</p><p><strong>空间复杂度</strong>：指执行算法需要的内存空间</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h4><h5 id="栈（Stack）："><a href="#栈（Stack）：" class="headerlink" title="栈（Stack）："></a><strong>栈（Stack）</strong>：</h5><p>后进先出的数据结构。只能在栈顶进行添加（入栈）和删除（出栈）的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本方法</span></span><br><span class="line"><span class="built_in">top</span>()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</span><br><span class="line"><span class="built_in">push</span>(<span class="keyword">const</span> T&amp; obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 <span class="built_in">push_back</span>() 函数完成的。</span><br><span class="line"><span class="built_in">push</span>(T&amp;&amp; obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 <span class="built_in">push_back</span>() 函数完成的。</span><br><span class="line"><span class="built_in">pop</span>()：弹出栈顶元素。</span><br><span class="line"><span class="built_in">size</span>()：返回栈中元素的个数。</span><br><span class="line"><span class="built_in">empty</span>()：在栈中没有元素的情况下返回 <span class="literal">true</span>。</span><br><span class="line"><span class="built_in">emplace</span>()：用传入的参数调用构造函数，在栈顶生成对象。</span><br><span class="line"><span class="built_in">swap</span>(stack&lt;T&gt; &amp; other_stack)：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 <span class="built_in">swap</span>() 可以使用。</span><br></pre></td></tr></table></figure><p><strong>应用</strong>：①撤销操作，②数组反转，③递归</p><h5 id="队列（Queue）："><a href="#队列（Queue）：" class="headerlink" title="队列（Queue）："></a><strong>队列（Queue）</strong>：</h5><p> 先进先出的数据结构，只能在队尾添加（入队）元素，队首删除（出队）元素。（双向队列无尾首区别）</p><p>循环队列 性能最好</p><p><strong>应用</strong>：排队</p><ul><li><p>queue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>();</span><br><span class="line"><span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">front</span>();</span><br><span class="line"><span class="built_in">back</span>();</span><br></pre></td></tr></table></figure></li></ul><h5 id="集合（Set）："><a href="#集合（Set）：" class="headerlink" title="集合（Set）："></a><strong>集合（Set）</strong>：</h5><p>包含不重复元素的集合称为set，例如HashSet等，能快速的进行去重操作。</p><p><strong>应用</strong>：词汇量统计</p><h5 id="映射（Reflection）："><a href="#映射（Reflection）：" class="headerlink" title="映射（Reflection）："></a><strong>映射（Reflection）</strong>：</h5><p>特殊集合，例如Dictionary，存储的是键值对</p><p><strong>应用</strong>：词汇量统计</p><h5 id="有序数组："><a href="#有序数组：" class="headerlink" title="有序数组："></a><strong>有序数组：</strong></h5><p><img src="/images/数据结构与算法/image-20220323182228705.png" alt="image-20220323182228705" style="zoom:50%;"></p><ul><li>Rank使用二分查找找到target的对应位置，方便add 和 remove 的操作，保证数组始终有序</li></ul><h5 id="树："><a href="#树：" class="headerlink" title="树："></a>树：</h5><p>​    <strong>二叉树（Binary Tree）</strong>：普通二叉树</p><p>​    <strong>满二叉树（Full Binary Tree）</strong>：除了叶子节点外都有两个节点</p><p>​    <strong>完全二叉树（Complete Binary Tree）</strong>：每层的节点均达到最大值，及每层的节点数为2的n-1次方个</p><p>​    <strong>二叉搜索树（Binary Search Tree）</strong>：每个节点左边所有节点的值均小于右边节点的值</p><p>​    <strong>平衡二叉树（AVL Tree）</strong>：任何节点的两颗字数的高度差小于等于1</p><p>​    <strong>B树（B-Tree）</strong>：B树与平衡二叉树一样，但是是多叉树</p><p>​    <strong>红黑树（Red-Black Tree）</strong>：自平衡二叉寻找数</p><p>​    </p><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><ul><li>substr(int pos, int len); 获得字串，pos为起始位置，len为长度</li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h4><h6 id="排序：升序为例"><a href="#排序：升序为例" class="headerlink" title="排序：升序为例"></a>排序：升序为例</h6><ul><li><p><strong>冒泡</strong>：双重循环，依次比较大小，前一个比后一个大，则交换位置，时间复杂度O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> t = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>选择</strong>：双重循环，但内循环只选出第 i 个即其之后位置的最小值，然后和第 i 个位置交换，时间复杂度O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = arr.<span class="built_in">size</span>(), idx = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> mx = arr[i];</span><br><span class="line">           idx = i;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(mx &gt; arr[j])&#123;</span><br><span class="line">                   mx = arr[j];</span><br><span class="line">                   idx = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> t = arr[i];</span><br><span class="line">           arr[i] = mx;</span><br><span class="line">           arr[idx] = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>快排</strong>：以第一个数为界 记flag，从前往后找出第一个比flag大的值，从后往前，找出第一个比flag小的数，然后交换两个数的位置。直到找到flag的位置，然后递归查找flag的左侧和右侧的中间值</p><p>时间复杂度O(n log2 n)</p><font color="red">不能对存在重复元素的数组进行排序</font><font color="red">若快排前数组有序，则时间复杂度为O(n^2)</font><font color="red">排序前可以将第一个元素与中间或随机元素进行交换，可优化时间复杂度</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = arr[start];</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++i] &lt; flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == end)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[j] &gt; flag)&#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(j == start)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[start] = arr[j];</span><br><span class="line">    arr[j] = flag;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, start, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, j + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>三路快排</strong>：<font color="red">有重复元素的快速排序</font> ，即相比上一个方法，多了等于flag的情况</p><p>即将数组中的元素分为三个区域，大于[gt, right] 小于[l+1, lt]和等于选定值flag的情况</p><p><img src="/images/数据结构与算法/70.png" alt="img"></p><p>i 指向当前元素</p><ul><li>若 i 指向元素等于flag，则i++；</li><li>若 i 指向元素小于flag，则将 it + 1 指向的值与 i 交换，然后 it++、i++。即将小于flag的区域增1，且等于flag的区域右移1.</li><li>若 i 指向的元素大于flag， 则将 gt - 1 指向的元素与 i 交换，然后 gt—。即将大于flag的区域向后增1，其余区域不变</li><li>当 i 指向 gt 时，表示遍历完成，此时只需将 flag 除的值与 lt 处的值进行交换，则三个区间形成，然后继续遍历大于flag和小于flag的区域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> flag = res[start];</span><br><span class="line">     <span class="keyword">int</span> i = start + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> lt = start, gt = end + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(i &lt; gt)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; flag)&#123;</span><br><span class="line">             <span class="keyword">int</span> t = arr[i];</span><br><span class="line">             arr[i] = arr[lt + <span class="number">1</span>];</span><br><span class="line">             arr[lt + <span class="number">1</span>] = t;</span><br><span class="line">             lt++;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; flag)&#123;</span><br><span class="line">             <span class="keyword">int</span> t = arr[i];</span><br><span class="line">             arr[i] = arr[gt - <span class="number">1</span>];</span><br><span class="line">             arr[gt - <span class="number">1</span>] = t;</span><br><span class="line">             gt--;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> arr[start] = arr[lt];</span><br><span class="line"> arr[lt] = flag;</span><br><span class="line">     <span class="built_in">QuickSort</span>(arr, start, lt - <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">QuickSort</span>(arr, gt, end);</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> arr;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>归并</strong>：采用分治法，先使子序列有序，然后将两个有序子序列合并，得到有序序列。即先将输入序列分成n/2个子序列，对这两个子序列分别采用归并排序，将两个排序好的子序列合并成排序序列，时间复杂度O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, vector&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = start;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">            res[k++] = arr[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        res[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(j &lt;= end)&#123;</span><br><span class="line">        res[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = start; z &lt;= end; z++)&#123;</span><br><span class="line">        arr[z] = res[z];</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, vector&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, res, start, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, res, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">Merge</span>(arr, res, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, res, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>堆</strong>：</p></li><li><p><strong>桶</strong>：</p></li></ul><h6 id="查找："><a href="#查找：" class="headerlink" title="查找："></a><strong>查找：</strong></h6><ul><li><p>顺序查找<strong>O(n)</strong>：遍历所有数据，进行处理 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">OrderSearch</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n, i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(target == arr[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找<strong>O(log n)</strong>：对有序数组进行分半查找，每次为对比中间数据，然后根据大小关系，对前半部分或后半部分进行对比。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BinarySearch</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>; <span class="comment">//防止数据溢出</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt; arr[mid])</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; arr[mid])</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="递归-recursion-："><a href="#递归-recursion-：" class="headerlink" title="递归(recursion)："></a><strong>递归(recursion)：</strong></h6><ul><li>程序调用自身的编程技巧称为递归，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解.。递归需要有边界条件、递归前进段和递归返回段。</li><li><strong>尾递归</strong>：首先执行计算，然后执行递归调用<ul><li>在尾部调用的是函数自身 （Self-called）；</li><li>可通过优化，使得计算仅占用常量栈空间 (Stack Space)。</li></ul></li></ul><h6 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h6><ul><li><p>定义：在一些有N个元素的集合应用问题中，通常在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。</p></li><li><p>主要用于解决一些<strong>元素分组</strong>的问题，用于管理一系列<strong>不相交的集合</strong>并存在两种操作：</p><ul><li><strong>查找(Find)</strong>:查询两个元素是否在同一个集合中；</li><li><strong>合并(Union)</strong>:把两个不相交的集合合并成一个集合。</li></ul></li><li><p>最简单版本的并查集代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> parent[MaxSize]; <span class="comment">//使用parents数组来记录每个节点的父节点</span></span><br><span class="line"><span class="comment">//初始化：首先将所有的节点的父节点设置为自己</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询:通过递归不断访问父节点，直到访问到根节点。根据两个节点的根节点是否相同来判断是否在同一个集合当中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[val] == val)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Find</span>(parent[val]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并：找到两个节点所在集合的根节点，将一个根节点的父节点设置为另一个根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parent[<span class="built_in">Find</span>(i)] == <span class="built_in">Find</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接合并可能会导致每次查询的路径过长，而增加时间消耗，因此，存在两个方面对算法进行优化</p><ul><li><p>路径压缩：在查询过程中把沿途的每个节点的父节点全部设置为根节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[val] == val)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    parent[val] = <span class="built_in">Find</span>(Parent[val]); <span class="comment">//将父节点设置为根节点</span></span><br><span class="line">    <span class="keyword">return</span> parent[val]<span class="comment">//返回父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通常简化为</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">Find</span>(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> parent[val] == val ? val:(parent[val] = <span class="built_in">Find</span>(parent[val]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按秩合并：用rank[]数组记录每个根节点对应的深度。初始化为1。合并时把rank较小的合并在较大的根节点上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="built_in">Find</span>(i);</span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">Find</span>(j);</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &gt; rank[y])</span><br><span class="line">        parent[y] = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">parent[x] = y;</span><br><span class="line">    <span class="keyword">if</span>(rank[x] == rank[y] &amp;&amp; x != y)<span class="comment">//如果深度相同且不是同一个根节点，则新的根节点深度加一</span></span><br><span class="line">        rank[y]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]"> ，但是很可能会破坏rank的准确性。</p></li></ul><h6 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h6><p>背包问题大体的解题模板是<strong>两层循环</strong>，分别遍历物品nums和背包容量target，然后写转移方程，根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法。</p><ol><li><p>01背包：外循环nums,内循环target,target倒序且target&gt;=nums[i];</p><p>例：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p></li><li><p>完全背包</p><ul><li>组合问题：外循环nums,内循环target,target正序且target&gt;=nums[i]</li><li>排列问题：外循环target,内循环nums,target正序且target&gt;=nums[i]</li></ul></li><li><p>分组背包：需要多重循环：外循环nums,内部循环根据题目的要求构建多重背包循环</p></li></ol><h6 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h6><p>概述</p><ul><li>A*算法是一个搜索算法，是对于广搜(BFS)的优化。</li><li>A<em>算法类似于Dijkstra算法。不同点在于A\</em>算法的查找优先向最可能到达终点的方向进行查找。即相较于BFS，少搜索了一些不太可能达到终点的点。</li><li>因为H是对未来路径的预测，所以A*算法找到的路径不一定是最短的，但牺牲准确度带来的是效率的提升</li></ul><p>关键</p><ul><li>启发函数：计算组成路径的方格的关键是以下等式<ul><li>F = G + H</li><li>G：从起点移动到当前点的代价。</li><li>H：从当前点移动到终点的预估代价。</li><li>F：当前选择路径的可能总代价，作为下一个将遍历点的依据</li><li>对于网格形式的图，H有几种方式：<ul><li>中能上下左右移动的，使用曼哈顿距离(|x1 - x2| + |y1 - y2|)</li><li>允许八个方向的，则使用对角距离</li><li>允许任意方向的，使用欧几里得距离(两点间的先线段长度)</li></ul></li></ul></li><li></li></ul><p><a href="https://github.com/kennyyyyyy/Untiy_AStar">Github，Unity案例</a></p><p>为了方便观察使用和Debug，进行了一些可视化处理</p><p><img src="/images/数据结构与算法/image-20221017200354119-16660082494291-16660082519673-16660082539365.png" alt="展示"></p><p>算法思路</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FindPath</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(openList.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序，F值小的在前</span></span><br><span class="line">    openList.Sort();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> minF = openList[<span class="number">0</span>].F, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将F最小的几个点的全部遍历完之后再开始下一次</span></span><br><span class="line">    <span class="keyword">while</span>(idx &lt; openList.Count &amp;&amp; minF == openList[idx].F)</span><br><span class="line">    &#123;</span><br><span class="line">        Point curPoint = openList[idx++];</span><br><span class="line"></span><br><span class="line">        Point nextPoint;</span><br><span class="line">        List&lt;Vector2&gt; dir = <span class="keyword">new</span> List&lt;Vector2&gt; &#123; Vector2.up, Vector2.right, Vector2.down, Vector2.left &#125;;</span><br><span class="line">        <span class="comment">//四个方向依次查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//越界判断</span></span><br><span class="line">            <span class="keyword">if</span> (curPoint.x + dir[i].x &gt;= <span class="number">0</span> &amp;&amp; curPoint.x + dir[i].x &lt; height * <span class="number">2</span> &amp;&amp; curPoint.y + dir[i].y &gt;= <span class="number">0</span> &amp;&amp; curPoint.y + dir[i].y &lt; width * <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nextPoint = map[(<span class="built_in">int</span>)(curPoint.x + dir[i].x), (<span class="built_in">int</span>)(curPoint.y + dir[i].y)];</span><br><span class="line">                <span class="comment">//不是障碍物才会对nextPoint进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (nextPoint.Type != BlockType.Obstacle)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//不在closeList列表中，即不是关闭状态</span></span><br><span class="line">                    <span class="keyword">if</span> (!closeList.Contains(nextPoint))</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextPoint.SetParent(curPoint);</span><br><span class="line"></span><br><span class="line">                        nextPoint.G = curPoint.G + <span class="number">1</span>;</span><br><span class="line">                        CalculateH(nextPoint, EndPoint);</span><br><span class="line">                        <span class="keyword">if</span> (!openList.Contains(nextPoint))</span><br><span class="line">                        &#123;</span><br><span class="line">                            nextPoint.Type = BlockType.Opened;</span><br><span class="line">                            openList.Add(nextPoint);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//是关闭状态，则更新其cost为较小的</span></span><br><span class="line">                        <span class="keyword">if</span> (curPoint.G + <span class="number">1</span> &lt; nextPoint.G)</span><br><span class="line">                        &#123;</span><br><span class="line">                            nextPoint.SetParent(curPoint);</span><br><span class="line">                            nextPoint.G = curPoint.G + <span class="number">1</span>;</span><br><span class="line">                            CalculateH(nextPoint, EndPoint);</span><br><span class="line">                            <span class="comment">//if (!openList.Contains(nextPoint))</span></span><br><span class="line">                            <span class="comment">//&#123;</span></span><br><span class="line">                            <span class="comment">//    nextPoint.Type = BlockType.Opened;</span></span><br><span class="line">                            <span class="comment">//    openList.Add(nextPoint);</span></span><br><span class="line">                            <span class="comment">//&#125;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移出openList并加入closeList，将当前点关闭</span></span><br><span class="line">        closeList.Add(curPoint);</span><br><span class="line">        openList.Remove(curPoint);</span><br><span class="line">        curPoint.Type = BlockType.Closed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//openList存在End节点，表示已经找到了路径</span></span><br><span class="line">        <span class="keyword">if</span> (openList.Contains(EndPoint))</span><br><span class="line">        &#123;</span><br><span class="line">            isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>每帧执行</li><li>Point类为地图中的一个点</li><li>将将要被遍历的点放入openList中，每次执行FindPath都会对openList中F值最小的点进行遍历，然后将其加入closeList中。</li><li>当openList中存在终点时，代表已经遍历至终点，从终点依次遍历其Parent点便可以得到最终路径</li></ul><p>执行</p><p><img src="/images/数据结构与算法/image-20221017201533543.png" alt="运行结果"></p><h4 id="STL-C"><a href="#STL-C" class="headerlink" title="STL(C++)"></a>STL(C++)</h4><ul><li>增删查：insert()、erase()、find()</li></ul><h6 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h6><ul><li><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec2</span><span class="params">(vec)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec2 = vec;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec2&#123;a, b, c&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec2</span><span class="params">(len, val)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>增</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + idx, val);</span><br></pre></td></tr></table></figure></li><li><p>删</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">pop_back</span>();<span class="comment">//尾部删除</span></span><br><span class="line"></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + idx);</span><br><span class="line"><span class="comment">//删除一段区间内的元素</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + idx, v.<span class="built_in">begin</span>() + idx + length);</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure></li></ul><h6 id="set"><a href="#set" class="headerlink" title="set"></a>set</h6><ul><li><p>find(T val); 返回指向对应元素的迭代器，若无对应元素，则返回指向end()。</p></li><li><p>erase(iterator); 删除迭代器指向的元素；</p></li><li><p>insert(T val); 插入元素</p></li><li><p>若T为结构体，则需重载 &lt; 运算符</p></li></ul><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><ul><li><h6 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列(priority_queue)"></a>优先队列(priority_queue)</h6></li><li><p>特殊队列。每次从队列中取出的是具有最高优先权的元素。\</p></li><li><p>自定义优先级：</p><ul><li><p>重载运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小优先</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> a.val &gt; b.val</span>;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;T, vector&lt;T&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h6 id="智能指针-shared-ptr"><a href="#智能指针-shared-ptr" class="headerlink" title="智能指针(shared_ptr)"></a>智能指针(shared_ptr)</h6><ul><li>ss</li></ul><h6 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h6><ul><li></li></ul><h6 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h6><ul><li>static的用法<ol><li>静态局部变量</li><li>静态全局变量</li><li>静态函数</li><li></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;算法复杂度&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：指执行算法所需要的工作</summary>
      
    
    
    
    
    <category term="C++" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
    <category term="数据结构" scheme="http://kennyyyyyy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://kennyyyyyy.github.io/2021/09/16/%E5%89%91%E6%8C%87offer/"/>
    <id>http://kennyyyyyy.github.io/2021/09/16/%E5%89%91%E6%8C%87offer/</id>
    <published>2021-09-16T08:45:47.000Z</published>
    <updated>2022-11-05T06:54:01.042Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p>链表反转：</p><p>开始先设定三个指针，并进行初始化，如图</p><p><img src="/images/剑指offer/List_1.png" alt="List_1"></p><p>并将Pre的指向的Next指向NULL</p><p><img src="/images/剑指offer/List_2.png" alt="List_2"></p><p>开始循环，head指针后移，让Cur指针的Next指向Pre，然后使Pre = Cur，Cur = Head。直到链表尾</p><p><img src="/images/剑指offer/List_3.png" alt="List_3"></p><p><img src="/images/剑指offer/List_4.png" alt="List_4"></p></li></ul><ul><li><p>二分法模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;根据题目判断搜索条件&quot;</span>) &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>广度优先遍历（BFS）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; qu;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        qu.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left)</span><br><span class="line">            qu.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;right)</span><br><span class="line">            qu.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>深度优先遍历（DFS）</p><ul><li>例题：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></li><li>用dfs深度遍历加回溯法。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//循环查找，每个字符都可能是第一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">const</span> string&amp; word, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx == word.<span class="built_in">length</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= board.<span class="built_in">size</span>() || </span><br><span class="line">        col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || </span><br><span class="line">        board[row][col] != word[idx]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//将遍历过的，和word字符匹配的位置置为不可能出现的字符，起到visited数组的作用</span></span><br><span class="line">board[row][col] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行递归遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, row - <span class="number">1</span>, col, idx + <span class="number">1</span>) ||</span><br><span class="line"><span class="built_in">dfs</span>(board, word, row + <span class="number">1</span>, col, idx + <span class="number">1</span>) ||</span><br><span class="line"><span class="built_in">dfs</span>(board, word, row, col - <span class="number">1</span>, idx + <span class="number">1</span>) ||</span><br><span class="line"><span class="built_in">dfs</span>(board, word, row, col + <span class="number">1</span>, idx + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若此次遍历无匹配，则将数组字符还原</span></span><br><span class="line">board[row][col] = word[idx];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><p>清除字符串前后的空格符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>​    <img src="/images/剑指offer/image-20210929203313557.png" alt="image-20210929203313557"></p><ol><li><p>前序遍历：优先遍历根节点，然后是左子节点，再是右子节点</p><p>​    A-B-D-F-G-H-I-E-C</p></li><li><p>中序遍历：优先遍历左子节点，然后是根节点，再是右子节点</p><p>​    F-D-H-G-I-B-E-A-C</p></li><li><p>后序遍历：优先遍历左子节点，然后是右子节点，再是根节点</p><p>​    F-H-I-G-D-E-B-C-A</p></li></ol><ul><li><h5 id="二叉树转化成双向链表："><a href="#二叉树转化成双向链表：" class="headerlink" title="二叉树转化成双向链表："></a>二叉树转化成双向链表：</h5><p>用中序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head保存双向链表头节点，pre保存中序遍历时的前一个遍历的节点</span></span><br><span class="line">Node* pre = <span class="literal">NULL</span>, * head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">dfsm</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使首尾相连</span></span><br><span class="line">head-&gt;left = pre;</span><br><span class="line">    pre-&gt;right = head;</span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsm</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">dfsm</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">//如果pre为空，则此节点为第一个节点，所以记录下头节点</span></span><br><span class="line">    <span class="keyword">if</span> (!pre)</span><br><span class="line">head = root;</span><br><span class="line">    <span class="comment">//不为空则表示已经遍历过其他节点，因此使上一个节点指向此节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pre)</span><br><span class="line">    pre-&gt;right = root;</span><br><span class="line">    <span class="comment">//双向链表，因此此节点的左指针指向上一个节点</span></span><br><span class="line">root-&gt;left = pre;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="built_in">dfsm</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><h4 id="优先队列：priority-queue"><a href="#优先队列：priority-queue" class="headerlink" title="优先队列：priority_queue"></a>优先队列：priority_queue</h4><ul><li><p>包含在头文件 ‘queue’ 中,我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队.</p></li><li><p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列，小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序队列，大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="二叉搜索树：Binary-Search-Tree"><a href="#二叉搜索树：Binary-Search-Tree" class="headerlink" title="二叉搜索树：Binary Search Tree"></a>二叉搜索树：Binary Search Tree</h4><ul><li><p>若它的左子树不空，则左子树上所有结点的值均小于它的<a href="https://baike.baidu.com/item/根结点/9795570">根结点</a>的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为<a href="https://baike.baidu.com/item/二叉排序树/10905079">二叉排序树</a>。</p></li><li><p>中序遍历得到的结果使有序的</p><p><img src="images/剑指offer/image-20211003134458224.png" alt="image-20211003134458224"></p></li></ul></li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><h5 id="分组位运算："><a href="#分组位运算：" class="headerlink" title="分组位运算："></a>分组位运算：</h5><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p></li></ul><p>  相同数字异或为零</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;<span class="comment">//所有数字异或的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到第一位为1的位置</span></span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//通过是否为一将数组分为两组，分别进行异或运算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= n;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;链表反转：&lt;/p&gt;
&lt;p&gt;开始先设定三个指针，并进行初始化，如图&lt;/p&gt;
</summary>
      
    
    
    
    <category term="c++" scheme="http://kennyyyyyy.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="http://kennyyyyyy.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>几种AI解决方法</title>
    <link href="http://kennyyyyyy.github.io/2021/07/29/%E5%87%A0%E7%A7%8DAI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://kennyyyyyy.github.io/2021/07/29/%E5%87%A0%E7%A7%8DAI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2021-07-29T11:36:24.000Z</published>
    <updated>2022-11-10T04:31:20.442Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>人工智能遵循着：感知-&gt;思考-&gt;行动<br>决策方法：有限状态机（Finite-State Machines），分层状态机（Hierarchical Finite-State Machines），行为树（Behavior Trees），效用系统（Utility Systems），目标导向型行动计划（Goal-Oriented Action Planners），分层任务网络（Hierarchical Task Networks）</p><h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>FSM是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的机器。是一种设计模式</p><ul><li><p>假设存在3个状态：巡逻（patrol），查看（investigate），攻击（attack）。正常状态为巡逻，当听到动静时会变为查看状态，若发现敌人则变为攻击状态，或者一段时间后回到巡逻状态。打死敌人之后或脱离范围，则回到巡逻状态</p></li><li><p>每个状态用一个类表示</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params"></span>)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;人工智能遵循着：感知-&amp;gt;思考-&amp;gt;行动&lt;br&gt;决策方法：有限状态机（Finite-State Machines），分层状态机（Hierarchical Finite-State Machines），行为树（Behav</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="unity" scheme="http://kennyyyyyy.github.io/tags/unity/"/>
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>3D RPG 学习笔记</title>
    <link href="http://kennyyyyyy.github.io/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://kennyyyyyy.github.io/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-23T07:38:31.000Z</published>
    <updated>2022-11-05T06:58:45.573Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="一、创建项目导入素材"><a href="#一、创建项目导入素材" class="headerlink" title="一、创建项目导入素材"></a>一、创建项目导入素材</h2><ol><li><h4 id="创建普通项目"><a href="#创建普通项目" class="headerlink" title="创建普通项目"></a>创建普通项目</h4><ul><li>在Package Manager中安装Universal RP</li><li>在Asset中创建Rendering =&gt; Universal Render Pipeline =&gt; Pipeline Asset(URP的设置文件)</li><li>将project setting中Graphics和Quality的渲染管线设置为刚创建的渲染管线设置文件</li><li>导入素材（Dog Knight PBR Polyart、 Low-Poly Simple Nature Pack 和 FREE Skybox Extended Shader）</li><li>在Edit =&gt; Edit=Render Pipeline =&gt; Universal Render Pipeline 中设置当前项目或当前素材的渲染管线</li><li>在Lighting =&gt; Environment 中设置天空盒的材质</li><li>注意Asset窗口和Inspect窗口的物体分类，方便管理</li></ul></li><li><h4 id="安装package"><a href="#安装package" class="headerlink" title="安装package"></a>安装package</h4><ul><li><p><strong>PolyBrush</strong> </p><p><img src="/images/3D-RPG-学习笔记/0.png" alt="PolyBrush "></p><ol><li><p>调整地面的高度(左键直接点击变高，control+左键点击变矮)</p><p><img src="/images/3D-RPG-学习笔记/1.png" alt="调整"></p><ul><li>Outer Radius：外圈大小</li><li>Inner Radius：内圈大小</li><li>Strength：变化强度</li><li>Direction：设置变化的方向。Brush normal：材质的法线方向</li><li>Brush Mirroring：沿坐标轴对称形成另一个笔刷同时进行相同操作</li></ul></li><li><p>柔化：将比较突出的棱角变的平滑。设置基本同上</p><p><img src="/images/3D-RPG-学习笔记/2.png" alt="柔化"></p></li><li><p>将当前物体刷上不同的颜色</p><p><img src="/images/3D-RPG-学习笔记/3.png" alt="颜色刷"></p><ul><li>如果需要将颜色刷到物体上，则物体材质的 shader 需要为 Polybrush=&gt; Shader 下的shader</li><li>Brush：根据笔刷的大小刷上颜色</li><li>Fill：填充区块</li><li>Flood：整个物体</li></ul></li><li><p>将预制体刷到场景当中</p><p><img src="/images/3D-RPG-学习笔记/4.png" alt="预制体刷"></p><ul><li>基本设置同1</li><li>将需要的prefab添加到Current Palette中，当前选中的prefab会在Brush Loadout中</li><li>Brush Loadout 中prefab下的拖动条表示此物体出现的概率</li><li>Hit Surface is Parent：将所有的画在平面上的物体都是此平面的子物体</li></ul></li><li><p>将texture刷到场景当中</p><ul><li>同4</li></ul></li></ol></li><li><p><strong>Pro Builder</strong> </p><p><img src="/images/3D-RPG-学习笔记/ProBuilder.png" alt=" Pro Builder "></p><ul><li>按住shift可以查看图标的功能</li><li></li></ul></li><li><p><strong>Pro Grids</strong></p><ul><li><p>安装ProGrids需要在Project Setting的Package Manger中打开允许preview</p><p><img src="/images/3D-RPG-学习笔记/EnablePreview.png" alt="Enable Preview"></p></li><li><p><img src="/images/3D-RPG-学习笔记/ProGrids.png" alt="Pro Grids"></p></li></ul><ol><li>设置物体移动时的单位距离</li><li>是否在Scene窗口中显示坐标轴</li><li>是否自动吸附：即按照1的设置在坐标轴上自动进行吸附，每次只移动1的距离</li><li>4</li><li>5</li><li>X 、Y、 Z、 3D均为Scene窗口显示的坐标轴</li></ol></li></ul></li><li><h4 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h4><p>自动导航</p></li><li><h4 id="点击移动"><a href="#点击移动" class="headerlink" title="点击移动"></a>点击移动</h4><ol><li><p><strong>自定义事件的注册和调用</strong></p><ol><li><p><img src="/images/3D-RPG-学习笔记/image-20210724155224166.png" alt="自定义事件"></p><ul><li><p>注册</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventVector3</span> : <span class="title">UnityEvent</span>&lt;<span class="title">Vector3</span>&gt; &#123; &#125;;</span><br><span class="line"><span class="comment">//声明类，继承UnityEvent，并需要参数Vector3</span></span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OnMouseClicked?.Invoke(hitInfo.point);</span><br><span class="line"><span class="comment">//当OnMouseClicked事件不为空时调用，并传入point信息</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p><strong>屏幕射线转为世界射线</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure></li><li><p><strong>单例模式</strong></p><p>方便事件函数等在外部的调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MouseManager Instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Instance != <span class="literal">null</span>)</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    Instance = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>事件注册和调用</strong></p></li></ol></li><li><h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><ul><li>鼠标指针图片切换</li><li>Cinemachine：多功能相机插件</li><li>Post Processing：后处理</li><li>Animator</li></ul></li><li><h4 id="Shader-Graph-遮挡剔除"><a href="#Shader-Graph-遮挡剔除" class="headerlink" title="Shader Graph 遮挡剔除"></a>Shader Graph 遮挡剔除</h4></li><li><h4 id="FSM-状态机"><a href="#FSM-状态机" class="headerlink" title="FSM 状态机"></a>FSM 状态机</h4></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;一、创建项目导入素材&quot;&gt;&lt;a href=&quot;#一、创建项目导入素材&quot; class=&quot;headerlink&quot; title=&quot;一、创建项目导入素材&quot;&gt;&lt;/a&gt;一、创建项目导入素材&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="unity" scheme="http://kennyyyyyy.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>每日一题</title>
    <link href="http://kennyyyyyy.github.io/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://kennyyyyyy.github.io/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2021-07-19T07:49:14.000Z</published>
    <updated>2022-11-05T06:49:39.557Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="面试题-10-02-变位词组"><a href="#面试题-10-02-变位词组" class="headerlink" title="面试题 10.02. 变位词组"></a><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></h3><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序</li></ul><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>思路</strong>：计数法。</p><p>计算每个字符串中所有字符出现的个数，将相同的放在同一个list中，完成分类</p></li><li><p><strong>代码</strong>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; GroupAnagrams(<span class="built_in">string</span>[] strs) &#123;</span><br><span class="line">        </span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; vs = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"><span class="comment">// 用字典储存相同的字符串</span></span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, IList&lt;<span class="built_in">string</span>&gt;&gt; pairs = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">        <span class="comment">// 用list储存出现过的key</span></span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; keysss = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环计算所有字符串中出现字符的次数，并通过key将字符串添加到相应的pairs中，最终结果key也添加到keysss列表中</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> str <span class="keyword">in</span> strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> key = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&#x27;0&#x27;</span>, <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> val <span class="keyword">in</span> str)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> keys = key.ToCharArray();</span><br><span class="line">                keys[val - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                key = <span class="keyword">new</span> <span class="built_in">string</span>(keys);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pairs.ContainsKey(key))</span><br><span class="line">            &#123;</span><br><span class="line">                pairs[key].Add(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                IList&lt;<span class="built_in">string</span>&gt; temp = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">                temp.Add(str);</span><br><span class="line">                pairs.Add(key, temp);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (!keysss.Contains(key))</span><br><span class="line">            &#123;</span><br><span class="line">                keysss.Add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出字典中的数据，存到list中</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> key <span class="keyword">in</span> keysss)</span><br><span class="line">        &#123;</span><br><span class="line">            vs.Add(pairs[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1877-数组中最大数对和的最小值"><a href="#1877-数组中最大数对和的最小值" class="headerlink" title="1877. 数组中最大数对和的最小值"></a><a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></h3><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a><strong>题解</strong>：</h4><ol><li><p><strong>分析</strong>：</p><p>最大与最小相加产生的数对和最小，即第k大的数和第k小的数相加，所得的最大数对和最小.</p><p>所以先将数组进行排序，然后依次下相加比较，即得出结果</p></li><li><p><strong>代码</strong>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinPairSum</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.Length;</span><br><span class="line">    Array.Sort(nums);</span><br><span class="line">    <span class="built_in">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxSum = Math.Max(maxSum, nums[i] + nums[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1893-检查是否区域内所有整数都被覆盖"><a href="#1893-检查是否区域内所有整数都被覆盖" class="headerlink" title="1893. 检查是否区域内所有整数都被覆盖"></a><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">1893. 检查是否区域内所有整数都被覆盖</a></h3><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>暴力解法，用一个 right-left+1 大小的数组来记录，直接通过二重循环，依次判断ranges中的每个[start,end]中是否包含[left,right]中的任意数字，如果包含，则对应的数组的值加一，循环完毕后再次循环判断数组中是否有0，有则为false，没有返回true。</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsCovered</span>(<span class="params"><span class="built_in">int</span>[][] ranges, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span>[] ltr = <span class="keyword">new</span> <span class="built_in">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ranges.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = ranges[i][<span class="number">0</span>]; j &lt;= ranges[i][<span class="number">1</span>]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt;= right &amp;&amp; j &gt;= left)</span><br><span class="line">            &#123;</span><br><span class="line">                ltr[j - left]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ltr[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1743-从相邻元素对还原数组"><a href="#1743-从相邻元素对还原数组" class="headerlink" title="1743. 从相邻元素对还原数组"></a><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/">1743. 从相邻元素对还原数组</a></h3><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>将数组中的数对用字典储存，则数组头或尾中字典的list的长度只有1，然后在通过字典，一次查找下一个</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">RestoreArray</span>(<span class="params"><span class="built_in">int</span>[][] adjacentPairs</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt; pairs = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">int</span>[] pair <span class="keyword">in</span> adjacentPairs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pairs.ContainsKey(pair[<span class="number">0</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    pairs.Add(pair[<span class="number">0</span>], <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!pairs.ContainsKey(pair[<span class="number">1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    pairs.Add(pair[<span class="number">1</span>], <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                pairs[pair[<span class="number">0</span>]].Add(pair[<span class="number">1</span>]);</span><br><span class="line">                pairs[pair[<span class="number">1</span>]].Add(pair[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> n = adjacentPairs.Length + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> pair <span class="keyword">in</span> pairs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> key = pair.Key;</span><br><span class="line">                <span class="keyword">if</span>(pair.Value.Count == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[<span class="number">0</span>] = key;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[<span class="number">1</span>] = pairs[nums[<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;<span class="built_in">int</span>&gt; vs = pairs[nums[i - <span class="number">1</span>]];</span><br><span class="line">                nums[i] = nums[i - <span class="number">2</span>] == vs[<span class="number">0</span>] ? vs[<span class="number">1</span>] : vs[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="704-二分查找-2021-9-7"><a href="#704-二分查找-2021-9-7" class="headerlink" title="704. 二分查找 2021/9/7"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a> 2021/9/7</h3><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>经典二分题，将数组分成两个部分，通过判断中间数字和目标数字的大小比较，然后进入目标数字存在的部分再次进行二分查找</p><p>在进行中间下标的计算时，若直接用 (left + right)/2 会导致一些特殊情况出现问题，所以使用 (right - left)/2 + left， 或直接使用位移运算 left + right &gt;&gt; 1。</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> right = nums.Length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> middle = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (nums[middle] == target)</span><br><span class="line">                    <span class="keyword">return</span> middle;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">                    left = middle + <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="470-用-Rand7-实现-Rand10-2021-9-6"><a href="#470-用-Rand7-实现-Rand10-2021-9-6" class="headerlink" title="470. 用 Rand7() 实现 Rand10()  2021/9/6"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a>  2021/9/6</h3><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>Rand7() 有 1~7 共7种数字，49种情况，所以从1-10依次分布如下</p><p>​    <img src="/images/每日一题/Rand7.png" alt="Rand7"></p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Rand10</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> ra = Rand7();</span><br><span class="line">    <span class="built_in">int</span> rb = Rand7();</span><br><span class="line">    <span class="built_in">int</span> idx;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ra = Rand7();</span><br><span class="line">        rb = Rand7();</span><br><span class="line">        idx = ra + (rb - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(idx &gt; <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> (idx) % <span class="number">10</span> + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1221-分割平衡字符串-2021-9-7"><a href="#1221-分割平衡字符串-2021-9-7" class="headerlink" title="1221. 分割平衡字符串 2021/9/7"></a><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串</a> 2021/9/<strong>7</strong></h3><h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>循环计算字符串中的L和R的字符个数，当两个个数相等时就表示出现一个平衡字符串，则计数器加一。</p></li></ol><ol><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BalancedStringSplit</span>(<span class="params"><span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">int</span> len = s.Length;</span><br><span class="line">    <span class="built_in">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i].Equals(<span class="string">&#x27;L&#x27;</span>))</span><br><span class="line">            L++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R++;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (L == R)</span><br><span class="line">        &#123;</span><br><span class="line">            L = <span class="number">0</span>;</span><br><span class="line">            R = <span class="number">0</span>;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="678-有效的括号字符串-2021-9-12"><a href="#678-有效的括号字符串-2021-9-12" class="headerlink" title="678. 有效的括号字符串  2021/9/12"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a>  2021/9/12</h3><h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><ul><li><p><strong>堆栈法：</strong></p><p>对字符串s逐个字符进行判断，有如下三种情况</p><ul><li>如果字符是左括号，则将其下标压入左括号栈</li><li>如果字符是星号，则将其下表压入星号栈</li><li>如果字符是右括号，则<ul><li>如果左括号栈中元素不为空，则将左括号栈中顶部元素出栈</li><li>如果左括号栈中元素为空，星号栈中元素不为空，则将星号栈中顶部元素出栈</li><li>如果两个栈中元素都为空，则此右括号无匹配元素，返回false</li></ul></li><li>字符串遍历完后，如果两个栈中元素都不为空，则依次将两个栈中的栈顶元素出栈，然后比较两个元素的大小，如果左括号栈的出栈下标比星号栈的出栈下标大，则表示左括号在星号的后面，无法匹配，返回false</li><li>最后判断左括号栈中的所有元素是否全部出栈，即所有左括号均有匹配，则返回true（星号可以为空字符，所以星号栈不需要做判断）</li></ul></li><li><p><strong>动态规划：</strong></p></li><li><p><strong>贪心：</strong></p></li></ul></li></ol><ol><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckValidString</span>(<span class="params"><span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> length = s.Length;</span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; left = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; aster = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i].Equals(<span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">                left.Push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i].Equals(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                aster.Push(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (left.Count &gt; <span class="number">0</span>)</span><br><span class="line">                    left.Pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (aster.Count &gt; <span class="number">0</span>)</span><br><span class="line">                    aster.Pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left.Count &gt; <span class="number">0</span> &amp;&amp; aster.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> leftIndex = left.Pop();</span><br><span class="line">            <span class="built_in">int</span> asterIndex = aster.Pop();</span><br><span class="line">            <span class="keyword">if</span> (leftIndex &gt; asterIndex)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.Count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="447-回旋镖的数量-2021-9-12"><a href="#447-回旋镖的数量-2021-9-12" class="headerlink" title="447. 回旋镖的数量  2021/9/12"></a><a href="https://leetcode-cn.com/problems/number-of-boomerangs/">447. 回旋镖的数量</a>  2021/9/12</h3><h4 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><ul><li><p>直接三重循环依次判断三个点是否组成等边三角形，然后返回值。（严重超时）</p></li><li><p>一个回旋镖可以看作三个点组成的一个等边三角形，所以要判断是否可以放置回旋镖即判断是否可以组成等边三角形，即找到两个点到同一个点的距离相同。每多一个点到顶点的距离相同，就会多两个可摆放的回旋镖（存在位置差异，n&gt;=2），即为n的排列组合。</p><center>An = n * (n - 1)</center><p>所以我们可以采用枚举的方法，依次判断所有点到其他点的距离，并用字典储存,再在最后进行判断。</p></li></ul></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">NumberOfBoomerangs</span>(<span class="params"><span class="built_in">int</span>[][] points</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//三重循环直接超时</span></span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span>[] p <span class="keyword">in</span> points)</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; cnt = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">int</span>[] q <span class="keyword">in</span> points)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> dis = (p[<span class="number">1</span>] - q[<span class="number">1</span>]) * (p[<span class="number">1</span>] - q[<span class="number">1</span>]) + (p[<span class="number">0</span>] - q[<span class="number">0</span>]) * (p[<span class="number">0</span>] - q[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!cnt.ContainsKey(dis))</span><br><span class="line">                cnt.Add(dis, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt[dis]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pair <span class="keyword">in</span> cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> m = pair.Value;</span><br><span class="line">            sum += m * (m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="524-通过删除字母匹配到字典里最长单词-2021-9-14"><a href="#524-通过删除字母匹配到字典里最长单词-2021-9-14" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词 2021/9/14"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a> 2021/9/14</h3><h4 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>题目描述不清楚，应为在第二个参数dictionary中找到最长的s的，且相同长度下字典序靠前的子字符串。</p><p>所以先将字典中的字符串按长度和字典序进行排序，然后依次判断是否为s的子串。</p><p>排序时需要先将 IList 转化为 List <code>var list = new List<string>(dictionary);</string></code> </p><p>然后使用List的Sort方法 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list.Sort((x, y) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x.Length == y.Length)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> x.CompareTo(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y.Length.CompareTo(x.Length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">FindLongestWord</span>(<span class="params"><span class="built_in">string</span> s, IList&lt;<span class="built_in">string</span>&gt; dictionary</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;(dictionary);</span><br><span class="line">    list.Sort((x, y) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(x.Length == y.Length)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span> x.CompareTo(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y.Length.CompareTo(x.Length);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> str <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.Length &amp;&amp; j &lt; s.Length)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == s[j])</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span> (i == str.Length)</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="162-寻找峰值-2021-9-15"><a href="#162-寻找峰值-2021-9-15" class="headerlink" title="162. 寻找峰值  2021/9/15"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a>  2021/9/15</h3><h4 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>该题需要时间复杂度为O(log n)，所以直接循环查找行不通。</p><p>因此需要使用二分法进行查找。</p><p>在二分查找时有四种情况</p><ul><li>nums[mid - 1] &lt; nums[mid] &lt; nums[mid + 1]，此时右边一定存在一个峰值</li><li>nums[mid - 1] &gt; nums[mid] &gt; nums[mid + 1]，此时左边一定存在一个峰值</li><li>nums[mid - 1] &gt; nums[mid] &lt; nums[mid + 1]，此时左边和右边都存在峰值</li><li>nums[mid - 1] &lt; nums[mid] &gt; nums[mid + 1]，此时mid 本生就为一个峰值</li></ul><p>对上述四种情况进行优化，可以分为两种情况，峰值在左边（右边）和峰值在右边（左边）和中间</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindPeakElement</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.Length;</span><br><span class="line">    <span class="built_in">int</span> mid;</span><br><span class="line">    <span class="built_in">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h3 id=&quot;面试题-10-02-变位词组&quot;&gt;&lt;a href=&quot;#面试题-10-02-变位词组&quot; class=&quot;headerlink&quot; title=&quot;面试题 10.02. 变位词组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://le</summary>
      
    
    
    
    <category term="每日一题" scheme="http://kennyyyyyy.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
    <category term="Leetcode" scheme="http://kennyyyyyy.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>VRTK学习记录</title>
    <link href="http://kennyyyyyy.github.io/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-06-06T11:27:43.000Z</published>
    <updated>2022-11-05T06:58:32.415Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>unity 2018.4.14<br>VRTK 3.3.0<br>steamVR 1.2.3</p><h3 id="键鼠模拟基本操作"><a href="#键鼠模拟基本操作" class="headerlink" title="键鼠模拟基本操作"></a>键鼠模拟基本操作</h3><ul><li>wasd控制人物移动</li><li>鼠标默认控制人物方向</li><li>alt切换控制模式<ul><li>鼠标：控制人物方向 —&gt;控制左右Controller的水平位置</li><li>ctrl：按住ctrl控制Controller的垂直位置</li></ul></li><li>tab切换左右Controller</li><li>ctrl 切换为抓取物体模式<ul><li>鼠标右键为右Controller抓取</li><li>鼠标左键为左Controller抓取</li></ul></li><li>shift 奔跑</li><li>q 发出射线<ul><li>鼠标右键代表Controller的扳机</li></ul></li></ul><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ol><li><p>新建场景，删除原本的Camera。</p></li><li><p>simulator为键鼠模拟；steamVr为设备操作；[VRSimulator_CameraRig]是VRTK的prefab，可直接使用；</p><p>RightController 为右控制器； LeftController 为左控制器； PlayArea 为需要传送时添加。</p><p><img src="/images/VRTK学习记录/基本结构.png" alt="基本结构"></p></li></ol><ol><li><p>VRTK SDK 需要添加VRTK_SDKManager 组件，并将子物体simulator和steamVR添加到组件中Setups的列表中（因为只需要键鼠模拟，所以只添加了simulator），然后将左右手控制器分别添加到Scripts Aliases中。</p><p><img src="/images/VRTK学习记录/VRTK_SDKManager.png" alt="Manager"></p></li></ol><ol><li><p>Simulator和SteamVR需要添加VRTK_SDK Setup 组件，并将Quick Select设置为相应的模式</p><p><img src="/images/VRTK学习记录/VRTK_SDKSetup.png" alt="Setup"></p></li></ol><h3 id="Controller相关"><a href="#Controller相关" class="headerlink" title="Controller相关"></a>Controller相关</h3><h4 id="控制器基本组件"><a href="#控制器基本组件" class="headerlink" title="控制器基本组件"></a>控制器基本组件</h4><p>​    <img src="/images/VRTK学习记录/Controller1.png" alt="Controller基本组件"></p><p>​    <img src="/images/VRTK学习记录/grab.png" alt="Controller抓取物体所需组件"></p><p>​    <img src="/images/VRTK学习记录/point.png" alt="Controller射线组件"></p><ul><li>​    射线类型可以为直线(VRTK_Straight Pointer Renderer)或贝塞尔曲线(VRTK_Bezier Pointer Renderer)</li></ul><p>​    <img src="/images/VRTK学习记录/Controller_UI.png" alt="Controller_UI"></p><ul><li>Heighlighter …. ； VRTK_UI Pointer为ui互动所必须组件</li></ul><h4 id="射线与场景互动"><a href="#射线与场景互动" class="headerlink" title="射线与场景互动"></a>射线与场景互动</h4><p>控制器上可以添加自定义脚本，使之可以与场景中的物体进行互动,脚本参考VRTK_ControllerPointerEvents_ListenerExample</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VRTK_ControllerPointerEvents_ListenerExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> showHoverState = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GetComponent&lt;VRTK_DestinationMarker&gt;() == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                VRTK_Logger.Error(VRTK_Logger.GetCommonMessage(VRTK_Logger.CommonMessageKeys.REQUIRED_COMPONENT_MISSING_FROM_GAMEOBJECT, <span class="string">&quot;VRTK_ControllerPointerEvents_ListenerExample&quot;</span>, <span class="string">&quot;VRTK_DestinationMarker&quot;</span>, <span class="string">&quot;the Controller Alias&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Setup controller event listeners</span></span><br><span class="line">            GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerEnter += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerIn);</span><br><span class="line">            <span class="keyword">if</span> (showHoverState)</span><br><span class="line">            &#123;</span><br><span class="line">                GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerHover += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerHover);</span><br><span class="line">            &#125;</span><br><span class="line">            GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerExit += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerOut);</span><br><span class="line">            GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerSet += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerDestinationSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DebugLogger</span>(<span class="params"><span class="built_in">uint</span> index, <span class="built_in">string</span> action, Transform target, RaycastHit raycastHit, <span class="built_in">float</span> distance, Vector3 tipPosition</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="built_in">string</span> targetName = (target ? target.name : <span class="string">&quot;&lt;NO VALID TARGET&gt;&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> colliderName = (raycastHit.collider ? raycastHit.collider.name : <span class="string">&quot;&lt;NO VALID COLLIDER&gt;&quot;</span>);</span><br><span class="line">            VRTK_Logger.Info(<span class="string">&quot;Controller on index &#x27;&quot;</span> + index + <span class="string">&quot;&#x27; is &quot;</span> + action + <span class="string">&quot; at a distance of &quot;</span> + distance + <span class="string">&quot; on object named [&quot;</span> + targetName + <span class="string">&quot;] on the collider named [&quot;</span> + colliderName + <span class="string">&quot;] - the pointer tip position is/was: &quot;</span> + tipPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerIn</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER IN&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerOut</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER OUT&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerHover</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER HOVER&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerDestinationSet</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER DESTINATION&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h3 id=&quot;配置环境&quot;&gt;&lt;a href=&quot;#配置环境&quot; class=&quot;headerlink&quot; title=&quot;配置环境&quot;&gt;&lt;/a&gt;配置环境&lt;/h3&gt;&lt;p&gt;unity 2018.4.14&lt;br&gt;VRTK 3.3.0&lt;br&gt;steam</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="错误总结" scheme="http://kennyyyyyy.github.io/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="经验" scheme="http://kennyyyyyy.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://kennyyyyyy.github.io/2021/04/25/Web/"/>
    <id>http://kennyyyyyy.github.io/2021/04/25/Web/</id>
    <published>2021-04-25T08:12:15.000Z</published>
    <updated>2022-11-05T06:58:35.942Z</updated>
    
    <content type="html"><![CDATA[<!--  more --><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>外部JavaScript脚本的调用：<code>&lt;script  src = &quot;../../路径&quot;&gt;&lt;/scripts&gt;</code></p><p>NaN：not a Number</p><p>逻辑运算（&amp;&amp;）：谁在表达式中起关键性作用，结果就是谁<br>例：<code>true &amp;&amp; 4 &amp;&amp; “aaa”</code><br>x输出 “aaa”</p><p>0 &nbsp;&nbsp; “0” &nbsp;&nbsp; “” &nbsp;&nbsp; null &nbsp;&nbsp; NaN &nbsp;&nbsp; undefined  =&gt; false</p><p>用 new 创建的对象为引用类型（object）</p><h2 id="预定义函数"><a href="#预定义函数" class="headerlink" title="预定义函数"></a>预定义函数</h2><p>parseInt():将字符转化为Int</p><p>eval(string):string为一个可计算的字符串或者是可执行的表达式</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>可以为一个类创建一个共有的模板<br>新new的对象会调用模板中的属性</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>cars = [“0”, 2, new Object()];</code>//数组中的元素可以不同</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join() : 将数组中的元素拼接成字符串，默认连接符为“,”</p><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>splice(index, howmany, [item1, … , itemx], item, …) : howmany为从index的位置开始删除元素的个数，后面的为插入的元素</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort(function(a,b){return b - a}); 数字的降序排列<br><br>sort(function(a,b){return a - b}); 数字的升序排列</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>unix时间戳，从1970.1.1到xxxx.xx.xx的毫秒数</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="round-四舍五入"><a href="#round-四舍五入" class="headerlink" title="round() 四舍五入"></a>round() 四舍五入</h3><h3 id="random-返回0-1的随机数"><a href="#random-返回0-1的随机数" class="headerlink" title="random() 返回0~1的随机数"></a>random() 返回0~1的随机数</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;!--  more --&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;外部JavaScript脚本的调用：&lt;code&gt;&amp;lt;script  src = &amp;quot;../../路</summary>
      
    
    
    
    <category term="Web" scheme="http://kennyyyyyy.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>TANKS! Unity Tutorial 项目学习记录</title>
    <link href="http://kennyyyyyy.github.io/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-13T15:25:35.000Z</published>
    <updated>2022-11-05T06:56:04.480Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="SmoothDamp"><a href="#SmoothDamp" class="headerlink" title="SmoothDamp"></a>SmoothDamp</h3><p>平滑的改变当前值至另一个值<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mathf.SmoothDamp(<span class="built_in">float</span> current, <span class="built_in">float</span> target, <span class="keyword">ref</span> <span class="built_in">float</span> currentVelocity, <span class="built_in">float</span> smoothTime, <span class="built_in">float</span> maxSpeed = Mathf.Infinity, <span class="built_in">float</span> deltaTime = Time.deltaTime);</span><br><span class="line"></span><br><span class="line"><span class="function">Vector3 <span class="title">SmoothDamp</span>(<span class="params">Vector3 current, Vector3 target, <span class="keyword">ref</span> Vector3 currentVelocity, <span class="built_in">float</span> smoothTime, <span class="built_in">float</span> maxSpeed = Mathf.Infinity, <span class="built_in">float</span> deltaTime = Time.deltaTime</span>)</span>;</span><br></pre></td></tr></table></figure></p><font color="#c77eb5" size="2"> *current*：当前位置 </font><font color="#c77eb5" size="2"> *target*：尝试达到的目标值 </font><font color="#c77eb5" size="2"> *currentVelocity*：当前速度，该值在每次调用时都会由函数修改。</font><font color="#c77eb5" size="2"> *smoothTime*：达到目标值的时间 </font><font color="#c77eb5" size="2"> *maxSpeed*：最大速度 </font><font color="#c77eb5" size="2"> *deltaTime*：默认为Time.deltatime </font><font color="#c77eb5" size="2"> *ref关键字*：相当于c的指针传参，及引用传参。 </font><h3 id="InverseTransformPoint"><a href="#InverseTransformPoint" class="headerlink" title="InverseTransformPoint"></a>InverseTransformPoint</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">InverseTransformPoint</span>(<span class="params">Vector3 position</span>)</span>;</span><br></pre></td></tr></table></figure><p>将position这个Vector3类型变量转化为 以V3的世界坐标为零点基准的情况下 position相对于V3的坐标值。</p><h3 id="Physics"><a href="#Physics" class="headerlink" title="Physics"></a>Physics</h3><h4 id="Physics-OverlapSphere"><a href="#Physics-OverlapSphere" class="headerlink" title="Physics.OverlapSphere"></a>Physics.OverlapSphere</h4><p>检测范围内的Collider<br><code> public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal);</code></p><font color="#c77eb5" size="2"> *position*：圆心 </font><font color="#c77eb5" size="2"> *radius*：检测半径 </font><font color="#c77eb5" size="2"> *layerMask*：检测层级 </font><font color="#c77eb5" size="2"> *queryTriggerInteraction*：判断是否应该检测Trigger </font><h3 id="Rigidbody"><a href="#Rigidbody" class="headerlink" title="Rigidbody"></a>Rigidbody</h3><h4 id="targetRigidbody-AddExplosionForce"><a href="#targetRigidbody-AddExplosionForce" class="headerlink" title="targetRigidbody.AddExplosionForce"></a>targetRigidbody.AddExplosionForce</h4><p>爆炸力将随着到物体的距离变小。<br><code> public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)); </code></p><font color="#c77eb5" size="2"> *explosionForce*：爆炸的力量（会根据距离变化）</font><font color="#c77eb5" size="2"> *explosionPosition*：爆炸中心 </font><font color="#c77eb5" size="2"> *explosionRadius*：爆炸半径 </font><font color="#c77eb5" size="2"> *upwardsModifier*：可以调整爆炸的位置，让物体有被炸起来向上的效果，但爆炸本身的位置不变 </font><font color="#c77eb5" size="2"> *ForceMode*：对物体施加力的方法 </font><h2 id="Manual"><a href="#Manual" class="headerlink" title="Manual"></a>Manual</h2><h3 id="相机的两种投影方式"><a href="#相机的两种投影方式" class="headerlink" title="相机的两种投影方式"></a>相机的两种投影方式</h3><p><img src="/images/Tanks项目学习记录/00.jpg" alt="相机的两种投影方式(prejection)"></p><p>透视投影(Perspective)(左): 正交投影的观察体是长方体，它使用一组平行投影将三维对象投影到投影平面上去，即场景中的物体没有近大远小的效果。</p><p>正交投影(Orthographic)(右): 透视投影的观察体是视锥体，它使用一组由投影中心产生的放射投影线，将三维对象投影到投影平面上去，即屏幕中的物体存在透视效果</p><h3 id="Aodio-Mixer"><a href="#Aodio-Mixer" class="headerlink" title="Aodio Mixer"></a>Aodio Mixer</h3><p>类似于Windows的音量合成器，但更为复杂<br>可以用来进行多种音效的混合表现<br>要用可百度学习</p><h2 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h2><h3 id="移动和旋转问题"><a href="#移动和旋转问题" class="headerlink" title="移动和旋转问题"></a>移动和旋转问题</h3><p>有问题的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 move = Vector3.forward * m_MovementInputValue * Time.deltaTime * m_Speed;</span><br><span class="line">m_Rigidbody.MovePosition(m_Rigidbody.position + move);</span><br></pre></td></tr></table></figure><p>此代码会导致物体旋转后会继续以世界坐标的z轴为前后方向，而导致旋转看起来不起作用，像坐标轴没有跟着旋转一样</p><hr><p>正确的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 move = transform.forward * m_MovementInputValue * Time.deltaTime * m_Speed;</span><br><span class="line">m_Rigidbody.MovePosition(m_Rigidbody.position + move);</span><br></pre></td></tr></table></figure><p>修改后一切正常</p><hr><div class="panel panel-warning">    <div class="panel-title">Vector3.forward和transform.forward的区别</div>    <div class="panel-body">        <p>Vector3.forward的值永远是世界坐标（0,0,1），<br>而transform.forward是世界坐标对应的物体坐标的轴的向量</p>    </div>    </div><h2 id="代码记录"><a href="#代码记录" class="headerlink" title="代码记录"></a>代码记录</h2><h3 id="相机的平滑运动"><a href="#相机的平滑运动" class="headerlink" title="相机的平滑运动"></a>相机的平滑运动</h3><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>移动相关</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FindAveragePosition();</span><br><span class="line"></span><br><span class="line">    transform.position = Vector3.SmoothDamp(transform.position, m_DesiredPosition, <span class="keyword">ref</span> m_MoveVelocity, m_DampTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 找到多个Player的中间位置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FindAveragePosition</span>(<span class="params"></span>)                      </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3 averagePos = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录还存在的Player的数量</span></span><br><span class="line">    <span class="built_in">int</span> numTargets = <span class="number">0</span>;                                 </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_Targets.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_Targets[i].gameObject.activeSelf)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录Player的位置和</span></span><br><span class="line">        averagePos += m_Targets[i].position;            </span><br><span class="line">        numTargets++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到中间位置</span></span><br><span class="line">    <span class="keyword">if</span> (numTargets &gt; <span class="number">0</span>)                              </span><br><span class="line">        averagePos /= numTargets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证相机的y轴不移动</span></span><br><span class="line">    averagePos.y = transform.position.y;               </span><br><span class="line"></span><br><span class="line">    m_DesiredPosition = averagePos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>缩放相关</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Zoom</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">float</span> requiredSize = FindRequiredSize();</span><br><span class="line">    m_Camera.orthographicSize = Mathf.SmoothDamp(m_Camera.orthographicSize, requiredSize, <span class="keyword">ref</span> m_ZoomSpeed, m_DampTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 找到需要的相机的最大大小</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回相机的合适大小<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">float</span> <span class="title">FindRequiredSize</span>(<span class="params"></span>)                    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获得相机将要到达的位置的相对坐标</span></span><br><span class="line">    Vector3 desiredLocalPos = transform.InverseTransformPoint(m_DesiredPosition);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> size = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得还存活的Player的所需要的屏幕最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_Targets.Length; i++)                                      </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_Targets[i].gameObject.activeSelf)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转化Player的坐标为相对值</span></span><br><span class="line">        Vector3 targetLocalPos = transform.InverseTransformPoint(m_Targets[i].position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Player中心位置与Player位置的差值</span></span><br><span class="line">        Vector3 desiredPosToTarget = targetLocalPos - desiredLocalPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算x/y轴的相对大小，并取最大值</span></span><br><span class="line">        size = Mathf.Max (size, Mathf.Abs (desiredPosToTarget.y));                  </span><br><span class="line"></span><br><span class="line">        size = Mathf.Max (size, Mathf.Abs (desiredPosToTarget.x) / m_Camera.aspect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加缓冲区</span></span><br><span class="line">    size += m_ScreenEdgeBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止屏幕缩小</span></span><br><span class="line">    size = Mathf.Max(size, m_MinSize);                                              </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><h3 id="炮弹的爆炸和伤害判定"><a href="#炮弹的爆炸和伤害判定" class="headerlink" title="炮弹的爆炸和伤害判定"></a>炮弹的爆炸和伤害判定</h3><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>爆炸相关</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得爆炸范围内的坦克collider</span></span><br><span class="line">    Collider[] colliders = Physics.OverlapSphere(transform.position, m_ExplosionRadius, m_TankMask);<span class="comment">//获得爆炸范围内的坦克collider</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Rigidbody targetRigidbody = colliders[i].GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!targetRigidbody)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对范围内的tank的刚体施加一个力</span></span><br><span class="line">        targetRigidbody.AddExplosionForce(m_ExplosionForce, transform.position, m_ExplosionRadius);<span class="comment">//将</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Tank的血量属性</span></span><br><span class="line">        TankHealth tankHealth = targetRigidbody.GetComponent&lt;TankHealth&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tankHealth)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算伤害</span></span><br><span class="line">        <span class="built_in">float</span> damage = CalculateDamage(targetRigidbody.position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//造成伤害</span></span><br><span class="line">        tankHealth.TakeDamage(damage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//粒子效果和声音的播放</span></span><br><span class="line">    m_ExplosionParticles.transform.parent = <span class="literal">null</span>;</span><br><span class="line">    m_ExplosionParticles.Play();</span><br><span class="line">    m_ExplosionAudio.Play();</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">    Destroy(m_ExplosionParticles.gameObject, m_ExplosionParticles.main.duration);</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>计算伤害</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">float</span> <span class="title">CalculateDamage</span>(<span class="params">Vector3 targetPosition</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算Tank和炸弹的向量</span></span><br><span class="line">    Vector3 explosionToTarget = targetPosition - transform.position;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得距离</span></span><br><span class="line">    <span class="built_in">float</span> explosionDistance = explosionToTarget.magnitude;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算相对距离比例</span></span><br><span class="line">    <span class="built_in">float</span> relativeDistance = (m_ExplosionRadius - explosionDistance) / m_ExplosionRadius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算伤害</span></span><br><span class="line">    <span class="built_in">float</span> damage = relativeDistance * m_MaxDamage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排除Tank在边缘时 相对比例 为负数的情况</span></span><br><span class="line">    damage = Mathf.Max(<span class="number">0</span>, damage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> damage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>     </div></div>    </div><h2 id="子弹的对象池模式"><a href="#子弹的对象池模式" class="headerlink" title="子弹的对象池模式"></a>子弹的对象池模式</h2><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>子弹</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShellExplosion</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPooler</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ...一些其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成时的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSpawning</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="comment">/* 初始化相关 */</span></span><br><span class="line">        StartCoroutine(Spawning());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用协程，一定时间后重置</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Spawning</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> m_TimeToFalse;</span><br><span class="line">        m_ExplosionParticles.transform.parent = gameObject.transform;</span><br><span class="line">        m_ExplosionParticles.transform.position = gameObject.transform.position;</span><br><span class="line">        gameObject.transform.position = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>对象池</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShellPool</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对象池</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> tag:名称</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> prefab;预制体</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> size:对象池的大小</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pool</span>                          </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> tag;</span><br><span class="line">        <span class="keyword">public</span> GameObject prefab;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象池的父物体</span></span><br><span class="line">    <span class="keyword">public</span> Transform parentTransform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Pool&gt; poolList;</span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, Queue&lt;GameObject&gt;&gt; poolDictionary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ShellPool shellPoolInsatance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shellPoolInsatance == <span class="literal">null</span>)</span><br><span class="line">            shellPoolInsatance = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (shellPoolInsatance != <span class="keyword">this</span>)</span><br><span class="line">            Destroy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化生成所有对象池的物体，并添加到对象池字典中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        poolDictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Queue&lt;GameObject&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> pool <span class="keyword">in</span> poolList)</span><br><span class="line">        &#123;</span><br><span class="line">            Queue&lt;GameObject&gt; tPool = <span class="keyword">new</span> Queue&lt;GameObject&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pool.size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                GameObject tShell = Instantiate(pool.prefab, parentTransform,<span class="literal">true</span>);</span><br><span class="line">                tShell.SetActive(<span class="literal">false</span>);</span><br><span class="line">                tPool.Enqueue(tShell);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            poolDictionary.Add(pool.tag, tPool);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 从对象池中生成（获得）物体</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;tag&quot;&gt;</span>物体名称<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;position&quot;&gt;</span>生成位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rotation&quot;&gt;</span>生成旋转<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回生成的对象<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">SpawnFromPool</span>(<span class="params"><span class="built_in">string</span> tag, Vector3 position, Quaternion rotation</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断是否存在需要生成的物体</span></span><br><span class="line">        <span class="keyword">if</span>(!poolDictionary.ContainsKey(tag))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(tag + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GameObject theSpawnObj = poolDictionary[tag].Dequeue();</span><br><span class="line">        Debug.Log(theSpawnObj);</span><br><span class="line"></span><br><span class="line">        theSpawnObj.SetActive(<span class="literal">true</span>);</span><br><span class="line">        theSpawnObj.transform.position = position;</span><br><span class="line">        theSpawnObj.transform.rotation = rotation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得IPooler接口，并调用初始化函数</span></span><br><span class="line">        IPooler poolSpawn = theSpawnObj.GetComponent&lt;IPooler&gt;();</span><br><span class="line">        <span class="keyword">if</span> (poolSpawn != <span class="literal">null</span>)</span><br><span class="line">            poolSpawn.OnSpawning();</span><br><span class="line"></span><br><span class="line">        poolDictionary[tag].Enqueue(theSpawnObj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> theSpawnObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>IPooler</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口，方便生成物体后的初始化函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IPooler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSpawning</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><h3 id="游戏循环模式-协程完成"><a href="#游戏循环模式-协程完成" class="headerlink" title="游戏循环模式(协程完成)"></a>游戏循环模式(协程完成)</h3><p><img src="/images/Tanks项目学习记录/游戏循环.jpg" alt="循环模式"><br><img src="/images/Tanks项目学习记录/流程控制.jpg" alt="Tanks的流程控制"></p><h3 id="游戏管理模式"><a href="#游戏管理模式" class="headerlink" title="游戏管理模式"></a>游戏管理模式</h3><p>一些游戏物体的代码不需要继承MonoBehaviour（无需挂载），只当实例化后赋予其GameObject或直接更具里面的信息实例化一个物体。例如此例中的Tank 或者 一些随机地图的部分地图信息</p><h3 id="可能的心得-……"><a href="#可能的心得-……" class="headerlink" title="可能的心得(……..)"></a>可能的心得(……..)</h3><ul><li>协程内调用多个协程，只会在上一个协程调用完成后，下一个协程才会开始</li><li>回合制的游戏可以使用协程控制游戏流程，开始、游玩、结束，都很清晰明了</li><li>写代码时因该将所有功能块写成函数，可以让代码结构更清晰</li><li>尽量将可能的变量全定义在类的开头，理由同上</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h2&gt;&lt;h3 id=&quot;SmoothDamp&quot;&gt;&lt;a href=&quot;#SmoothDamp&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>部署网站的记录</title>
    <link href="http://kennyyyyyy.github.io/2021/04/13/Demo/"/>
    <id>http://kennyyyyyy.github.io/2021/04/13/Demo/</id>
    <published>2021-04-13T08:56:13.000Z</published>
    <updated>2022-11-05T06:58:22.476Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="网页属性"><a href="#网页属性" class="headerlink" title="网页属性"></a>网页属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建时间</span><br><span class="line">categories: 分类</span><br><span class="line">tags:标签</span><br><span class="line">- Tag0</span><br><span class="line">- Tag1</span><br><span class="line">- Tag2</span><br><span class="line">sticky: 100数字越大优先级越高</span><br><span class="line">pic:指定预览图片，图片位置为同级目录下的同名文件夹</span><br><span class="line">comments: <span class="literal">true</span>是否开放评论</span><br><span class="line">toc: <span class="literal">true</span>是否生成目录</span><br><span class="line">only:在什么位置显示，如果没有就全部显示</span><br><span class="line">- home</span><br><span class="line">- category</span><br><span class="line">- tag</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>提示信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% alertbox success <span class="string">&quot;成功&quot;</span> %&#125;</span><br><span class="line">&#123;% alertbox danger <span class="string">&quot;危险&quot;</span> %&#125;</span><br><span class="line">&#123;% alertbox info <span class="string">&quot;消息&quot;</span> %&#125;</span><br><span class="line">&#123;% alertbox warning <span class="string">&quot;警告&quot;</span> %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="折叠相关"><a href="#折叠相关" class="headerlink" title="折叠相关"></a>折叠相关</h3><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>折叠的折叠框</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% collapse 折叠框的标题 %&#125;</span><br><span class="line"></span><br><span class="line">被折叠的内容 1</span><br><span class="line">被折叠的内容 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;% endcollapse %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl active">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>预先打开的折叠框</span></div>    <div class="xContent pre-open"><div class="inner">        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% collapse 折叠框的标题 open %&#125;</span><br><span class="line"></span><br><span class="line">被折叠的内容 1</span><br><span class="line">被折叠的内容 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;% endcollapse %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><div class="panel panel-info">    <div class="panel-title">提示框</div>    <div class="panel-body">        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% colorpanel TYPE 面板框的标题 %&#125;</span><br><span class="line"></span><br><span class="line">面板里的内容 1</span><br><span class="line">面板里的内容 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;% endcolorpanel %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>type是框的类型<br>·successs<br>·danger<br>·info<br>·warning</p>    </div>    </div><h3 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h3><p>图片需要放在source文件夹下的images下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](/images/图片名称.jpg)  </span><br><span class="line"></span><br><span class="line">![图片描述](/images/文件夹/图片名称.jpg) </span><br></pre></td></tr></table></figure></p><p><img src="/images/Demo/00.jpg" alt="图片插入"> </p><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=<span class="comment">#00ffff&gt;color=#00ffff&lt;/font&gt;</span></span><br></pre></td></tr></table></figure><font color="#00ffff">color=#00ffff</font><p><a href="https://www.5tu.cn/colors/yansebiao.html">颜色表参考</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://candinya.com/posts/Kratos-Rebirth-Manual/#%E5%AE%89%E8%A3%85%E6%8F%90%E7%A4%BA">部分参考来源</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;h3 id=&quot;网页属性&quot;&gt;&lt;a href=&quot;#网页属性&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="错误总结" scheme="http://kennyyyyyy.github.io/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="经验" scheme="http://kennyyyyyy.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
