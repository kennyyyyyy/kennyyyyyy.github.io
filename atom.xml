<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Imperio</title>
  
  <subtitle>Boy♂ Next♂ Door~</subtitle>
  <link href="http://kennyyyyyy.github.io/atom.xml" rel="self"/>
  
  <link href="http://kennyyyyyy.github.io/"/>
  <updated>2022-08-20T07:14:04.532Z</updated>
  <id>http://kennyyyyyy.github.io/</id>
  
  <author>
    <name>kennyyy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔试题记录</title>
    <link href="http://kennyyyyyy.github.io/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-08-19T14:13:21.000Z</published>
    <updated>2022-08-20T07:14:04.532Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ol><li><p><strong>从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Material material = Render.materials;</span><br><span class="line">material.shader = targetShader;</span><br><span class="line"><span class="comment">//修改 Shader 中参数的值：</span></span><br><span class="line">material.SetFloat(“参数名”，值); </span><br><span class="line">material.SetColor(“参数名”，颜色值); </span><br><span class="line">material.SetTexture(“参数名”，贴图); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Shader 中参数的值：</span></span><br><span class="line">material.GetFloat(“参数名”);</span><br><span class="line">material.GetColor(“参数名”); </span><br><span class="line">material.GetTexture(“参数名”); </span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>给定一个数组，有n(n &gt;= 0)个元素，找到数组中第二大的元素</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1 5 9 2 1 6 4 2 3 9</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetScendNum</span>(<span class="params"><span class="built_in">int</span>[] number, <span class="built_in">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> first=number[<span class="number">0</span>],second=number[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(number[i]&gt;first)&#123;</span><br><span class="line">            second=first;</span><br><span class="line">            first=number[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i]&gt;second)</span><br><span class="line">                second=number[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 若第二和第一相等，则将当前值赋予第二</span></span><br><span class="line">                second = first==second ? number[i] : second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>oop的四个特征： 抽象、封装、继承、多态</strong></p><ul><li>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。</li><li>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。这也体现了大自然中一般与特殊的关系。继承性很好的解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。</li><li>封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。</li><li>多态性是指允许不同类的对象对同一消息作出响应。比如同样的加法，把两个时间加在一起和把两个整数加在一起肯定完全不同。又比如，同样的选择编辑-粘贴操作，在字处理程序和绘图程序中有不同的效果。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</li></ul></li><li><p><strong>AssetBundle的打包和加载</strong></p></li></ol><ol><li><p><strong>反射的作用。动态创建一个数据集，并获得其类型T，调用T的Create函数。</strong></p><ul><li>.NET的一个强大功能是它可以通过一种称为反射(reflection)的过程访问应用程序的元数据。简单地说，反射就是运行时查询类型信息的能力</li><li>基本用法：一是用反射来创建实例，二是用反射调用实例的方法，三是用反射调用实例的属性。<ul><li></li></ul></li></ul></li><li><p><strong>迭代器和数组的区别</strong></p><p>迭代器：<strong>迭代器</strong>（iterator）有时又称<strong>光标</strong>（cursor）是程序设计的<a href="https://baike.baidu.com/item/软件设计模式">软件设计模式</a>，可在容器对象（container，例如<a href="https://baike.baidu.com/item/链表">链表</a>或<a href="https://baike.baidu.com/item/数组">数组</a>）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。</p><ul><li><p><a href="https://blog.csdn.net/lx2054807/article/details/107981276?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107981276-blog-123304449.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107981276-blog-123304449.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=2">C#</a> </p><ul><li><p>迭代器模式 指按照一定顺序来访问一个集合对象中的每个元素, 但是同时不会暴露集合对象的内部结构. C#中内置的迭代器模式就是Foreach语句, 它可以顺序遍历容器中的每个元素. 而迭代器的具体实现主要是靠IEnumerable 和IEnumerator.</p></li><li><h4 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h4><p>IEnumerator接口其实就是<a href="https://so.csdn.net/so/search?q=foreach&amp;spm=1001.2101.3001.7020">foreach</a>的具体实现, 它只定义了三个函数, 如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们实现一个最简单的IEnumerator接口只需要实现这三个函数即可. MoveNext()表示向集合中的下一个元素移动, 如果有下一个元素返回true, 没有就返回false. Current是一个只读属性, 返回当前迭代器所指元素. Reset()表示重置迭代器到第一个元素.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIEnumerator</span>: <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        count = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的IEnumerator, 如果用Foreach输出, 可以得到从9到0的十个计数. 而具体的实现过程还需要IEnumerable.</p></li><li><h4 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h4><p>IEnumerable可以粗略的理解为可迭代(遍历)的, 如果接口继承了IEnumerable, 那么就可以使用Foreach语句进行迭代操作. 这个接口只定义了一个函数, 如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数需要返回一个我们刚才定义的IEnumerator, 即告知上层调用方可以枚举.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIEnumerable</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个时候我们的迭代器已经实现, 可以使用Foreach语句进行迭代操作.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> VARIABLE <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">MyIEnumerable</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(VARIABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在有一个完整的迭代器了, 但是有一个问题, 很多时候我们需要的迭代器并不复杂, 如上面的计数装置, 如果每次都需要实现IEnumerator和IEnumerable十分不方便, 显得头重脚轻, 这时我们可以使用yield.</p></li><li><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>yield是为了方便使用迭代器而产生的语法糖, 他可以直接使用在返回类型为IEnumerable或IEnumerator的函数中直接实现迭代器操作. 它有两种用法yield break 和yield return (something) 效果和break与return一样. 当使用yield return在foreach语句中进行迭代器操作时, 每一次执行到yield return时都会返回后面定义的something并且记录函数内的信息, 下一次运行时继续.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> VARIABLE <span class="keyword">in</span> <span class="title">myIEnumerable</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(VARIABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable <span class="title">myIEnumerable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  这里我们在i = 5的时候使用了yield break终止了迭代器操作, 如果去掉它, 这个函数就和我们刚才定义的迭代器作用一样, 产生了9到0, 共10个数的倒数.</p><ul><li><h4 id="协程-coroutine"><a href="#协程-coroutine" class="headerlink" title="协程(coroutine)"></a>协程(coroutine)</h4><p>除了foreach语句, Unity中另一种迭代器模式就是协程, 它是根据每一次IEnumerator的MoveNext()方法调用进行迭代的, 有些类似于Unity的Update方法. 同时它可以结合Unity的yield return new WaitForSeconds(time)等等接口实行迭代器+定时器模式.<br>使用和停止协程比较简单, 都只要传入IEnumerator就可以.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Coroutine <span class="title">StartCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br></pre></td></tr></table></figure><p>使用协程的方法实现我们的从9数到0.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StartCoroutine(myCoroutine());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">myCoroutine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(i);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">myCoroutine(</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  值得注意的是unity里有很多可以和yield结合使用的语句块, 如上的代码不仅实现了从9数到0, 还实现了每隔1秒数一次, 数到0后继续从头开始数, 当然还有很多其他有趣的功能可以通过coroutine和yield实现.</p></li></ul></li></ul></li><li><p><strong>多态的作用。多态和传统类型Boxing/UnBoxing的区别</strong></p></li></ol><ol><li><p><strong>当你接手一个新项目，当运行一段时间后，发现内存占用高且帧率低，如何解决</strong></p></li><li><p><strong>如何获得Prefab的GameObject类型，PrefabInstance和ModelPrefabInstance的区别</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果&lt;/strong&gt;&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>热更新</title>
    <link href="http://kennyyyyyy.github.io/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://kennyyyyyy.github.io/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2022-08-16T01:41:04.000Z</published>
    <updated>2022-08-16T02:25:21.091Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><hr><h4 id="资源目录划分"><a href="#资源目录划分" class="headerlink" title="资源目录划分"></a>资源目录划分</h4><p><img src="/images/热更新/资源目录划分.png" alt="image-20220816102442776"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;hr&gt;
&lt;h4 id=&quot;资源目录划分&quot;&gt;&lt;a href=&quot;#资源目录划分&quot; class=&quot;headerlink&quot; title=&quot;资源目录划分&quot;&gt;&lt;/a&gt;资源目录划分&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/热更新/资源目</summary>
      
    
    
    
    
    <category term="Lua" scheme="http://kennyyyyyy.github.io/tags/Lua/"/>
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
    <category term="xlua" scheme="http://kennyyyyyy.github.io/tags/xlua/"/>
    
  </entry>
  
  <entry>
    <title>Lua学习</title>
    <link href="http://kennyyyyyy.github.io/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/"/>
    <id>http://kennyyyyyy.github.io/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-08-12T02:30:23.000Z</published>
    <updated>2022-08-16T01:40:18.024Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><a href="https://www.runoob.com/manual/lua53doc/contents.html">Lua5.3参考手册</a></p><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><ol><li><p><strong>变量</strong></p><ul><li>动态类型 弱类型 大小写敏感 默认全局 带GC</li><li>类型：nil、boolean、number、string、function、userdata(用户自定义类型)、tread、table</li><li></li></ul></li></ol><ol><li><p><strong>语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 赋值 --</span></span><br><span class="line">a,b = <span class="string">&quot;hello&quot;</span>, <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of a = &quot;</span>, <span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of b = &quot;</span>, <span class="built_in">type</span>(b))</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    多行注释 d </span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"><span class="comment">-- 交换 --</span></span><br><span class="line">a,b = b,a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分支 if  boolean: false、nil。 0 != false</span></span><br><span class="line"><span class="keyword">if</span> b == <span class="number">15</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b = 15&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> b ~= <span class="number">16</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b != 15&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)        </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 循环： 有break 无continue</span></span><br><span class="line"><span class="comment">-- for 起始，终值，增值</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> ,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- while</span></span><br><span class="line">d = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> d &lt;= <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line">    d = d + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- repeat until (do while)</span></span><br><span class="line"></span><br><span class="line">ans = <span class="number">15</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;guess the password (little than 100)&quot;</span>)</span><br><span class="line">    a =<span class="built_in">tonumber</span>(<span class="built_in">io</span>.<span class="built_in">read</span>())</span><br><span class="line">    <span class="keyword">if</span> a == ans <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You are right!&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elseif</span> a &gt; ans <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(a,<span class="string">&quot;Too big&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(a,<span class="string">&quot;Too small&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">until</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数学运算  + -  *  /(//)    %   ^</span></span><br><span class="line"><span class="comment">--         加 减 乘 除(取整) 取余 幂</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;5^3 = &quot;</span>, <span class="number">5</span>^<span class="number">3</span>)</span><br><span class="line"><span class="comment">-- 关系运算 &gt; &lt; &gt;= &lt;= == ~=(不等)</span></span><br><span class="line"><span class="comment">-- 逻辑运算 and(&amp;&amp;) or(||) not(!)</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>数据结构 Table</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table</span></span><br><span class="line"><span class="comment">-- 下标从一开始</span></span><br><span class="line"><span class="comment">-- 可以看作为键值对，没有键值，则默认的位置下标为键值(去掉中间存在键值的)</span></span><br><span class="line"><span class="comment">-- table.key or talbe[&quot;key&quot;]</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,pos =&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;ddd&quot;</span>, [<span class="string">&quot;z&quot;</span>] = <span class="string">&quot;zz&quot;</span>&#125;, x = <span class="number">123</span>, y = <span class="number">456</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;x&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a.y)</span><br><span class="line"><span class="built_in">print</span>(a.pos.z)  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(k) == <span class="built_in">table</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(k) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">print</span>(key, <span class="string">&quot;:&quot;</span>, val)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(k, <span class="string">&quot;:&quot;</span>, v);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>function 函数</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- function </span></span><br><span class="line"><span class="comment">-- 有多个值返回的，从第一个返回的值开始接收，多余的丢弃</span></span><br><span class="line">add = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a + b    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a - b, a * b, <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ans1, ans2 = func(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(ans1, ans2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 高阶函数 第一类(first class)</span></span><br><span class="line"><span class="comment">-- 即返回值或参数为函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span><span class="params">(f, a, b)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;f(a,b)&quot;</span>, f(a,b))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p(func, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 变参 #v == length(v)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">local</span> args = &#123;...&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(args) <span class="keyword">do</span></span><br><span class="line">        sum = sum + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> #args, sum</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>运算符</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 运算符</span></span><br><span class="line"><span class="comment">-- # 求长度 : 用于普通数组，用于表不准确，存在未定义事件(下标不连续，不是整数等)，无法计算长度</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">nil</span>, x = <span class="string">&quot;ss&quot;</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接符 .. 性能消耗大</span></span><br><span class="line">a = <span class="string">&quot;ab&quot;</span></span><br><span class="line">b = <span class="string">&quot;cd&quot;</span></span><br><span class="line">c = a..b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑运算符 and or not (与其他语言基本一致)</span></span><br><span class="line"><span class="comment">-- 优先级 and &gt; or</span></span><br><span class="line"><span class="comment">-- 右结合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>^<span class="number">3</span>^<span class="number">2</span>) <span class="comment">-- &lt;--(2^(3^2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 位运算 &amp;  |  ~  ~    &gt;&gt; &lt;&lt;</span></span><br><span class="line"><span class="comment">--       与 或 非 异或  位运算</span></span><br><span class="line"><span class="comment">-- 3 0011</span></span><br><span class="line"><span class="comment">-- 5 0101</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>~<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>函数库：例</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &quot;&quot;有转译， [[]]无转义</span></span><br><span class="line">a = <span class="string">&quot;a\nb\\c 0b110&quot;</span></span><br><span class="line">b = <span class="string">[[d \ \ \ \ \ cdca\c\]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">&quot;,&quot;</span>, b)</span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">upper</span>(a))</span><br><span class="line"><span class="built_in">print</span>(b:<span class="built_in">upper</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">--string 正则匹配与标准不完全一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--table</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(a, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(a, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(a)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&quot;:&quot;</span>, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">table</span>.<span class="built_in">concat</span>(a, <span class="string">&quot;+&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--math</span></span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>协程</strong></p><p><img src="/images/Lua学习/协程执行流程.png" alt="协程执行流程"></p><p><img src="/images/Lua学习/协程状态转换.png" alt="协程状态转换"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 协程：与Unity协程基本一致，执行到yield，下次执行从yeild后继续</span></span><br><span class="line"><span class="comment">-- thread 线程 协程 进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--type(co) = thread</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;coroutine running...&quot;</span>)</span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;coroutine continue...&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 运行协程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br><span class="line">        v1,v2 = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;v1 = &quot;</span>, v1, <span class="string">&quot;v2 = &quot;</span>, v2)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line">a1,a2,a3 = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a1, a2, a3)   <span class="comment">-- a1：执行结果(成功/失败) a2，a3(yield返回值)</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">-- 第二次调用时传入的参数会作为yeild的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- type(func) == function</span></span><br><span class="line">func = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>OO 面向对象</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 简易面向对象实现代码</span></span><br><span class="line"><span class="comment">-- 定义对象</span></span><br><span class="line"><span class="keyword">local</span> Monster = &#123;</span><br><span class="line">    name = <span class="string">&quot;Monster&quot;</span>,</span><br><span class="line">    HP = <span class="number">100</span>,</span><br><span class="line">    pos = &#123;x = <span class="number">10</span>, y = <span class="number">10</span>&#125;,</span><br><span class="line">    TakeDamage = <span class="function"><span class="keyword">function</span><span class="params">(self, damage)</span></span></span><br><span class="line">        <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">local</span> Monster2 = &#123;HP = <span class="number">200</span>&#125;</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">-- 增加方法,传入对象</span></span><br><span class="line"><span class="comment">    Monster.TakeDamage = function(self, damage)</span></span><br><span class="line"><span class="comment">        self.HP = self.HP - damage    </span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    function Monster:TakeDamage(damage)</span></span><br><span class="line"><span class="comment">        self.HP = self.HP - damamge</span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line">Monster.TakeDamage(Monster2, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(Monster.HP)</span><br><span class="line"><span class="built_in">print</span>(Monster2.HP)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Monster.TakeDamage(Monster, 10),即将Monster作为TakeDamage的第一个参数</span></span><br><span class="line">Monster:TakeDamage(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">------------------------------------------</span></span><br><span class="line"><span class="comment">-- 定义类</span></span><br><span class="line"><span class="comment">-- 通过原表</span></span><br><span class="line">CMonster = &#123;</span><br><span class="line">    name = <span class="string">&quot;Monster&quot;</span>,</span><br><span class="line">    HP = <span class="number">1000</span>,</span><br><span class="line">    TakeDamage = <span class="function"><span class="keyword">function</span><span class="params">(self, damage)</span></span></span><br><span class="line">        <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjMonster = &#123;pos = &#123;x = <span class="number">10</span>, y = <span class="number">10</span>&#125;&#125;</span><br><span class="line"><span class="comment">-- 设置原表  -- 该值或加值，调用的是__newindex</span></span><br><span class="line"><span class="built_in">setmetatable</span>(</span><br><span class="line">    ObjMonster, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">__index</span> = CMonster,</span><br><span class="line">        <span class="built_in">__newindex</span> = CMonster   <span class="comment">-- 若__newindex = CMonster 则修改会影响原表</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(ObjMonster.HP)</span><br><span class="line">ObjMonster.HP = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义new 方法，用于新建对象</span></span><br><span class="line">CMonster = &#123;</span><br><span class="line">    name = <span class="string">&quot;Monster&quot;</span>,</span><br><span class="line">    HP = <span class="number">1000</span>,</span><br><span class="line">    TakeDamage = <span class="function"><span class="keyword">function</span><span class="params">(self, damage)</span></span></span><br><span class="line">        <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line">    <span class="keyword">end</span> ,</span><br><span class="line">    Show = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">self</span>.name, <span class="string">&quot;:&quot;</span>, <span class="built_in">self</span>.HP, <span class="string">&quot;:&quot;</span>, <span class="built_in">self</span>.x, <span class="string">&quot;;&quot;</span>, <span class="built_in">self</span>.y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 设置CMonster的__index， 设置原表时就不需要新建一个表来设置__index了</span></span><br><span class="line">CMonster.<span class="built_in">__index</span> = CMonster </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CMonster:new</span><span class="params">(name, hp, x, y)</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    obj.HP = hp</span><br><span class="line">    obj.x = x</span><br><span class="line">    obj.y = y</span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, CMonster)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置CMonster的原表，使其调用可以直接使用 () 来调用new或其他函数  </span></span><br><span class="line"><span class="built_in">setmetatable</span>(CMonster, &#123;<span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, name, hp, x, y)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>:new(name, hp, x, y)</span><br><span class="line"><span class="keyword">end</span>&#125;)</span><br><span class="line"></span><br><span class="line">obj1 = CMonster(<span class="string">&quot;mon&quot;</span>, <span class="number">300</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">obj1:Show()</span><br><span class="line">obj1:TakeDamage(<span class="number">250</span>)</span><br><span class="line">obj1:Show()</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>类的继承的简单实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 继承</span></span><br><span class="line"><span class="comment">-- 引用上一个文件的CMonster类</span></span><br><span class="line"><span class="keyword">local</span> Cm = <span class="built_in">require</span>(<span class="string">&quot;t6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> obj1 = Cm(<span class="string">&quot;Monster&quot;</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">obj1:Show()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个新类</span></span><br><span class="line"><span class="keyword">local</span> MMonster = &#123;</span><br><span class="line">    MP = <span class="number">200</span>,</span><br><span class="line">    Attack = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Attacking...&quot;</span>)</span><br><span class="line">        <span class="built_in">self</span>.MP = <span class="built_in">self</span>.MP - <span class="number">10</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义其原表未Cm，即模拟继承的效果</span></span><br><span class="line"><span class="built_in">setmetatable</span>(MMonster, &#123;</span><br><span class="line">    <span class="built_in">__index</span> = Cm,</span><br><span class="line">    <span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, name, HP)</span></span></span><br><span class="line">        <span class="keyword">local</span> obj = Cm(name, HP)</span><br><span class="line">        <span class="built_in">setmetatable</span>(obj, &#123;<span class="built_in">__index</span> = MMonster&#125;)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多态的实现，即在新类中定义原表中存在的方法，模拟多态的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MMonster:Show</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;M Monster:&quot;</span>, <span class="built_in">self</span>.name, <span class="built_in">self</span>.HP, <span class="built_in">self</span>.MP)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mm = MMonster(<span class="string">&quot;MMonster1&quot;</span>, <span class="number">100</span>)</span><br><span class="line">mm:Show()</span><br><span class="line">mm:TakeDamage(<span class="number">10</span>)</span><br><span class="line">mm:Show()</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>简单封装的实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 实现Monster类，并进行封装</span></span><br><span class="line"><span class="keyword">local</span> Monster = &#123;&#125;</span><br><span class="line">Monster.HP = <span class="number">100</span></span><br><span class="line">Monster.x = <span class="number">1000</span></span><br><span class="line">Monster.y = <span class="number">10</span></span><br><span class="line">Monster.<span class="built_in">type</span> = <span class="string">&quot;Monster&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:GetHP</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>.HP</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:TakeDamage</span><span class="params">(damage)</span></span></span><br><span class="line">    <span class="built_in">self</span>.HP = <span class="built_in">self</span>.HP - damage</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:SetHP</span><span class="params">(hp)</span></span></span><br><span class="line">    <span class="built_in">self</span>.HP = hp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monster:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;HP = Monster.HP, x = Monster.x, y = Monster.y&#125;    <span class="comment">-- 默认值</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, Monster)</span><br><span class="line">    <span class="comment">-- __index 定义新表，表示哪些属性可以被obj访问</span></span><br><span class="line">    Monster.<span class="built_in">__index</span> = &#123;GetHP = Monster.GetHP, TakeDamage = Monster.TakeDamage, <span class="built_in">type</span> = Monster.<span class="built_in">type</span>&#125;</span><br><span class="line">    <span class="comment">-- __newindex 访问不存在的域时的调用 例如 obj.type = “ddd&quot; 三个分别对应function的三个参数 </span></span><br><span class="line">    Monster.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(tab, key, value)</span></span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&quot;type&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Forbiden orerate.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">rawset</span>(tab, key, value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Monster</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 引用并测试</span></span><br><span class="line"><span class="keyword">local</span> CMonster = <span class="built_in">require</span>(<span class="string">&quot;t9&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> cm = CMonster:new()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cm:GetHP())</span><br><span class="line">cm:TakeDamage(<span class="number">10</span>)</span><br><span class="line">cm.<span class="built_in">type</span> = <span class="string">&quot;Player&quot;</span>  <span class="comment">-- Forbiden orerate.</span></span><br><span class="line"><span class="comment">--cm:SetHP(100)     -- attempt to call a nil value (method &#x27;SetHP&#x27;) 无法访问，即设置为私有了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cm.z)<span class="comment">-- nil</span></span><br><span class="line">cm.z = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(cm.z)<span class="comment">-- 20</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>闭包</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 闭包：通过一系方法,将函数内部的变量(局部变量)转化为全局变量</span></span><br><span class="line"><span class="comment">-- 如下，</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span><span class="params">()</span></span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cn = Counter()</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br><span class="line"><span class="built_in">print</span>(cn())</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/manual/lua53doc/contents.html&quot;&gt;Lua5.3参考手册&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;语法：&quot;&gt;&lt;a href=&quot;#语法：&quot; cla</summary>
      
    
    
    
    
    <category term="Lua" scheme="http://kennyyyyyy.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://kennyyyyyy.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://kennyyyyyy.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2022-05-12T02:30:23.000Z</published>
    <updated>2022-08-13T03:35:20.883Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p><strong>时间复杂度</strong>：指执行算法所需要的工作量。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，即考察输入值大小趋近无穷时的情况。</p><p><strong>空间复杂度</strong>：指执行算法需要的内存空间</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h4><h5 id="栈（Stack）："><a href="#栈（Stack）：" class="headerlink" title="栈（Stack）："></a><strong>栈（Stack）</strong>：</h5><p>后进先出的数据结构。只能在栈顶进行添加（入栈）和删除（出栈）的操作。</p><p><strong>应用</strong>：①撤销操作，②数组反转，③递归</p><h5 id="队列（Queue）："><a href="#队列（Queue）：" class="headerlink" title="队列（Queue）："></a><strong>队列（Queue）</strong>：</h5><p> 先进先出的数据结构，只能在队尾添加（入队）元素，队首删除（出队）元素。（双向队列无尾首区别）</p><p>循环队列 性能最好</p><p><strong>应用</strong>：排队</p><h5 id="集合（Set）："><a href="#集合（Set）：" class="headerlink" title="集合（Set）："></a><strong>集合（Set）</strong>：</h5><p>包含不重复元素的集合称为set，例如HashSet等，能快速的进行去重操作。</p><p><strong>应用</strong>：词汇量统计</p><h5 id="映射（Reflection）："><a href="#映射（Reflection）：" class="headerlink" title="映射（Reflection）："></a><strong>映射（Reflection）</strong>：</h5><p>特殊集合，例如Dictionary，存储的是键值对</p><p><strong>应用</strong>：词汇量统计</p><h5 id="有序数组："><a href="#有序数组：" class="headerlink" title="有序数组："></a><strong>有序数组：</strong></h5><p><img src="../images/数据结构与算法/image-20220323182228705.png" alt="image-20220323182228705" style="zoom:50%;"></p><ul><li>Rank使用二分查找找到target的对应位置，方便add 和 remove 的操作，保证数组始终有序</li></ul><h5 id="树："><a href="#树：" class="headerlink" title="树："></a>树：</h5><p>​    <strong>二叉树（Binary Tree）</strong>：普通二叉树</p><p>​    <strong>满二叉树（Full Binary Tree）</strong>：除了叶子节点外都有两个节点</p><p>​    <strong>完全二叉树（Complete Binary Tree）</strong>：每层的节点均达到最大值，及每层的节点数为2的n-1次方个</p><p>​    <strong>二叉搜索树（Binary Search Tree）</strong>：每个节点左边所有节点的值均小于右边节点的值</p><p>​    <strong>平衡二叉树（AVL Tree）</strong>：任何节点的两颗字数的高度差小于等于1</p><p>​    <strong>B树（B-Tree）</strong>：B树与平衡二叉树一样，但是是多叉树</p><p>​    <strong>红黑树（Red-Black Tree）</strong>：自平衡二叉寻找数</p><p>​    </p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h4><h6 id="排序：升序为例"><a href="#排序：升序为例" class="headerlink" title="排序：升序为例"></a>排序：升序为例</h6><ul><li><p><strong>冒泡</strong>：双重循环，依次比较大小，前一个比后一个大，则交换位置，时间复杂度O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> t = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>选择</strong>：双重循环，但内循环只选出第 i 个即其之后位置的最小值，然后和第 i 个位置交换，时间复杂度O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = arr.<span class="built_in">size</span>(), idx = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> mx = arr[i];</span><br><span class="line">           idx = i;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(mx &gt; arr[j])&#123;</span><br><span class="line">                   mx = arr[j];</span><br><span class="line">                   idx = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> t = arr[i];</span><br><span class="line">           arr[i] = mx;</span><br><span class="line">           arr[idx] = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>快排</strong>：以第一个数为界 记flag，从前往后找出第一个比flag大的值，从后往前，找出第一个比flag小的数，然后交换两个数的位置。直到找到flag的位置，然后递归查找flag的左侧和右侧的中间值</p><p>时间复杂度O(n log2 n)</p><font color="red">不能对存在重复元素的数组进行排序</font><font color="red">若快排前数组有序，则时间复杂度为O(n^2)</font><font color="red">排序前可以将第一个元素与中间或随机元素进行交换，可优化时间复杂度</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = arr[start];</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++i] &lt; flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == end)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[j] &gt; flag)&#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(j == start)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[start] = arr[j];</span><br><span class="line">    arr[j] = flag;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, start, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, j + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>三路快排</strong>：<font color="red">有重复元素的快速排序</font> ，即相比上一个方法，多了等于flag的情况</p><p>即将数组中的元素分为三个区域，大于[gt, right] 小于[l+1, lt]和等于选定值flag的情况</p><p><img src="../images/数据结构与算法/70.png" alt="img"></p><p>i 指向当前元素</p><ul><li>若 i 指向元素等于flag，则i++；</li><li>若 i 指向元素小于flag，则将 it + 1 指向的值与 i 交换，然后 it++、i++。即将小于flag的区域增1，且等于flag的区域右移1.</li><li>若 i 指向的元素大于flag， 则将 gt - 1 指向的元素与 i 交换，然后 gt—。即将大于flag的区域向后增1，其余区域不变</li><li>当 i 指向 gt 时，表示遍历完成，此时只需将 flag 除的值与 lt 处的值进行交换，则三个区间形成，然后继续遍历大于flag和小于flag的区域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, i</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="number">1</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">while</span>(i &lt; gt)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">if</span>(arr[i] &lt; flag)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> t = arr[i];</span></span></span><br><span class="line"><span class="function"><span class="params">                arr[i] = arr[lt + <span class="number">1</span>];</span></span></span><br><span class="line"><span class="function"><span class="params">                arr[lt + <span class="number">1</span>] = t;</span></span></span><br><span class="line"><span class="function"><span class="params">                lt++;</span></span></span><br><span class="line"><span class="function"><span class="params">                i++;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; flag)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> t = arr[i];</span></span></span><br><span class="line"><span class="function"><span class="params">                arr[i] = arr[gt - <span class="number">1</span>];</span></span></span><br><span class="line"><span class="function"><span class="params">                arr[gt - <span class="number">1</span>] = t;</span></span></span><br><span class="line"><span class="function"><span class="params">                gt--;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">else</span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                i++;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    arr[start] = arr[lt];</span></span></span><br><span class="line"><span class="function"><span class="params">    arr[lt] = flag;</span></span></span><br><span class="line"><span class="function"><span class="params">        QuickSort(arr, start, lt - <span class="number">1</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        QuickSort(arr, gt, end);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">     </span></span></span><br><span class="line"><span class="function"><span class="params">    vector&lt;<span class="keyword">int</span>&gt; MySort(vector&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        QuickSort(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> arr;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>归并</strong>：采用分治法，先使子序列有序，然后将两个有序子序列合并，得到有序序列。即先将输入序列分成n/2个子序列，对这两个子序列分别采用归并排序，将两个排序好的子序列合并成排序序列，时间复杂度O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, vector&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = start;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">            res[k++] = arr[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        res[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(j &lt;= end)&#123;</span><br><span class="line">        res[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = start; z &lt;= end; z++)&#123;</span><br><span class="line">        arr[z] = res[z];</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, vector&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, res, start, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, res, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">Merge</span>(arr, res, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, res, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>堆</strong>：</p></li><li><p><strong>桶</strong>：</p></li></ul><h6 id="查找："><a href="#查找：" class="headerlink" title="查找："></a><strong>查找：</strong></h6><ul><li><p>顺序查找<strong>O(n)</strong>：遍历所有数据，进行处理 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">OrderSearch</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n, i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(target == arr[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找<strong>O(log n)</strong>：对有序数组进行分半查找，每次为对比中间数据，然后根据大小关系，对前半部分或后半部分进行对比。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BinarySearch</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>; <span class="comment">//防止数据溢出</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt; arr[mid])</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; arr[mid])</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="递归-recursion-："><a href="#递归-recursion-：" class="headerlink" title="递归(recursion)："></a><strong>递归(recursion)：</strong></h6><ul><li>程序调用自身的编程技巧称为递归，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解.。递归需要有边界条件、递归前进段和递归返回段。</li></ul><h6 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h6><ul><li><p>定义：在一些有N个元素的集合应用问题中，通常在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。</p></li><li><p>主要用于解决一些<strong>元素分组</strong>的问题，用于管理一系列<strong>不相交的集合</strong>并存在两种操作：</p><ul><li><strong>查找(Find)</strong>:查询两个元素是否在同一个集合中；</li><li><strong>合并(Union)</strong>:把两个不相交的集合合并成一个集合。</li></ul></li><li><p>最简单版本的并查集代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> parent[MaxSize]; <span class="comment">//使用parents数组来记录每个节点的父节点</span></span><br><span class="line"><span class="comment">//初始化：首先将所有的节点的父节点设置为自己</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询:通过递归不断访问父节点，直到访问到根节点。根据两个节点的根节点是否相同来判断是否在同一个集合当中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[val] == val)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Find</span>(parent[val]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并：找到两个节点所在集合的根节点，将一个根节点的父节点设置为另一个根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parent[<span class="built_in">Find</span>(i)] == <span class="built_in">Find</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接合并可能会导致每次查询的路径过长，而增加时间消耗，因此，存在两个方面对算法进行优化</p><ul><li><p>路径压缩：在查询过程中把沿途的每个节点的父节点全部设置为根节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[val] == val)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    parent[val] = <span class="built_in">Find</span>(Parent[val]); <span class="comment">//将父节点设置为根节点</span></span><br><span class="line">    <span class="keyword">return</span> parent[val]<span class="comment">//返回父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通常简化为</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">Find</span>(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> parent[val] == val ? val:(parent[val] = <span class="built_in">Find</span>(parent[val]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按秩合并：用rank[]数组记录每个根节点对应的深度。初始化为1。合并时把rank较小的合并在较大的根节点上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="built_in">Find</span>(i);</span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">Find</span>(j);</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &gt; rank[y])</span><br><span class="line">        parent[y] = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">parent[x] = y;</span><br><span class="line">    <span class="keyword">if</span>(rank[x] == rank[y] &amp;&amp; x != y)<span class="comment">//如果深度相同且不是同一个根节点，则新的根节点深度加一</span></span><br><span class="line">        rank[y]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]"> ，但是很可能会破坏rank的准确性。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;算法复杂度&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：指执行算法所需要的工作</summary>
      
    
    
    
    
    <category term="C++" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
    <category term="数据结构" scheme="http://kennyyyyyy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://kennyyyyyy.github.io/2021/09/16/%E5%89%91%E6%8C%87offer/"/>
    <id>http://kennyyyyyy.github.io/2021/09/16/%E5%89%91%E6%8C%87offer/</id>
    <published>2021-09-16T08:45:47.000Z</published>
    <updated>2021-10-06T06:12:07.330Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p>链表反转：</p><p>开始先设定三个指针，并进行初始化，如图</p><p><img src="/images/剑指offer/List_1.png" alt="List_1"></p><p>并将Pre的指向的Next指向NULL</p><p><img src="/images/剑指offer/List_2.png" alt="List_2"></p><p>开始循环，head指针后移，让Cur指针的Next指向Pre，然后使Pre = Cur，Cur = Head。直到链表尾</p><p><img src="/images/剑指offer/List_3.png" alt="List_3"></p><p><img src="/images/剑指offer/List_4.png" alt="List_4"></p></li></ul><ul><li><p>二分法模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;根据题目判断搜索条件&quot;</span>) &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>广度优先遍历（BFS）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; qu;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        qu.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left)</span><br><span class="line">            qu.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;right)</span><br><span class="line">            qu.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>深度优先遍历（DFS）</p><ul><li>例题：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></li><li>用dfs深度遍历加回溯法。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//循环查找，每个字符都可能是第一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">const</span> string&amp; word, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx == word.<span class="built_in">length</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= board.<span class="built_in">size</span>() || </span><br><span class="line">        col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || </span><br><span class="line">        board[row][col] != word[idx]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//将遍历过的，和word字符匹配的位置置为不可能出现的字符，起到visited数组的作用</span></span><br><span class="line">board[row][col] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行递归遍历</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, row - <span class="number">1</span>, col, idx + <span class="number">1</span>) ||</span><br><span class="line"><span class="built_in">dfs</span>(board, word, row + <span class="number">1</span>, col, idx + <span class="number">1</span>) ||</span><br><span class="line"><span class="built_in">dfs</span>(board, word, row, col - <span class="number">1</span>, idx + <span class="number">1</span>) ||</span><br><span class="line"><span class="built_in">dfs</span>(board, word, row, col + <span class="number">1</span>, idx + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若此次遍历无匹配，则将数组字符还原</span></span><br><span class="line">board[row][col] = word[idx];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><p>清除字符串前后的空格符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>​    <img src="/images/剑指offer/image-20210929203313557.png" alt="image-20210929203313557"></p><ol><li><p>前序遍历：优先遍历根节点，然后是左子节点，再是右子节点</p><p>​    A-B-D-F-G-H-I-E-C</p></li><li><p>中序遍历：优先遍历左子节点，然后是根节点，再是右子节点</p><p>​    F-D-H-G-I-B-E-A-C</p></li><li><p>后序遍历：优先遍历左子节点，然后是右子节点，再是根节点</p><p>​    F-H-I-G-D-E-B-C-A</p></li></ol><ul><li><h5 id="二叉树转化成双向链表："><a href="#二叉树转化成双向链表：" class="headerlink" title="二叉树转化成双向链表："></a>二叉树转化成双向链表：</h5><p>用中序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head保存双向链表头节点，pre保存中序遍历时的前一个遍历的节点</span></span><br><span class="line">Node* pre = <span class="literal">NULL</span>, * head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">dfsm</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使首尾相连</span></span><br><span class="line">head-&gt;left = pre;</span><br><span class="line">    pre-&gt;right = head;</span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsm</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">dfsm</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">//如果pre为空，则此节点为第一个节点，所以记录下头节点</span></span><br><span class="line">    <span class="keyword">if</span> (!pre)</span><br><span class="line">head = root;</span><br><span class="line">    <span class="comment">//不为空则表示已经遍历过其他节点，因此使上一个节点指向此节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pre)</span><br><span class="line">    pre-&gt;right = root;</span><br><span class="line">    <span class="comment">//双向链表，因此此节点的左指针指向上一个节点</span></span><br><span class="line">root-&gt;left = pre;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="built_in">dfsm</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><h4 id="优先队列：priority-queue"><a href="#优先队列：priority-queue" class="headerlink" title="优先队列：priority_queue"></a>优先队列：priority_queue</h4><ul><li><p>包含在头文件 ‘queue’ 中,我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队.</p></li><li><p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列，小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序队列，大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="二叉搜索树：Binary-Search-Tree"><a href="#二叉搜索树：Binary-Search-Tree" class="headerlink" title="二叉搜索树：Binary Search Tree"></a>二叉搜索树：Binary Search Tree</h4><ul><li><p>若它的左子树不空，则左子树上所有结点的值均小于它的<a href="https://baike.baidu.com/item/根结点/9795570">根结点</a>的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为<a href="https://baike.baidu.com/item/二叉排序树/10905079">二叉排序树</a>。</p></li><li><p>中序遍历得到的结果使有序的</p><p><img src="images/剑指offer/image-20211003134458224.png" alt="image-20211003134458224"></p></li></ul></li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><h5 id="分组位运算："><a href="#分组位运算：" class="headerlink" title="分组位运算："></a>分组位运算：</h5><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p></li></ul><p>  相同数字异或为零</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;<span class="comment">//所有数字异或的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到第一位为1的位置</span></span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//通过是否为一将数组分为两组，分别进行异或运算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= n;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;链表反转：&lt;/p&gt;
&lt;p&gt;开始先设定三个指针，并进行初始化，如图&lt;/p&gt;
</summary>
      
    
    
    
    <category term="c++" scheme="http://kennyyyyyy.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="http://kennyyyyyy.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>FSM状态机</title>
    <link href="http://kennyyyyyy.github.io/2021/07/29/FSM%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://kennyyyyyy.github.io/2021/07/29/FSM%E7%8A%B6%E6%80%81%E6%9C%BA/</id>
    <published>2021-07-29T11:36:24.000Z</published>
    <updated>2021-07-29T13:47:44.736Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ol><li><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>FSM是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的机器。</p><p>是一种设计模式</p></li><li><h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;ol&gt;
&lt;li&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;FSM是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="unity" scheme="http://kennyyyyyy.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>3D RPG 学习笔记</title>
    <link href="http://kennyyyyyy.github.io/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://kennyyyyyy.github.io/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-23T07:38:31.000Z</published>
    <updated>2021-09-07T11:03:10.186Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="一、创建项目导入素材"><a href="#一、创建项目导入素材" class="headerlink" title="一、创建项目导入素材"></a>一、创建项目导入素材</h2><ol><li><h4 id="创建普通项目"><a href="#创建普通项目" class="headerlink" title="创建普通项目"></a>创建普通项目</h4><ul><li>在Package Manager中安装Universal RP</li><li>在Asset中创建Rendering =&gt; Universal Render Pipeline =&gt; Pipeline Asset(URP的设置文件)</li><li>将project setting中Graphics和Quality的渲染管线设置为刚创建的渲染管线设置文件</li><li>导入素材（Dog Knight PBR Polyart、 Low-Poly Simple Nature Pack 和 FREE Skybox Extended Shader）</li><li>在Edit =&gt; Edit=Render Pipeline =&gt; Universal Render Pipeline 中设置当前项目或当前素材的渲染管线</li><li>在Lighting =&gt; Environment 中设置天空盒的材质</li><li>注意Asset窗口和Inspect窗口的物体分类，方便管理</li></ul></li><li><h4 id="安装package"><a href="#安装package" class="headerlink" title="安装package"></a>安装package</h4><ul><li><p><strong>PolyBrush</strong> </p><p><img src="/images/3D-RPG-学习笔记/0.png" alt="PolyBrush "></p><ol><li><p>调整地面的高度(左键直接点击变高，control+左键点击变矮)</p><p><img src="/images/3D-RPG-学习笔记/1.png" alt="调整"></p><ul><li>Outer Radius：外圈大小</li><li>Inner Radius：内圈大小</li><li>Strength：变化强度</li><li>Direction：设置变化的方向。Brush normal：材质的法线方向</li><li>Brush Mirroring：沿坐标轴对称形成另一个笔刷同时进行相同操作</li></ul></li><li><p>柔化：将比较突出的棱角变的平滑。设置基本同上</p><p><img src="/images/3D-RPG-学习笔记/2.png" alt="柔化"></p></li><li><p>将当前物体刷上不同的颜色</p><p><img src="/images/3D-RPG-学习笔记/3.png" alt="颜色刷"></p><ul><li>如果需要将颜色刷到物体上，则物体材质的 shader 需要为 Polybrush=&gt; Shader 下的shader</li><li>Brush：根据笔刷的大小刷上颜色</li><li>Fill：填充区块</li><li>Flood：整个物体</li></ul></li><li><p>将预制体刷到场景当中</p><p><img src="/images/3D-RPG-学习笔记/4.png" alt="预制体刷"></p><ul><li>基本设置同1</li><li>将需要的prefab添加到Current Palette中，当前选中的prefab会在Brush Loadout中</li><li>Brush Loadout 中prefab下的拖动条表示此物体出现的概率</li><li>Hit Surface is Parent：将所有的画在平面上的物体都是此平面的子物体</li></ul></li><li><p>将texture刷到场景当中</p><ul><li>同4</li></ul></li></ol></li><li><p><strong>Pro Builder</strong> </p><p><img src="/images/3D-RPG-学习笔记/ProBuilder.png" alt=" Pro Builder "></p><ul><li>按住shift可以查看图标的功能</li><li></li></ul></li><li><p><strong>Pro Grids</strong></p><ul><li><p>安装ProGrids需要在Project Setting的Package Manger中打开允许preview</p><p><img src="/images/3D-RPG-学习笔记/EnablePreview.png" alt="Enable Preview"></p></li><li><p><img src="/images/3D-RPG-学习笔记/ProGrids.png" alt="Pro Grids"></p></li></ul><ol><li>设置物体移动时的单位距离</li><li>是否在Scene窗口中显示坐标轴</li><li>是否自动吸附：即按照1的设置在坐标轴上自动进行吸附，每次只移动1的距离</li><li>4</li><li>5</li><li>X 、Y、 Z、 3D均为Scene窗口显示的坐标轴</li></ol></li></ul></li><li><h4 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h4><p>自动导航</p></li><li><h4 id="点击移动"><a href="#点击移动" class="headerlink" title="点击移动"></a>点击移动</h4><ol><li><p><strong>自定义事件的注册和调用</strong></p><ol><li><p><img src="/images/3D-RPG-学习笔记/image-20210724155224166.png" alt="自定义事件"></p><ul><li><p>注册</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventVector3</span> : <span class="title">UnityEvent</span>&lt;<span class="title">Vector3</span>&gt; &#123; &#125;;</span><br><span class="line"><span class="comment">//声明类，继承UnityEvent，并需要参数Vector3</span></span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OnMouseClicked?.Invoke(hitInfo.point);</span><br><span class="line"><span class="comment">//当OnMouseClicked事件不为空时调用，并传入point信息</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p><strong>屏幕射线转为世界射线</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure></li><li><p><strong>单例模式</strong></p><p>方便事件函数等在外部的调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MouseManager Instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Instance != <span class="literal">null</span>)</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    Instance = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>事件注册和调用</strong></p></li></ol></li><li><h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><ul><li>鼠标指针图片切换</li><li>Cinemachine：多功能相机插件</li><li>Post Processing：后处理</li><li>Animator</li></ul></li><li><h4 id="Shader-Graph-遮挡剔除"><a href="#Shader-Graph-遮挡剔除" class="headerlink" title="Shader Graph 遮挡剔除"></a>Shader Graph 遮挡剔除</h4></li><li><h4 id="FSM-状态机"><a href="#FSM-状态机" class="headerlink" title="FSM 状态机"></a>FSM 状态机</h4></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;一、创建项目导入素材&quot;&gt;&lt;a href=&quot;#一、创建项目导入素材&quot; class=&quot;headerlink&quot; title=&quot;一、创建项目导入素材&quot;&gt;&lt;/a&gt;一、创建项目导入素材&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="unity" scheme="http://kennyyyyyy.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>每日一题</title>
    <link href="http://kennyyyyyy.github.io/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://kennyyyyyy.github.io/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2021-07-19T07:49:14.000Z</published>
    <updated>2021-09-15T09:34:03.991Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="面试题-10-02-变位词组"><a href="#面试题-10-02-变位词组" class="headerlink" title="面试题 10.02. 变位词组"></a><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></h3><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序</li></ul><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>思路</strong>：计数法。</p><p>计算每个字符串中所有字符出现的个数，将相同的放在同一个list中，完成分类</p></li><li><p><strong>代码</strong>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; GroupAnagrams(<span class="built_in">string</span>[] strs) &#123;</span><br><span class="line">        </span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; vs = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"><span class="comment">// 用字典储存相同的字符串</span></span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, IList&lt;<span class="built_in">string</span>&gt;&gt; pairs = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">        <span class="comment">// 用list储存出现过的key</span></span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; keysss = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环计算所有字符串中出现字符的次数，并通过key将字符串添加到相应的pairs中，最终结果key也添加到keysss列表中</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> str <span class="keyword">in</span> strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> key = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&#x27;0&#x27;</span>, <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> val <span class="keyword">in</span> str)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> keys = key.ToCharArray();</span><br><span class="line">                keys[val - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                key = <span class="keyword">new</span> <span class="built_in">string</span>(keys);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pairs.ContainsKey(key))</span><br><span class="line">            &#123;</span><br><span class="line">                pairs[key].Add(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                IList&lt;<span class="built_in">string</span>&gt; temp = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">                temp.Add(str);</span><br><span class="line">                pairs.Add(key, temp);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (!keysss.Contains(key))</span><br><span class="line">            &#123;</span><br><span class="line">                keysss.Add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出字典中的数据，存到list中</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> key <span class="keyword">in</span> keysss)</span><br><span class="line">        &#123;</span><br><span class="line">            vs.Add(pairs[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1877-数组中最大数对和的最小值"><a href="#1877-数组中最大数对和的最小值" class="headerlink" title="1877. 数组中最大数对和的最小值"></a><a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></h3><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a><strong>题解</strong>：</h4><ol><li><p><strong>分析</strong>：</p><p>最大与最小相加产生的数对和最小，即第k大的数和第k小的数相加，所得的最大数对和最小.</p><p>所以先将数组进行排序，然后依次下相加比较，即得出结果</p></li><li><p><strong>代码</strong>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinPairSum</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.Length;</span><br><span class="line">    Array.Sort(nums);</span><br><span class="line">    <span class="built_in">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxSum = Math.Max(maxSum, nums[i] + nums[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1893-检查是否区域内所有整数都被覆盖"><a href="#1893-检查是否区域内所有整数都被覆盖" class="headerlink" title="1893. 检查是否区域内所有整数都被覆盖"></a><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">1893. 检查是否区域内所有整数都被覆盖</a></h3><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>暴力解法，用一个 right-left+1 大小的数组来记录，直接通过二重循环，依次判断ranges中的每个[start,end]中是否包含[left,right]中的任意数字，如果包含，则对应的数组的值加一，循环完毕后再次循环判断数组中是否有0，有则为false，没有返回true。</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsCovered</span>(<span class="params"><span class="built_in">int</span>[][] ranges, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span>[] ltr = <span class="keyword">new</span> <span class="built_in">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ranges.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = ranges[i][<span class="number">0</span>]; j &lt;= ranges[i][<span class="number">1</span>]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt;= right &amp;&amp; j &gt;= left)</span><br><span class="line">            &#123;</span><br><span class="line">                ltr[j - left]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ltr[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1743-从相邻元素对还原数组"><a href="#1743-从相邻元素对还原数组" class="headerlink" title="1743. 从相邻元素对还原数组"></a><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/">1743. 从相邻元素对还原数组</a></h3><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>将数组中的数对用字典储存，则数组头或尾中字典的list的长度只有1，然后在通过字典，一次查找下一个</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">RestoreArray</span>(<span class="params"><span class="built_in">int</span>[][] adjacentPairs</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt; pairs = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">int</span>[] pair <span class="keyword">in</span> adjacentPairs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pairs.ContainsKey(pair[<span class="number">0</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    pairs.Add(pair[<span class="number">0</span>], <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!pairs.ContainsKey(pair[<span class="number">1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    pairs.Add(pair[<span class="number">1</span>], <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                pairs[pair[<span class="number">0</span>]].Add(pair[<span class="number">1</span>]);</span><br><span class="line">                pairs[pair[<span class="number">1</span>]].Add(pair[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> n = adjacentPairs.Length + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> pair <span class="keyword">in</span> pairs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> key = pair.Key;</span><br><span class="line">                <span class="keyword">if</span>(pair.Value.Count == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[<span class="number">0</span>] = key;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[<span class="number">1</span>] = pairs[nums[<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;<span class="built_in">int</span>&gt; vs = pairs[nums[i - <span class="number">1</span>]];</span><br><span class="line">                nums[i] = nums[i - <span class="number">2</span>] == vs[<span class="number">0</span>] ? vs[<span class="number">1</span>] : vs[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="704-二分查找-2021-9-7"><a href="#704-二分查找-2021-9-7" class="headerlink" title="704. 二分查找 2021/9/7"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a> 2021/9/7</h3><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>经典二分题，将数组分成两个部分，通过判断中间数字和目标数字的大小比较，然后进入目标数字存在的部分再次进行二分查找</p><p>在进行中间下标的计算时，若直接用 (left + right)/2 会导致一些特殊情况出现问题，所以使用 (right - left)/2 + left， 或直接使用位移运算 left + right &gt;&gt; 1。</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> right = nums.Length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> middle = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (nums[middle] == target)</span><br><span class="line">                    <span class="keyword">return</span> middle;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">                    left = middle + <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="470-用-Rand7-实现-Rand10-2021-9-6"><a href="#470-用-Rand7-实现-Rand10-2021-9-6" class="headerlink" title="470. 用 Rand7() 实现 Rand10()  2021/9/6"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a>  2021/9/6</h3><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>Rand7() 有 1~7 共7种数字，49种情况，所以从1-10依次分布如下</p><p>​    <img src="/images/每日一题/Rand7.png" alt="Rand7"></p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Rand10</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> ra = Rand7();</span><br><span class="line">    <span class="built_in">int</span> rb = Rand7();</span><br><span class="line">    <span class="built_in">int</span> idx;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ra = Rand7();</span><br><span class="line">        rb = Rand7();</span><br><span class="line">        idx = ra + (rb - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(idx &gt; <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> (idx) % <span class="number">10</span> + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1221-分割平衡字符串-2021-9-7"><a href="#1221-分割平衡字符串-2021-9-7" class="headerlink" title="1221. 分割平衡字符串 2021/9/7"></a><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串</a> 2021/9/<strong>7</strong></h3><h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>循环计算字符串中的L和R的字符个数，当两个个数相等时就表示出现一个平衡字符串，则计数器加一。</p></li></ol><ol><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BalancedStringSplit</span>(<span class="params"><span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">int</span> len = s.Length;</span><br><span class="line">    <span class="built_in">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i].Equals(<span class="string">&#x27;L&#x27;</span>))</span><br><span class="line">            L++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R++;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (L == R)</span><br><span class="line">        &#123;</span><br><span class="line">            L = <span class="number">0</span>;</span><br><span class="line">            R = <span class="number">0</span>;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="678-有效的括号字符串-2021-9-12"><a href="#678-有效的括号字符串-2021-9-12" class="headerlink" title="678. 有效的括号字符串  2021/9/12"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a>  2021/9/12</h3><h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><ul><li><p><strong>堆栈法：</strong></p><p>对字符串s逐个字符进行判断，有如下三种情况</p><ul><li>如果字符是左括号，则将其下标压入左括号栈</li><li>如果字符是星号，则将其下表压入星号栈</li><li>如果字符是右括号，则<ul><li>如果左括号栈中元素不为空，则将左括号栈中顶部元素出栈</li><li>如果左括号栈中元素为空，星号栈中元素不为空，则将星号栈中顶部元素出栈</li><li>如果两个栈中元素都为空，则此右括号无匹配元素，返回false</li></ul></li><li>字符串遍历完后，如果两个栈中元素都不为空，则依次将两个栈中的栈顶元素出栈，然后比较两个元素的大小，如果左括号栈的出栈下标比星号栈的出栈下标大，则表示左括号在星号的后面，无法匹配，返回false</li><li>最后判断左括号栈中的所有元素是否全部出栈，即所有左括号均有匹配，则返回true（星号可以为空字符，所以星号栈不需要做判断）</li></ul></li><li><p><strong>动态规划：</strong></p></li><li><p><strong>贪心：</strong></p></li></ul></li></ol><ol><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckValidString</span>(<span class="params"><span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> length = s.Length;</span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; left = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; aster = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i].Equals(<span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">                left.Push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i].Equals(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                aster.Push(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (left.Count &gt; <span class="number">0</span>)</span><br><span class="line">                    left.Pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (aster.Count &gt; <span class="number">0</span>)</span><br><span class="line">                    aster.Pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left.Count &gt; <span class="number">0</span> &amp;&amp; aster.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> leftIndex = left.Pop();</span><br><span class="line">            <span class="built_in">int</span> asterIndex = aster.Pop();</span><br><span class="line">            <span class="keyword">if</span> (leftIndex &gt; asterIndex)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.Count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="447-回旋镖的数量-2021-9-12"><a href="#447-回旋镖的数量-2021-9-12" class="headerlink" title="447. 回旋镖的数量  2021/9/12"></a><a href="https://leetcode-cn.com/problems/number-of-boomerangs/">447. 回旋镖的数量</a>  2021/9/12</h3><h4 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><ul><li><p>直接三重循环依次判断三个点是否组成等边三角形，然后返回值。（严重超时）</p></li><li><p>一个回旋镖可以看作三个点组成的一个等边三角形，所以要判断是否可以放置回旋镖即判断是否可以组成等边三角形，即找到两个点到同一个点的距离相同。每多一个点到顶点的距离相同，就会多两个可摆放的回旋镖（存在位置差异，n&gt;=2），即为n的排列组合。</p><center>An = n * (n - 1)</center><p>所以我们可以采用枚举的方法，依次判断所有点到其他点的距离，并用字典储存,再在最后进行判断。</p></li></ul></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">NumberOfBoomerangs</span>(<span class="params"><span class="built_in">int</span>[][] points</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//三重循环直接超时</span></span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">int</span>[] p <span class="keyword">in</span> points)</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; cnt = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">int</span>[] q <span class="keyword">in</span> points)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> dis = (p[<span class="number">1</span>] - q[<span class="number">1</span>]) * (p[<span class="number">1</span>] - q[<span class="number">1</span>]) + (p[<span class="number">0</span>] - q[<span class="number">0</span>]) * (p[<span class="number">0</span>] - q[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!cnt.ContainsKey(dis))</span><br><span class="line">                cnt.Add(dis, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt[dis]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pair <span class="keyword">in</span> cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> m = pair.Value;</span><br><span class="line">            sum += m * (m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="524-通过删除字母匹配到字典里最长单词-2021-9-14"><a href="#524-通过删除字母匹配到字典里最长单词-2021-9-14" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词 2021/9/14"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a> 2021/9/14</h3><h4 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>题目描述不清楚，应为在第二个参数dictionary中找到最长的s的，且相同长度下字典序靠前的子字符串。</p><p>所以先将字典中的字符串按长度和字典序进行排序，然后依次判断是否为s的子串。</p><p>排序时需要先将 IList 转化为 List <code>var list = new List<string>(dictionary);</string></code> </p><p>然后使用List的Sort方法 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list.Sort((x, y) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x.Length == y.Length)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> x.CompareTo(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y.Length.CompareTo(x.Length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">FindLongestWord</span>(<span class="params"><span class="built_in">string</span> s, IList&lt;<span class="built_in">string</span>&gt; dictionary</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;(dictionary);</span><br><span class="line">    list.Sort((x, y) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(x.Length == y.Length)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span> x.CompareTo(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y.Length.CompareTo(x.Length);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> str <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.Length &amp;&amp; j &lt; s.Length)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == s[j])</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span> (i == str.Length)</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="162-寻找峰值-2021-9-15"><a href="#162-寻找峰值-2021-9-15" class="headerlink" title="162. 寻找峰值  2021/9/15"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a>  2021/9/15</h3><h4 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h4><ol><li><p><strong>分析：</strong></p><p>该题需要时间复杂度为O(log n)，所以直接循环查找行不通。</p><p>因此需要使用二分法进行查找。</p><p>在二分查找时有四种情况</p><ul><li>nums[mid - 1] &lt; nums[mid] &lt; nums[mid + 1]，此时右边一定存在一个峰值</li><li>nums[mid - 1] &gt; nums[mid] &gt; nums[mid + 1]，此时左边一定存在一个峰值</li><li>nums[mid - 1] &gt; nums[mid] &lt; nums[mid + 1]，此时左边和右边都存在峰值</li><li>nums[mid - 1] &lt; nums[mid] &gt; nums[mid + 1]，此时mid 本生就为一个峰值</li></ul><p>对上述四种情况进行优化，可以分为两种情况，峰值在左边（右边）和峰值在右边（左边）和中间</p></li><li><p><strong>代码：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindPeakElement</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.Length;</span><br><span class="line">    <span class="built_in">int</span> mid;</span><br><span class="line">    <span class="built_in">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h3 id=&quot;面试题-10-02-变位词组&quot;&gt;&lt;a href=&quot;#面试题-10-02-变位词组&quot; class=&quot;headerlink&quot; title=&quot;面试题 10.02. 变位词组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://le</summary>
      
    
    
    
    <category term="每日一题" scheme="http://kennyyyyyy.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="C#" scheme="http://kennyyyyyy.github.io/tags/C/"/>
    
    <category term="Leetcode" scheme="http://kennyyyyyy.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>VRTK学习记录</title>
    <link href="http://kennyyyyyy.github.io/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-06-06T11:27:43.000Z</published>
    <updated>2021-07-20T12:41:43.122Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>unity 2018.4.14<br>VRTK 3.3.0<br>steamVR 1.2.3</p><h3 id="键鼠模拟基本操作"><a href="#键鼠模拟基本操作" class="headerlink" title="键鼠模拟基本操作"></a>键鼠模拟基本操作</h3><ul><li>wasd控制人物移动</li><li>鼠标默认控制人物方向</li><li>alt切换控制模式<ul><li>鼠标：控制人物方向 —&gt;控制左右Controller的水平位置</li><li>ctrl：按住ctrl控制Controller的垂直位置</li></ul></li><li>tab切换左右Controller</li><li>ctrl 切换为抓取物体模式<ul><li>鼠标右键为右Controller抓取</li><li>鼠标左键为左Controller抓取</li></ul></li><li>shift 奔跑</li><li>q 发出射线<ul><li>鼠标右键代表Controller的扳机</li></ul></li></ul><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ol><li><p>新建场景，删除原本的Camera。</p></li><li><p>simulator为键鼠模拟；steamVr为设备操作；[VRSimulator_CameraRig]是VRTK的prefab，可直接使用；</p><p>RightController 为右控制器； LeftController 为左控制器； PlayArea 为需要传送时添加。</p><p><img src="/images/VRTK学习记录/基本结构.png" alt="基本结构"></p></li></ol><ol><li><p>VRTK SDK 需要添加VRTK_SDKManager 组件，并将子物体simulator和steamVR添加到组件中Setups的列表中（因为只需要键鼠模拟，所以只添加了simulator），然后将左右手控制器分别添加到Scripts Aliases中。</p><p><img src="/images/VRTK学习记录/VRTK_SDKManager.png" alt="Manager"></p></li></ol><ol><li><p>Simulator和SteamVR需要添加VRTK_SDK Setup 组件，并将Quick Select设置为相应的模式</p><p><img src="/images/VRTK学习记录/VRTK_SDKSetup.png" alt="Setup"></p></li></ol><h3 id="Controller相关"><a href="#Controller相关" class="headerlink" title="Controller相关"></a>Controller相关</h3><h4 id="控制器基本组件"><a href="#控制器基本组件" class="headerlink" title="控制器基本组件"></a>控制器基本组件</h4><p>​    <img src="/images/VRTK学习记录/Controller1.png" alt="Controller基本组件"></p><p>​    <img src="/images/VRTK学习记录/grab.png" alt="Controller抓取物体所需组件"></p><p>​    <img src="/images/VRTK学习记录/point.png" alt="Controller射线组件"></p><ul><li>​    射线类型可以为直线(VRTK_Straight Pointer Renderer)或贝塞尔曲线(VRTK_Bezier Pointer Renderer)</li></ul><p>​    <img src="/images/VRTK学习记录/Controller_UI.png" alt="Controller_UI"></p><ul><li>Heighlighter …. ； VRTK_UI Pointer为ui互动所必须组件</li></ul><h4 id="射线与场景互动"><a href="#射线与场景互动" class="headerlink" title="射线与场景互动"></a>射线与场景互动</h4><p>控制器上可以添加自定义脚本，使之可以与场景中的物体进行互动,脚本参考VRTK_ControllerPointerEvents_ListenerExample</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VRTK_ControllerPointerEvents_ListenerExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> showHoverState = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GetComponent&lt;VRTK_DestinationMarker&gt;() == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                VRTK_Logger.Error(VRTK_Logger.GetCommonMessage(VRTK_Logger.CommonMessageKeys.REQUIRED_COMPONENT_MISSING_FROM_GAMEOBJECT, <span class="string">&quot;VRTK_ControllerPointerEvents_ListenerExample&quot;</span>, <span class="string">&quot;VRTK_DestinationMarker&quot;</span>, <span class="string">&quot;the Controller Alias&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Setup controller event listeners</span></span><br><span class="line">            GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerEnter += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerIn);</span><br><span class="line">            <span class="keyword">if</span> (showHoverState)</span><br><span class="line">            &#123;</span><br><span class="line">                GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerHover += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerHover);</span><br><span class="line">            &#125;</span><br><span class="line">            GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerExit += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerOut);</span><br><span class="line">            GetComponent&lt;VRTK_DestinationMarker&gt;().DestinationMarkerSet += <span class="keyword">new</span> DestinationMarkerEventHandler(DoPointerDestinationSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DebugLogger</span>(<span class="params"><span class="built_in">uint</span> index, <span class="built_in">string</span> action, Transform target, RaycastHit raycastHit, <span class="built_in">float</span> distance, Vector3 tipPosition</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="built_in">string</span> targetName = (target ? target.name : <span class="string">&quot;&lt;NO VALID TARGET&gt;&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> colliderName = (raycastHit.collider ? raycastHit.collider.name : <span class="string">&quot;&lt;NO VALID COLLIDER&gt;&quot;</span>);</span><br><span class="line">            VRTK_Logger.Info(<span class="string">&quot;Controller on index &#x27;&quot;</span> + index + <span class="string">&quot;&#x27; is &quot;</span> + action + <span class="string">&quot; at a distance of &quot;</span> + distance + <span class="string">&quot; on object named [&quot;</span> + targetName + <span class="string">&quot;] on the collider named [&quot;</span> + colliderName + <span class="string">&quot;] - the pointer tip position is/was: &quot;</span> + tipPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerIn</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER IN&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerOut</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER OUT&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerHover</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER HOVER&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoPointerDestinationSet</span>(<span class="params"><span class="built_in">object</span> sender, DestinationMarkerEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DebugLogger(VRTK_ControllerReference.GetRealIndex(e.controllerReference), <span class="string">&quot;POINTER DESTINATION&quot;</span>, e.target, e.raycastHit, e.distance, e.destinationPosition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h3 id=&quot;配置环境&quot;&gt;&lt;a href=&quot;#配置环境&quot; class=&quot;headerlink&quot; title=&quot;配置环境&quot;&gt;&lt;/a&gt;配置环境&lt;/h3&gt;&lt;p&gt;unity 2018.4.14&lt;br&gt;VRTK 3.3.0&lt;br&gt;steam</summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="错误总结" scheme="http://kennyyyyyy.github.io/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="经验" scheme="http://kennyyyyyy.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://kennyyyyyy.github.io/2021/04/25/Web/"/>
    <id>http://kennyyyyyy.github.io/2021/04/25/Web/</id>
    <published>2021-04-25T08:12:15.000Z</published>
    <updated>2021-04-26T09:49:10.622Z</updated>
    
    <content type="html"><![CDATA[<!--  more --><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>外部JavaScript脚本的调用：<code>&lt;script  src = &quot;../../路径&quot;&gt;&lt;/scripts&gt;</code></p><p>NaN：not a Number</p><p>逻辑运算（&amp;&amp;）：谁在表达式中起关键性作用，结果就是谁<br>例：<code>true &amp;&amp; 4 &amp;&amp; “aaa”</code><br>x输出 “aaa”</p><p>0 &nbsp;&nbsp; “0” &nbsp;&nbsp; “” &nbsp;&nbsp; null &nbsp;&nbsp; NaN &nbsp;&nbsp; undefined  =&gt; false</p><p>用 new 创建的对象为引用类型（object）</p><h2 id="预定义函数"><a href="#预定义函数" class="headerlink" title="预定义函数"></a>预定义函数</h2><p>parseInt():将字符转化为Int</p><p>eval(string):string为一个可计算的字符串或者是可执行的表达式</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>可以为一个类创建一个共有的模板<br>新new的对象会调用模板中的属性</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>cars = [“0”, 2, new Object()];</code>//数组中的元素可以不同</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join() : 将数组中的元素拼接成字符串，默认连接符为“,”</p><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>splice(index, howmany, [item1, … , itemx], item, …) : howmany为从index的位置开始删除元素的个数，后面的为插入的元素</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort(function(a,b){return b - a}); 数字的降序排列<br><br>sort(function(a,b){return a - b}); 数字的升序排列</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>unix时间戳，从1970.1.1到xxxx.xx.xx的毫秒数</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="round-四舍五入"><a href="#round-四舍五入" class="headerlink" title="round() 四舍五入"></a>round() 四舍五入</h3><h3 id="random-返回0-1的随机数"><a href="#random-返回0-1的随机数" class="headerlink" title="random() 返回0~1的随机数"></a>random() 返回0~1的随机数</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;!--  more --&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;外部JavaScript脚本的调用：&lt;code&gt;&amp;lt;script  src = &amp;quot;../../路</summary>
      
    
    
    
    <category term="Web" scheme="http://kennyyyyyy.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>数电</title>
    <link href="http://kennyyyyyy.github.io/2021/04/19/%E6%95%B0%E7%94%B5/"/>
    <id>http://kennyyyyyy.github.io/2021/04/19/%E6%95%B0%E7%94%B5/</id>
    <published>2021-04-19T13:05:33.000Z</published>
    <updated>2021-04-20T12:39:26.832Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="第四章：组合逻辑电路"><a href="#第四章：组合逻辑电路" class="headerlink" title="第四章：组合逻辑电路"></a>第四章：组合逻辑电路</h1><h2 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h2><p><img src="/images/数电/1.二进制编码器.png" alt="二进制编码器"></p><p><img src="/images/数电/1.2-10进制编码器.png" alt="2-10进制编码器"></p><p><img src="/images/数电/1.优先编码器.png" alt="优先编码器"></p><p><img src="/images/数电/1.2-10进制优先编码器.png" alt="2-10进制优先编码器"></p><h2 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h2><p><img src="/images/数电/2.二进制译码器-低电平有效.png" alt="二进制译码器-低电平有效"> <img src="/images/数电/2.二进制译码器-高电平有效.png" alt="二进制译码器-高电平有效"> </p><p><img src="/images/数电/2.3线-8线译码器.png" alt="3线-8线译码器"></p><p><img src="/images/数电/2.2-10进制译码器.png" alt="2-10进制译码器"></p><p><img src="/images/数电/2.数码显示译码器.png" alt="数码显示译码器"></p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p><img src="/images/数电/3.数据选择器.png" alt="数据选择器"></p><script type="math/tex; mode=display">\mid \mathrm{Y}_{1}=\left[\mathrm{D}_{10}\left(\mathrm{~A}_{1} \mathrm{~A}_{0}^{\prime}\right)+\mathrm{D}_{11}\left(\mathrm{~A}_{1}^{\prime} \mathrm{A}_{0}\right)+\mathrm{D}_{12}\left(\mathrm{~A}_{1} \mathrm{~A}_{0}^{\prime}\right)+\mathrm{D}_{13}\left(\mathrm{~A}_{1} \mathrm{~A}_{0}\right)\right]^{*} \mathrm{~S}_{1}</script><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><h3 id="一位加法器"><a href="#一位加法器" class="headerlink" title="一位加法器"></a>一位加法器</h3><p><img src="/images/数电/4.1位加法器-半加器.png" alt="半加器"></p><p><img src="/images/数电/4.1位加法器-全加器.png" alt="全加器"></p><h3 id="多位加法器"><a href="#多位加法器" class="headerlink" title="多位加法器"></a>多位加法器</h3><p><img src="/images/数电/4.多为加法器-超前进位加法器.png" alt="超前进位加法器"></p><p><img src="/images/数电/4.多为加法器-串行进位加法器.png" alt="串行进位加法器"> </p><script type="math/tex; mode=display">\begin{array}{l}(\boldsymbol{C I})_{i}=(\boldsymbol{C O})_{i-1} \\\boldsymbol{S}_{i}=\boldsymbol{A}_{i} \oplus \boldsymbol{B}_{i} \oplus(\boldsymbol{C I})_{i} \\(\boldsymbol{C O})_{i}=A_{i} \boldsymbol{B}_{i}+\left(\boldsymbol{A}_{i}+\boldsymbol{B}_{i}\right)(\boldsymbol{C I})_{i}\end{array}</script><h2 id="数值比较器"><a href="#数值比较器" class="headerlink" title="数值比较器"></a>数值比较器</h2><h3 id="一位数值比较器"><a href="#一位数值比较器" class="headerlink" title="一位数值比较器"></a>一位数值比较器</h3><p><img src="/images/数电/5.一位数值比较器.png" alt="一位数值比较器"></p><p><img src="/images/数电/5.多位数值比较器.png" alt="多位数值比较器"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h1 id=&quot;第四章：组合逻辑电路&quot;&gt;&lt;a href=&quot;#第四章：组合逻辑电路&quot; class=&quot;headerlink&quot; title=&quot;第四章：组合逻辑电路&quot;&gt;&lt;/a&gt;第四章：组合逻辑电路&lt;/h1&gt;&lt;h2 id=&quot;编码器&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="数电" scheme="http://kennyyyyyy.github.io/categories/%E6%95%B0%E7%94%B5/"/>
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TANKS! Unity Tutorial 项目学习记录</title>
    <link href="http://kennyyyyyy.github.io/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://kennyyyyyy.github.io/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-13T15:25:35.000Z</published>
    <updated>2021-07-23T08:11:27.216Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="SmoothDamp"><a href="#SmoothDamp" class="headerlink" title="SmoothDamp"></a>SmoothDamp</h3><p>平滑的改变当前值至另一个值<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mathf.SmoothDamp(<span class="built_in">float</span> current, <span class="built_in">float</span> target, <span class="keyword">ref</span> <span class="built_in">float</span> currentVelocity, <span class="built_in">float</span> smoothTime, <span class="built_in">float</span> maxSpeed = Mathf.Infinity, <span class="built_in">float</span> deltaTime = Time.deltaTime);</span><br><span class="line"></span><br><span class="line"><span class="function">Vector3 <span class="title">SmoothDamp</span>(<span class="params">Vector3 current, Vector3 target, <span class="keyword">ref</span> Vector3 currentVelocity, <span class="built_in">float</span> smoothTime, <span class="built_in">float</span> maxSpeed = Mathf.Infinity, <span class="built_in">float</span> deltaTime = Time.deltaTime</span>)</span>;</span><br></pre></td></tr></table></figure></p><font color="#c77eb5" size="2"> *current*：当前位置 </font><font color="#c77eb5" size="2"> *target*：尝试达到的目标值 </font><font color="#c77eb5" size="2"> *currentVelocity*：当前速度，该值在每次调用时都会由函数修改。</font><font color="#c77eb5" size="2"> *smoothTime*：达到目标值的时间 </font><font color="#c77eb5" size="2"> *maxSpeed*：最大速度 </font><font color="#c77eb5" size="2"> *deltaTime*：默认为Time.deltatime </font><font color="#c77eb5" size="2"> *ref关键字*：相当于c的指针传参，及引用传参。 </font><h3 id="InverseTransformPoint"><a href="#InverseTransformPoint" class="headerlink" title="InverseTransformPoint"></a>InverseTransformPoint</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">InverseTransformPoint</span>(<span class="params">Vector3 position</span>)</span>;</span><br></pre></td></tr></table></figure><p>将position这个Vector3类型变量转化为 以V3的世界坐标为零点基准的情况下 position相对于V3的坐标值。</p><h3 id="Physics"><a href="#Physics" class="headerlink" title="Physics"></a>Physics</h3><h4 id="Physics-OverlapSphere"><a href="#Physics-OverlapSphere" class="headerlink" title="Physics.OverlapSphere"></a>Physics.OverlapSphere</h4><p>检测范围内的Collider<br><code> public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal);</code></p><font color="#c77eb5" size="2"> *position*：圆心 </font><font color="#c77eb5" size="2"> *radius*：检测半径 </font><font color="#c77eb5" size="2"> *layerMask*：检测层级 </font><font color="#c77eb5" size="2"> *queryTriggerInteraction*：判断是否应该检测Trigger </font><h3 id="Rigidbody"><a href="#Rigidbody" class="headerlink" title="Rigidbody"></a>Rigidbody</h3><h4 id="targetRigidbody-AddExplosionForce"><a href="#targetRigidbody-AddExplosionForce" class="headerlink" title="targetRigidbody.AddExplosionForce"></a>targetRigidbody.AddExplosionForce</h4><p>爆炸力将随着到物体的距离变小。<br><code> public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)); </code></p><font color="#c77eb5" size="2"> *explosionForce*：爆炸的力量（会根据距离变化）</font><font color="#c77eb5" size="2"> *explosionPosition*：爆炸中心 </font><font color="#c77eb5" size="2"> *explosionRadius*：爆炸半径 </font><font color="#c77eb5" size="2"> *upwardsModifier*：可以调整爆炸的位置，让物体有被炸起来向上的效果，但爆炸本身的位置不变 </font><font color="#c77eb5" size="2"> *ForceMode*：对物体施加力的方法 </font><h2 id="Manual"><a href="#Manual" class="headerlink" title="Manual"></a>Manual</h2><h3 id="相机的两种投影方式"><a href="#相机的两种投影方式" class="headerlink" title="相机的两种投影方式"></a>相机的两种投影方式</h3><p><img src="/images/Tanks项目学习记录/00.jpg" alt="相机的两种投影方式(prejection)"></p><p>透视投影(Perspective)(左): 正交投影的观察体是长方体，它使用一组平行投影将三维对象投影到投影平面上去，即场景中的物体没有近大远小的效果。</p><p>正交投影(Orthographic)(右): 透视投影的观察体是视锥体，它使用一组由投影中心产生的放射投影线，将三维对象投影到投影平面上去，即屏幕中的物体存在透视效果</p><h3 id="Aodio-Mixer"><a href="#Aodio-Mixer" class="headerlink" title="Aodio Mixer"></a>Aodio Mixer</h3><p>类似于Windows的音量合成器，但更为复杂<br>可以用来进行多种音效的混合表现<br>要用可百度学习</p><h2 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h2><h3 id="移动和旋转问题"><a href="#移动和旋转问题" class="headerlink" title="移动和旋转问题"></a>移动和旋转问题</h3><p>有问题的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 move = Vector3.forward * m_MovementInputValue * Time.deltaTime * m_Speed;</span><br><span class="line">m_Rigidbody.MovePosition(m_Rigidbody.position + move);</span><br></pre></td></tr></table></figure><p>此代码会导致物体旋转后会继续以世界坐标的z轴为前后方向，而导致旋转看起来不起作用，像坐标轴没有跟着旋转一样</p><hr><p>正确的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 move = transform.forward * m_MovementInputValue * Time.deltaTime * m_Speed;</span><br><span class="line">m_Rigidbody.MovePosition(m_Rigidbody.position + move);</span><br></pre></td></tr></table></figure><p>修改后一切正常</p><hr><div class="panel panel-warning">    <div class="panel-title">Vector3.forward和transform.forward的区别</div>    <div class="panel-body">        <p>Vector3.forward的值永远是世界坐标（0,0,1），<br>而transform.forward是世界坐标对应的物体坐标的轴的向量</p>    </div>    </div><h2 id="代码记录"><a href="#代码记录" class="headerlink" title="代码记录"></a>代码记录</h2><h3 id="相机的平滑运动"><a href="#相机的平滑运动" class="headerlink" title="相机的平滑运动"></a>相机的平滑运动</h3><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>移动相关</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FindAveragePosition();</span><br><span class="line"></span><br><span class="line">    transform.position = Vector3.SmoothDamp(transform.position, m_DesiredPosition, <span class="keyword">ref</span> m_MoveVelocity, m_DampTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 找到多个Player的中间位置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FindAveragePosition</span>(<span class="params"></span>)                      </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3 averagePos = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录还存在的Player的数量</span></span><br><span class="line">    <span class="built_in">int</span> numTargets = <span class="number">0</span>;                                 </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_Targets.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_Targets[i].gameObject.activeSelf)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录Player的位置和</span></span><br><span class="line">        averagePos += m_Targets[i].position;            </span><br><span class="line">        numTargets++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到中间位置</span></span><br><span class="line">    <span class="keyword">if</span> (numTargets &gt; <span class="number">0</span>)                              </span><br><span class="line">        averagePos /= numTargets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证相机的y轴不移动</span></span><br><span class="line">    averagePos.y = transform.position.y;               </span><br><span class="line"></span><br><span class="line">    m_DesiredPosition = averagePos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>缩放相关</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Zoom</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">float</span> requiredSize = FindRequiredSize();</span><br><span class="line">    m_Camera.orthographicSize = Mathf.SmoothDamp(m_Camera.orthographicSize, requiredSize, <span class="keyword">ref</span> m_ZoomSpeed, m_DampTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 找到需要的相机的最大大小</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回相机的合适大小<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">float</span> <span class="title">FindRequiredSize</span>(<span class="params"></span>)                    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获得相机将要到达的位置的相对坐标</span></span><br><span class="line">    Vector3 desiredLocalPos = transform.InverseTransformPoint(m_DesiredPosition);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> size = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得还存活的Player的所需要的屏幕最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_Targets.Length; i++)                                      </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_Targets[i].gameObject.activeSelf)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转化Player的坐标为相对值</span></span><br><span class="line">        Vector3 targetLocalPos = transform.InverseTransformPoint(m_Targets[i].position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Player中心位置与Player位置的差值</span></span><br><span class="line">        Vector3 desiredPosToTarget = targetLocalPos - desiredLocalPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算x/y轴的相对大小，并取最大值</span></span><br><span class="line">        size = Mathf.Max (size, Mathf.Abs (desiredPosToTarget.y));                  </span><br><span class="line"></span><br><span class="line">        size = Mathf.Max (size, Mathf.Abs (desiredPosToTarget.x) / m_Camera.aspect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加缓冲区</span></span><br><span class="line">    size += m_ScreenEdgeBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止屏幕缩小</span></span><br><span class="line">    size = Mathf.Max(size, m_MinSize);                                              </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><h3 id="炮弹的爆炸和伤害判定"><a href="#炮弹的爆炸和伤害判定" class="headerlink" title="炮弹的爆炸和伤害判定"></a>炮弹的爆炸和伤害判定</h3><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>爆炸相关</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得爆炸范围内的坦克collider</span></span><br><span class="line">    Collider[] colliders = Physics.OverlapSphere(transform.position, m_ExplosionRadius, m_TankMask);<span class="comment">//获得爆炸范围内的坦克collider</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Rigidbody targetRigidbody = colliders[i].GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!targetRigidbody)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对范围内的tank的刚体施加一个力</span></span><br><span class="line">        targetRigidbody.AddExplosionForce(m_ExplosionForce, transform.position, m_ExplosionRadius);<span class="comment">//将</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Tank的血量属性</span></span><br><span class="line">        TankHealth tankHealth = targetRigidbody.GetComponent&lt;TankHealth&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tankHealth)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算伤害</span></span><br><span class="line">        <span class="built_in">float</span> damage = CalculateDamage(targetRigidbody.position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//造成伤害</span></span><br><span class="line">        tankHealth.TakeDamage(damage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//粒子效果和声音的播放</span></span><br><span class="line">    m_ExplosionParticles.transform.parent = <span class="literal">null</span>;</span><br><span class="line">    m_ExplosionParticles.Play();</span><br><span class="line">    m_ExplosionAudio.Play();</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">    Destroy(m_ExplosionParticles.gameObject, m_ExplosionParticles.main.duration);</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>计算伤害</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">float</span> <span class="title">CalculateDamage</span>(<span class="params">Vector3 targetPosition</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算Tank和炸弹的向量</span></span><br><span class="line">    Vector3 explosionToTarget = targetPosition - transform.position;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得距离</span></span><br><span class="line">    <span class="built_in">float</span> explosionDistance = explosionToTarget.magnitude;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算相对距离比例</span></span><br><span class="line">    <span class="built_in">float</span> relativeDistance = (m_ExplosionRadius - explosionDistance) / m_ExplosionRadius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算伤害</span></span><br><span class="line">    <span class="built_in">float</span> damage = relativeDistance * m_MaxDamage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排除Tank在边缘时 相对比例 为负数的情况</span></span><br><span class="line">    damage = Mathf.Max(<span class="number">0</span>, damage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> damage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>     </div></div>    </div><h2 id="子弹的对象池模式"><a href="#子弹的对象池模式" class="headerlink" title="子弹的对象池模式"></a>子弹的对象池模式</h2><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>子弹</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShellExplosion</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPooler</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ...一些其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成时的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSpawning</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="comment">/* 初始化相关 */</span></span><br><span class="line">        StartCoroutine(Spawning());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用协程，一定时间后重置</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Spawning</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> m_TimeToFalse;</span><br><span class="line">        m_ExplosionParticles.transform.parent = gameObject.transform;</span><br><span class="line">        m_ExplosionParticles.transform.position = gameObject.transform.position;</span><br><span class="line">        gameObject.transform.position = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>对象池</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShellPool</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对象池</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> tag:名称</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> prefab;预制体</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> size:对象池的大小</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pool</span>                          </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> tag;</span><br><span class="line">        <span class="keyword">public</span> GameObject prefab;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象池的父物体</span></span><br><span class="line">    <span class="keyword">public</span> Transform parentTransform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Pool&gt; poolList;</span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, Queue&lt;GameObject&gt;&gt; poolDictionary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ShellPool shellPoolInsatance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shellPoolInsatance == <span class="literal">null</span>)</span><br><span class="line">            shellPoolInsatance = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (shellPoolInsatance != <span class="keyword">this</span>)</span><br><span class="line">            Destroy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化生成所有对象池的物体，并添加到对象池字典中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        poolDictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Queue&lt;GameObject&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> pool <span class="keyword">in</span> poolList)</span><br><span class="line">        &#123;</span><br><span class="line">            Queue&lt;GameObject&gt; tPool = <span class="keyword">new</span> Queue&lt;GameObject&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pool.size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                GameObject tShell = Instantiate(pool.prefab, parentTransform,<span class="literal">true</span>);</span><br><span class="line">                tShell.SetActive(<span class="literal">false</span>);</span><br><span class="line">                tPool.Enqueue(tShell);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            poolDictionary.Add(pool.tag, tPool);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 从对象池中生成（获得）物体</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;tag&quot;&gt;</span>物体名称<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;position&quot;&gt;</span>生成位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rotation&quot;&gt;</span>生成旋转<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回生成的对象<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">SpawnFromPool</span>(<span class="params"><span class="built_in">string</span> tag, Vector3 position, Quaternion rotation</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//判断是否存在需要生成的物体</span></span><br><span class="line">        <span class="keyword">if</span>(!poolDictionary.ContainsKey(tag))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(tag + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GameObject theSpawnObj = poolDictionary[tag].Dequeue();</span><br><span class="line">        Debug.Log(theSpawnObj);</span><br><span class="line"></span><br><span class="line">        theSpawnObj.SetActive(<span class="literal">true</span>);</span><br><span class="line">        theSpawnObj.transform.position = position;</span><br><span class="line">        theSpawnObj.transform.rotation = rotation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得IPooler接口，并调用初始化函数</span></span><br><span class="line">        IPooler poolSpawn = theSpawnObj.GetComponent&lt;IPooler&gt;();</span><br><span class="line">        <span class="keyword">if</span> (poolSpawn != <span class="literal">null</span>)</span><br><span class="line">            poolSpawn.OnSpawning();</span><br><span class="line"></span><br><span class="line">        poolDictionary[tag].Enqueue(theSpawnObj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> theSpawnObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>IPooler</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口，方便生成物体后的初始化函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IPooler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSpawning</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><h3 id="游戏循环模式-协程完成"><a href="#游戏循环模式-协程完成" class="headerlink" title="游戏循环模式(协程完成)"></a>游戏循环模式(协程完成)</h3><p><img src="/images/Tanks项目学习记录/游戏循环.jpg" alt="循环模式"><br><img src="/images/Tanks项目学习记录/流程控制.jpg" alt="Tanks的流程控制"></p><h3 id="游戏管理模式"><a href="#游戏管理模式" class="headerlink" title="游戏管理模式"></a>游戏管理模式</h3><p>一些游戏物体的代码不需要继承MonoBehaviour（无需挂载），只当实例化后赋予其GameObject或直接更具里面的信息实例化一个物体。例如此例中的Tank 或者 一些随机地图的部分地图信息</p><h3 id="可能的心得-……"><a href="#可能的心得-……" class="headerlink" title="可能的心得(……..)"></a>可能的心得(……..)</h3><ul><li>协程内调用多个协程，只会在上一个协程调用完成后，下一个协程才会开始</li><li>回合制的游戏可以使用协程控制游戏流程，开始、游玩、结束，都很清晰明了</li><li>写代码时因该将所有功能块写成函数，可以让代码结构更清晰</li><li>尽量将可能的变量全定义在类的开头，理由同上</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h2&gt;&lt;h3 id=&quot;SmoothDamp&quot;&gt;&lt;a href=&quot;#SmoothDamp&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="http://kennyyyyyy.github.io/tags/Unity/"/>
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>部署网站的记录</title>
    <link href="http://kennyyyyyy.github.io/2021/04/13/Demo/"/>
    <id>http://kennyyyyyy.github.io/2021/04/13/Demo/</id>
    <published>2021-04-13T08:56:13.000Z</published>
    <updated>2021-09-16T08:46:56.393Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="网页属性"><a href="#网页属性" class="headerlink" title="网页属性"></a>网页属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建时间</span><br><span class="line">categories: 分类</span><br><span class="line">tags:标签</span><br><span class="line">- Tag0</span><br><span class="line">- Tag1</span><br><span class="line">- Tag2</span><br><span class="line">sticky: 100数字越大优先级越高</span><br><span class="line">pic:指定预览图片，图片位置为同级目录下的同名文件夹</span><br><span class="line">comments: <span class="literal">true</span>是否开放评论</span><br><span class="line">toc: <span class="literal">true</span>是否生成目录</span><br><span class="line">only:在什么位置显示，如果没有就全部显示</span><br><span class="line">- home</span><br><span class="line">- category</span><br><span class="line">- tag</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>提示信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% alertbox success <span class="string">&quot;成功&quot;</span> %&#125;</span><br><span class="line">&#123;% alertbox danger <span class="string">&quot;危险&quot;</span> %&#125;</span><br><span class="line">&#123;% alertbox info <span class="string">&quot;消息&quot;</span> %&#125;</span><br><span class="line">&#123;% alertbox warning <span class="string">&quot;警告&quot;</span> %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="折叠相关"><a href="#折叠相关" class="headerlink" title="折叠相关"></a>折叠相关</h3><div class="xControl">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>折叠的折叠框</span></div>    <div class="xContent"><div class="inner">        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% collapse 折叠框的标题 %&#125;</span><br><span class="line"></span><br><span class="line">被折叠的内容 1</span><br><span class="line">被折叠的内容 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;% endcollapse %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><div class="xControl active">    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>预先打开的折叠框</span></div>    <div class="xContent pre-open"><div class="inner">        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% collapse 折叠框的标题 open %&#125;</span><br><span class="line"></span><br><span class="line">被折叠的内容 1</span><br><span class="line">被折叠的内容 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;% endcollapse %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>     </div></div>    </div><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><div class="panel panel-info">    <div class="panel-title">提示框</div>    <div class="panel-body">        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% colorpanel TYPE 面板框的标题 %&#125;</span><br><span class="line"></span><br><span class="line">面板里的内容 1</span><br><span class="line">面板里的内容 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;% endcolorpanel %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>type是框的类型<br>·successs<br>·danger<br>·info<br>·warning</p>    </div>    </div><h3 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h3><p>图片需要放在source文件夹下的images下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](/images/图片名称.jpg)  </span><br><span class="line"></span><br><span class="line">![图片描述](/images/文件夹/图片名称.jpg) </span><br></pre></td></tr></table></figure></p><p><img src="/images/Demo/00.jpg" alt="图片插入"> </p><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=<span class="comment">#00ffff&gt;color=#00ffff&lt;/font&gt;</span></span><br></pre></td></tr></table></figure><font color="#00ffff">color=#00ffff</font><p><a href="https://www.5tu.cn/colors/yansebiao.html">颜色表参考</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://candinya.com/posts/Kratos-Rebirth-Manual/#%E5%AE%89%E8%A3%85%E6%8F%90%E7%A4%BA">部分参考来源</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;h3 id=&quot;网页属性&quot;&gt;&lt;a href=&quot;#网页属性&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习" scheme="http://kennyyyyyy.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="错误总结" scheme="http://kennyyyyyy.github.io/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    
    <category term="经验" scheme="http://kennyyyyyy.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
