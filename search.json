[{"title":"嵌入式基础","date":"2023-08-05T14:38:47.000Z","url":"/2023/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/","categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 名词解释 串口：串口是一种用于在计算机和外部设备之间进行通信的接口。串口可以通过传输一位一位的数据来实现通信，常见的有RS-232串口和USB串口。在嵌入式领域，串口通常被用于连接开发板和计算机，用于传输数据、进行调试或者配置设备。串口通常包含发送线、接收线和地线等信号线。 MCU：MCU（Microcontroller Unit）是一种集成了微处理器核心、存储器、输入/输出接口和其他外设模块的单芯片微型计算机系统。 问题记录 该电路中电容的作用？上电后让NRST保持一段时间低电平（电容电压不突变），使其复位。 1、单片机简介 2、STM32 ST：半导体；M：MCU/MPU；32位 ST中文社区网 命名规则 3、最小系统和IO分配 最小系统：保证MCU正常工作的最小电路组成单元 优先分配特定外设IO，然后分配通用IO，最后微调 "},{"title":"毕设记录","date":"2022-12-06T05:33:31.000Z","url":"/2022/12/06/%E6%AF%95%E8%AE%BE%E8%AE%B0%E5%BD%95/","tags":[["Unity","/tags/Unity/"]],"categories":[["undefined",""]],"content":" 选题描述主要内容：基于Unity3D引擎的一个2D平台跳跃类游戏。玩家可以在多个地图之中活动，每个地图上会存在一些对应的功能或物体。例如某个地图中存在商店，可以给玩家提供升级武器或购买道具的选项。一些地图中则存在怪物，打败怪物后会掉落金币，用于商店物品的购买。玩家可以随时存档，存档会保存当前玩家的状态数据和位置信息等，下次进入会读取上次的信息，继续游戏。 策划（旧）（地图设计太难）总目标 复刻空洞骑士 类银河恶魔城游戏设计 项目通过GitHub来管理 资源先通过免费素材代替 系统设计分析玩家模块设计 移动 正常左右移动 冲刺 游玩过程中获得 只能水品方向冲刺 跳跃 通过按键时间的长短控制跳跃高度 二段跳需要游玩过程中获得 攻击 攻击分为 上下左右 四个方向 攻击在一些特定的物体（无法破坏的物体，例如地面尖刺、怪物护盾等）上，会将自己击退 基础属性 血量：血量降到零时，玩家或死亡。可以通过血瓶回复血量，通过商店购买对应的物品提升上限 攻击力：可以通过购买对应物品升级攻击力（升级武器） 基础物品 血瓶：需要从NPC中购买（或地图中探索获得），血瓶可以重复使用，只存在使用次数的限制。玩家每次 存档或复活都会使使用次数回满。商店处可以购买使次数提升的物品 敌人模块设计 AI逻辑 采用状态机来实现敌人的移动和攻击。目前考虑：普通怪物的状态机可以复用（移动，攻击、防御、死亡等），BOSS的状态机单独设计（二阶段的模式设计） 动画 动画采用帧动画，先找免费素材 地图模块设计 敌人刷新 游戏每次重新加载，地图中的敌人便会进行刷新。（重新加载包括：死亡后复活、存档后读档、传送等） 地图传送 一些地图当中存在传送点，玩家可以在所有已经激活的传送点之间进行传送 商店 商店即为NPC，地图中会存在NPC，他们会出售一些增益物品（武器升级，功能升级等） 地图总览 玩家所有探索过的地图区域都可以在其中预览 特定NPC出可以购买地图，能让玩家提前预览未探索的区域 地图探索 地图中存在一些特殊物体，可以通过攻击互动 地图中存在隐藏路径，有一些奖励 地图设计 钥匙与锁 能力锁：一些地图的点需要获得某些能力之后才能到达。一些高度需要二段跳才能跳上去，一些坑需要冲刺才能通过 挑战锁：有些地方需要打败特殊敌人才能解锁（打包BOSS） 物品锁：可以通过钥匙打开一些门，开通近路 回路探索： NPC模块设计 NPC为地图中功能的载体（或许有任务系统），可以通过和NPC对话来调用相关的功能 流程（新）改为类死亡细胞 随机地图设计​ 使用 Edgar插件，采用预先设计模板和随机连接的方式生成地图 Edgar 制作地图模板（包括房间和连接），通过Level Graph对设计房间连接规则 普通的Level Graph中房间节点无房间类型，若需要特殊房间则要为此节点单独添加模板 通过Custom Input Task 可以对其进行拓展，新增类需要继承DungeonGeneratorInputBaseGrid2D。例如新增房间类型，每种类型有对应的模板，这样就无需对每个房间单独添加，只需要选择类型即可 在room templates中，每个tile必须至少于两个tile连接 Dungeon generator（地图生成器）/ Platformer generator 它是一个组件，存在Level Graph字段和Post Processing字段等 定义了地图的生成规则 后处理（Post Processing） 用户后处理脚本需继承DungeonGeneratorPostProcessingGrid2D，并重载Run函数，后处理逻辑由Run执行 后处理的逻辑在地图生成后执行。例如将角色的位置移动至出生点、生成敌人等 地图案例 现阶段问题 地图模板设计 后处理逻辑 角色控制 基础控制（走、跑、跳（二段）、冲刺），可添加额外控制（蹲、爬、滑墙、滑铲、蹬强跳等） 跳跃 跳跃检测和跳跃实现分开判断 在地面状态时重置跳跃次数 滑墙 通过射线检测，判断角色前方是否存在墙体，当角色不在地面且前方存在墙体时进入滑墙状态 当x轴输入方向和墙的方向一致时才进入滑墙 在滑墙状态下重置跳跃次数 蹬墙跳： 在滑墙的基础下实现 当角色在滑墙状态时，用户可以通过直接跳跃落下墙体或者通过方向加跳跃进行蹬墙跳 两种跳跃通过预设定的方向和力实现 设置canMove和canFlip两个参数，优化蹬墙跳的手感。即当在滑墙状态下输入反方向时的一小段时间内使角色无法移动和转向 问题： 跳跃感觉在月球 调整重力大小 跳跃直接修改速度而非添加力 冲刺有bug 设置其他条件，当碰到墙壁或时间结束都结束冲刺 冲刺过程中屏蔽跳跃和移动 攻击等需要设计 有限状态机敌人状态控制 Entity 敌人实体的基类 FiniteStateMachine 管理Entity当前状态，执行对应的逻辑 State 状态类，每个状态有对应的逻辑 状态转换图 enemy1：近战 enemy2：远程 Player 状态机（分层状态机） Ledge Climb： 分为三个状态，在动画状态机中用sub-state machine完成动画状态转换 Input System Descirption:The Input System package implements a system to use any kind of Input Device to control your Unity content. It’s intended to be a more powerful, flexible, and configurable replacement for Unity’s classic Input Manager (the UnityEngine.Input class). InputSystem对大部分常用的输入设备都定义了详细的控制类，其中具体的控制项则基于InputControl基类派生出的各种处理类，包括但不仅限于AxisControl，ButtonControl，TouchControl等。可以很方便的对多个设备的输入进行处理 Animator 子状态机（Sub-State Machine） 战斗系统目标是一个框架，能够方便的装备和取消装备，且敌人也能如此 武器让武器成为有限状态机的一个完全独立的实体，每个武器对应一个单一的攻击状态 每个武器类决定攻击状态如何和武器交互 武器结构如图 分为角色（base）和武器（weapon），base控制角色动画，weapon控制武器动画，并添加有碰撞器，用于攻击检测 sprite 切换回调 SpriteRenderer.RegsiterSpriteChangeCallback(UnityAction&lt;SpriteRenderer&gt; callback); Entity重构将所有Entity公用的方法和变量抽象成另一个类，其他Entity中增加一个对其的引用，增加代码复用性，并方便管理 Movement：控制移动 CollisionSenses：控制物理检测部分 Combat：控制战斗和受伤部分，继承IDamageable、IKnockbackable等接口，并有collider用于被攻击的触发检测 Stats：用于记录所有的数据状态，如health、mana等 ParticleManagert：例子效果管理 Death：死亡 "},{"title":"Unity功能模块整理","date":"2022-11-21T01:20:21.000Z","url":"/2022/11/21/Unity%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E6%95%B4%E7%90%86/","tags":[["Unity","/tags/Unity/"]],"categories":[["undefined",""]],"content":" Unity中的功能模块整理1、UGUI2、Animation System3、Terrain System4、Humanoid Character5、Particle System6、Timeline7、Partical Simulation8、Timemap9、Light Probe10、Audio &amp; Video11 Path Finding"},{"title":"Unity相关","date":"2022-11-06T05:46:42.000Z","url":"/2022/11/06/Unity%E7%9B%B8%E5%85%B3/","tags":[["Unity","/tags/Unity/"]],"categories":[["undefined",""]],"content":" UIToolkit 可视化UI编辑器，类似于网页前端的编写 缺点（暂时，官方已在优化） 不依赖于GameObject工作流，难以制作放置在3D世界中的可互动的UI； 不支持Shader，特效制作不方便； 不支持Animator，无法制作实时循环动画（自带了Transition动画系统）。 Tilemap 问题1：摄像机视角中会出现虚线 解决办法：修改Tilemap Renderer中的材质，材质属性如下 其他API SendMessage 调用GameObject挂载的Script里对应的函数 SendMessage (“函数名”,参数，SendMessageOptions) 缺点 过于依赖反射机制(reflection)来查找消息对应的被调用函数 频繁使用反射会影响性能 更会大大增加代码的维护成本 — 字符串标识对应方法 无视访问权限, 能够调用private的方法 — 若有一个是有方法在声明的类中没有被使用，那正常情况下都会把它认为是废代码从而删除，这时隐患就出现了 AddTorque public void AddTorque(Vector3 torque, ForceMode mode = ForceMode.Force); 功能：对刚体施加一个旋转力。 参数介绍： torque 决定旋转力的大小和旋转轴的方向，旋转方向参照左手定则 mode 决定作用力的模式，缺省方式为ForceMode.Force Transform transform.parent.GetComponent 只找直属父级 transform.GetComponentInParrent 一直往上查找所有父级，直到找到 "},{"title":"3D数学基础：图形与游戏开发","date":"2022-10-07T11:38:59.000Z","url":"/2022/10/07/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/","tags":[["Unity","/tags/Unity/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["undefined",""]],"content":" 2、笛卡尔坐标系3、多坐标系3.2 一些有用的坐标系3.2.1 世界坐标系​ 世界坐标系建立了描述其他坐标系所需要的参考框架，能够用世界坐标系描述其他坐标系的位置，而不能用更大的、外部的坐标系来描述世界坐标系。 ​ 世界坐标系的典型问题都是关于初始位置和环境的，如： 每个物体的位置和方向； 摄像机的位置和方向； 世界中没一点的地形是什么（如山丘、湖泊等）； 个物体从哪里来，到哪里去（NPC的运动策略）。 3.2.2 物体坐标系​ 物体坐标系是特定物体相关联的坐标系，每个物体都有独立的坐标系，当物体移动或改变方向时，该物体相关联的坐标系也会移动或改变方向。 ​ 世界坐标系也叫模型坐标系。 周围有需要相互作用的物体吗？（我要攻击他吗？） 哪个方向？前面？左边？ 3.2.3 摄像机坐标系​ 摄像机坐标系是和观察者密切相关的坐标系。可以被看做是一种特殊的“物体“坐标系，该”物体“坐标系定义在摄像机的屏幕可视区域。 3D空间中的给定点在摄像机前方吗？ 某个物体是否在屏幕上？ 两个物体，谁在前？ 3.2.4 惯性坐标系​ 为了简化世界坐标系到物体坐标系的转换，引入的新的坐标系。惯性坐标系的原点和物体坐标系的原点重合，轴和世界坐标系的轴平行。 ​ 从世界坐标系到惯性坐标系只需要平移，从惯性坐标系到物体坐标系只需要旋转。 4、向量与标量5、向量运算5.2 符号约定 标量：斜体小写字母 a, b, c, d, e 向量：粗体小写 a, b, c, d, e 矩阵：粗体大写 A, B, C, D 5.10 向量点乘5.10.1 运算法则​ 向量点乘记为 a·b，为对应分量乘积的和，结果为标量。 ​ [a1,a2…an-1,an]·[b1,b2…bn-1,bn] = a1b1 + a2b2 + … + an bn 5.10.2 几何解释​ a·b = |a| |b|cosθ ​ θ = arccos((a·b)/(|a||b|)) ​ 根据θ的大小，可以判断两向量的方向。可用于判断怪物与人物的位置关系。 5.10.3 向量投影​ 给定两个向量 v 和 n ，基于向量 n, 可以将v分解为平行和垂直n的两个向量 v1和 v2 ​ v1 = n|v1|/|n| ​ ​ 5.11 向量叉乘5.10.1 运算法则​ [x1, y1, z1]x[x- y2, z2] = [y1z2 - z1y2, z1x2 - x1z2, x1y2 - y1x2] ​ 叉乘的运算优先级和点乘一样，叉乘优先计算。 5.10.2 几何解释​ 叉乘得到的向量垂直于原来的两个向量平面 ​ |a x b| = |a| |b| sinθ ​ 叉乘的结果的模值等于以ab为边的平行四边形的面积 5.12 线性代数公式​ "},{"title":"Linux网络编程","date":"2022-10-01T17:01:40.000Z","url":"/2022/10/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","tags":[["Linux","/tags/Linux/"],["Socket","/tags/Socket/"]],"categories":[["undefined",""]],"content":" Socket编程GitHub基础知识 Socket地址结构 字节序（大端/小端） 字节序转换 地址转换函数 套接字类型 流式套接字：TCP 数据包套接字：UDP 原始套接字 测试代码 结果 TCP cs模型 简单的客户端和服务端 服务端 客户端 结果 REUSEADDR 服务端断开连接的一段时间内会处于TIME_WAIT状态，再此状态下无法进行绑定连接。 服务端尽可能使用REUSERADDR 绑定前尽可能调用setsockopt来设置REUSERADDR套接字选项 使用REUSERADDR选项可以使得不必等待TIME_WAIT状态结束就可以重启服务器 处理多个客户端的连接：通过一个连接一个进程来处理并发 服务端在获得连接时创建子进程进行消息处理 客户端关闭后退出循环，并关闭进程。 服务端发送消息（一对一） 使用多进程向处理消息发送和接收 流协议与粘包 流式协议：基于字节流，无边界 粘包问题 粘包解决办法 本质是在应用层维护消息与消息的边界 固定包的长度 包结尾加上分隔符 \\r\\n (ftp) 包头加上包的长度 其他复杂应用层协议 readn &amp; writen 对 read 和 wirte 函数进行封装 包头添加长度解决粘包 read、write与recv、send ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t send(int sockfd, const void *buf, size_t len, int flags); ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); recv与read一样，都能从套接口缓冲区中获得数据 recv只能用于套接口IO，read能用于所有的IO recv可以通过选项指定接收数据的行为 MSG_OOB：接收紧急指针发送的数据（out-of-band） MSG_PEEK：接收缓冲区的数据，但不清除缓冲区的数据 封装recv_peek函数 通过包尾添加对应字符解决粘包问题（\\n） 使用recv_peek实现readline 使用recv_peek读取缓存区中的内容，直到读取到 \\n Socket相关函数 getsockname ：获得连接套接字本地的sockaddr int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen); getpeername：获得连接套接字对方的sockaddr int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen); gethostname int gethostname(char *name, size_t len); 0 for success -1 for failure gethostbyname struct hostent *gethostbyname(const char *name); h_addr equals h_addr_list[0] gethostbyaddr struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type); close和shutdown close：close终止了数据传送的两个方向。 shutdown：可以有选择的终止某个方向的数据传送或终止数据传送的两个方向。 shutdown how = 1 可以保证对等方接收到一个EOF字符，而不管其他进程是否已经打开了套接字，而close不能保证。close只有等套接字的引用计数变为零，即所有的进程都关闭了才发送。 使用shutdown(sock, SHUT_WR);代替 close(sock); 可以保证接受完缓冲区中的数据 getsockopt int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen); int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 功能：获取/设置一个套接字的选项 参数： socket：文件描述符 level：协议层次 SOL_SOCKET 套接字层次 IPPROTO_IP ip层次 IPPROTO_TCP TCP层次 option_name：选项的名称（套接字层次） SO_BROADCAST 是否允许发送广播信息 SO_REUSEADDR 是否允许重复使用本地地址 SO_SNDBUF 获取发送缓冲区长度 SO_RCVBUF 获取接收缓冲区长度 SO_RCVTIMEO 获取接收超时时间 SO_SNDTIMEO 获取发送超时时间 option_value：获取到的选项的值 option_len：value的长度 返回值： 成功：0 失败：-1 recv和recvfrom 两者可以相互替换，知识recvfrom可以接收对端的地址信息，在udp中可以很方便的进行回复操作 僵尸进程 进程中的指令已经执行完成，但是进程PCB结构还没有回收。即子进程先于父进程退出后，子进程的PCB需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程。 父进程未结束，子进程结束，但父进程没有处理子进程的退出状态（当子进程先于父进程结束，父进程没有获取子进程的退出码，子进程的PCB会保留一段时间等待父进程在PCB中获取退出码，，且该进程不可执行，此时子进程变成僵尸进程）。直到父进程获取到子进程的退出状态，子进程的PCB才会被移除。 采用信号的方式对僵尸进程进行忽略 signal(SIGCHLD, SIG_IGN) 捕捉SIGCHLD信号来避免僵尸进程 signal(SIGCHLD, handle_sigchld) TCP TCP的十一种状态 还有一种状态为 CLOSING，其产生原因是双方同时关闭 SIGPIPE信号 收到FIN信号的套接字还可以接收数据，接收到FIN只代表对方不在发送数据 在收到RST段之后，即在接收到FIN之后，再调用wirte就会产生SIGPIPE信号，对于这个信号，一般忽略处理 signal(SIGPIPE, GIS_IGN) 五种IO模型 阻塞IO 非阻塞IO 将套接口设置为非阻塞模式 fcntl(fd, F_SETFL, flag|0_NCNBLOCK) I/O复用（select和poll） select 信号驱动I/O 异步I/O：效率最高 I/O超时设置方法 alarm 使用alarm函数，超时之后会发送一个SIGALRM信号，捕捉信号就可以将阻塞函数打断，进行后续处理 套接字选项 SO_SNDTIMEO SO_RCVTIMEO setsockopt(sock, SOL_SOCKET, SO_RECVTIMEO, 5) 设置接收时间为5，超时后会产生错误代码 errno = EWOULDBLOCK Select select模型 用select来管理多个I/O，一旦其中一个或多个I/O检测到感兴趣时间，select返回，返回值为事件个数和哪些事件，然后遍历并处理这些事件。 nfds：读、写、异常集合中的文件描述符的最大值+1（select为遍历所有事件来检测） readfds：可读fd集合 writefds：可写fd集合 exceptfds：异常fd集合 timeout：超时时间结构体 select模型处理标准输入和sock I/O select模型 读、写、异常事件发生的条件 可读 套接口缓冲区有数据可读 连接的读一半关闭，即接收到FIN，读操作返回0 监听套接口，已完成链接队列不为空 套接口上发生了一个错误待处理，错误可以通过getsockopt指定SO_ERROR选项来处理 可写 套接口发送缓冲区有数据 连接的写一半关闭，即接收到RST，再次调用write 套接口上发生了一个错误待处理，错误可以通过getsockopt指定SO_ERROR选项来处理 异常 套接口存在带外数据（out-of-band） 使用select实现单进程处理服务器并发。 即使用select来监听所有套接口是否有事件待处理，当套接口存在事件待处理才调用相关函数（accept、read等），这样就不会产生阻塞。 select 实现超时 read_timeout - accept_timeout - connect_timeout select限制 用select实现并发服务器，最大并发数受以下限制 一个进程能打开的最大文件描述符限制，可以通过调整内核参数更改。最大值和内存大小有关 int getrlimit(int resource, struct rlimit *rlim); int setrlimit(int resource, const struct rlimit *rlim); 指令更改ulimit -n number select中的fd_set集合容量的限制（FD_SIZE），需要重新编译内核才能修改 Poll poll函数 参数列表 fds ：pollfd数组 nfds：数组中数据的个数 timeout：超时事件，-1为永远等待 events的类型定义在头文件 poll.h 中 POLLIN / POLLRDNORM ：可读 POLLPRI：特殊事件可读（exceptional condition）（存在带外数据等） POLLOUT / POLLWANORM：可写 POLLRDHUP：流套接字对等端关闭连接 POLLERR：错误 POLLHUP：关闭 POLLNVAL：非法请求 POLLRDBAND / POLLWRBAND：优先数据可读 / 写 poll的使用与select基本一致 区别是poll不需要额外的集合来保存需要检测的事件和返回的文件描述符，所有的相关数据都保存在响应的结构体中。 且 epoll epoll的使用 epoll_event.events事件定义：与poll大部分一致 EPOLLET：设置关联文件描述符的边缘触发行为。epoll的默认行为是级别触发的。有关边缘和级别触发事件分布体系结构的更多详细信息 epoll_create 和 epoll_create1。底层 数据结构更改，现在的epoll不使用哈希表，而是用红黑树，所以不需要size的参数 flags EPOLL_CLOEXEC：当进程执行exec后 ，文件描述符会被关闭（close-on-exec） int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); event：文件描述符 fd 所关心的事件 op：存在三种方式 EPOLL_CTL_ADD：向epoll添加文件描述符 EPOLL_CTL_MOD：修改文件描述符的event EPOLL_CTL_DEL：删除epoll中的文件描述符 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); events：返回值，包含可用事件 maxevents：最大容量 timeout：超时时间，-1 表示不超时 epoll的两种模式 EPOLLLT ： 电平触发 完全靠kernel epoll驱动，应用程序只需要处理从epoll_wait返回的fds，这些fds我们认为它们处于就绪状态。 EPOLLET ： 边沿触发 此模式下，系统仅仅通知应用程序哪些fds变成了就绪状态，一旦fd变成就绪状态，epoll将不再关注这个fd的任何状态信息，（从epoll队列移除）直到应用程序通过读写操作触发EAGAIN状态，epoll认为这个fd又变为空闲状态，那么epoll又重新关注这个fd的状态变化（重新加入epoll队列） 随着epoll_wait的返回，队列中的fds是在减少的，所以在大并发的系统中，EPOLLET更有优势。但是对程序员的要求也更高。 epoll使用案例 epoll和poll、select的区别 epoll不会随着监听fd数目的增长而降低效率 select、poll的实现是采用遍历查询的方式处理；epoll是基于回调来实现的，当fd有期望的事件发生就通过回调函数将其加入epoll的就绪队列中。 内核/用户空间内存拷贝问题，如何让内核把fd消息通知给用户空间呢？在这个问题上select/poll采取了内存拷贝方法。而epoll采用了共享内存的方式。 epoll的epoll_event结构体会保存事件的相关信息，不用遍历所有的fd集合查询 UDP 模型 简单的客户端和服务端实现 服务端 客户端 udp发送失败回得到一个异步错误（icmp错误），在接收时才能知道 通过connect解决：使套接字连接到远程地址，此时调用sendto不需要远程地址，即可以直接调用send udp实现聊天室"},{"title":"操作系统/计网/数据库","date":"2022-09-22T09:33:32.000Z","url":"/2022/09/22/%E5%85%AB%E8%82%A1/","tags":[["操作系统","/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"],["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[["undefined",""]],"content":" 操作系统 进程与线程 进程：一个在内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。 线程：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。 区别 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。 谷歌浏览器为什么是多进程 浏览器存在单进程架构和多进程架构 单进程架构 所有的功能模块都是运行在同一个进程里的。可能会导致 不稳定、不流畅、不安全。 对进程架构 具备更好的容错性，提供安全性和沙盒性。 谷歌浏览器的进程： 浏览器进程（Browser Process），浏览器的主进程，负责包括地址栏、前进后退按钮、处理网络访问、文件访问等。 渲染进程（Renderer Process），控制显示网站的选项卡内的所有内容。 插件进程（Plugin Process），控制网站使用的所有插件。 GPU（GPU Process），与其他进程隔离处理GPU任务，由于GPU处理来自多个应用程序的请求并将它们绘制在同一表面上，因此将其分为不同的过程。 网络进程（NetWork Process），负责页面的网络资源加载，之前是放在浏览器进程中的一个线程运行，现在独立出来。 编程语言中的内存管理 当软件在计算机上的目标操作系统上运行时，它需要访问计算机RAM（随机存取存储器）： 加载自己需要执行的字节码 存储被执行的程序使用的数据值和数据结构 加载程序执行所需的任何运行时系统 当软件程序使用内存时，除了用于加载字节码的空间外，它们还使用两个内存区域，堆栈和堆内存 Stack 静态内存分配，后进先出 ( LIFO ). 多线程应用程序的每个线程可以有一个堆栈。 堆栈的内存管理由操作系统完成。 存储在堆栈上的典型数据是局部变量（值类型或原语、原语常量）、指针和函数帧。 Heap 堆用于动态内存分配，与堆栈不同，程序需要使用指针在堆中查找数据。 储存具有动态大小的数据。 堆在程序的线程之间共享。 存储在堆上的典型数据是全局变量、引用类型（如对象、字符串、映射和其他复杂数据结构）。 JAVA和C++的区别（GC） Mark &amp; Sweep GC（JVM(Java/Scala/Groovy/Kotlin)、JavaScript） 遍历所有的被引用的对象，并标记。清理所有的未被标记的对象 引用计数GC（c++） 在这种方法中，每个对象都会获得一个引用计数，该计数会随着对其引用的更改而递增或递减，并且当计数变为零时完成垃圾收集。 无法处理循环引用 操作系统中的内存管理 主存储器（Main Memory） 主存储器是计算机运行的核心，是CPU和 I/O 设备共享的快速存储库，也称为RAM。 是易失性内存，断电时数据回丢失 内存管理 在不同进程之间细分内存的任务称为内存管理，用于管理进程执行期间主存和磁盘之间的操作，主要目的时实现内存的高效利用 在进程执行之前和之后分配和取消分配内存。 跟踪进程使用的内存空间。 尽量减少碎片问题。 正确使用主存。 在执行流程时保持数据完整性。 逻辑地址和物理地址 逻辑地址：虚拟地址，由cpu生成。可以定义进程的大小，更改逻辑地址 物理地址：真实地址，由MMU计算. 静态加载和动态加载 将进程加载到主内存中是由加载程序完成的。 静态加载：将整个程序加载到固定地址，需要较多的内存空间 动态加载：在动态加载中，例程在调用之前不会加载。所有例程都以可重定位加载格式驻留在磁盘上。动态加载的优点之一是永远不会加载未使用的例程。 静态链接和动态链接 要执行链接任务，需要使用链接器。链接器是一种程序，它接受一个或多个由编译器生成的目标文件，并将它们组合成一个单一的可执行文件。 静态链接：在静态链接中，链接器将所有必需的程序模块组合成单个可执行程序。所以没有运行时依赖。 动态链接：在动态链接中，每个适当的库例程引用都包含“存根”。存根是一小段代码。执行存根时，它会检查所需的例程是否已在内存中。如果不可用，则程序将例程加载到内存中。 分页 进程和进程管理 进程生命周期 new：进程首次启动/创建时的初始状态。 ready：进程在就绪队列中等待分配给处理器。 running：一旦被分配给处理器，就改为运行态。 terminated：完成或遇到错误，进入终止状态。等待从主存中删除。 计网 流媒体传输协议 传输层协议： TCP：面向连接的、可靠的、基于字节流的 SYN：同步序列号；ACK：确认字符；seq：序列号 三次握手： Client =&gt; Server : SYN = 1, seq = x Server =&gt; Client : SYN = 1, ACK = 1, seq = y, ack = x + 1 Client =&gt; Server : ACK = 1, seq = x + 1, ack = y + 1 四次挥手： Client =&gt; Server : FIN = 1, seq = x Server =&gt; Cilent : ACK = 1, seq = y, ack = x + 1 Server =&gt; Client : FIN = 1, ACK = 1, seq = z, ack = x + 1；服务端关闭 Client =&gt; Server : ACK = 1, seq = x + 1, ack = z + 1 等待两倍报文最大生存时间后客户端关闭 UDP：无连接的、不可靠的、面向数据报的 区别： TCP是一对一的传输，UDP支持一对一、一对多、多对多的交互通信 TCP首部长度长，开销较大；UDP首部8个字节，固定不变，开销较小 Socket通信： 网络编程 流程：服务端监听，客户端请求，确认连接进行通信 c++下的Socket 创建Socket 绑定端口和地址 服务端监听 服务端接收客户端请求 关闭连接 客户端发送连接请求 接收消息 发送消息 通信 Application 层 对数据进行编码 发送者信息 TCP 层 全双工通信（可以接收和发送）、可靠的（确认和重传、数据校验、分片和排序）、stream流的、协议（protocal） stream 流 ：即连续的，有前后、有顺序的。在任意指定时刻，可读的数据量都是不确定的 如何优化包传输/即包大小 packet 包：不连续的，以包为发送单位。 IP 层 对端的身份的定位 Domain Name Service DNS：域名解析服务 将网址翻译成一个能够在互联网上找到相应的服务器的IP地址。 网络编程模型 select 单线程模型，阻塞操作 只能同时处理一个client的连接，没有处理多个连接的能力 多线程模型 每个client对应一个线程连接 管理线程过多，效率过低 多路复用模型(epoll) 一个线程可以对应多个连接 相当于线程池 一个线程处理多个连接（epoll） ready list 保存所有的就绪fd的指针 每次挂起操作只会从ready list中查找就绪的fd io uring submission：提交的请求操作列表 complete：请求操作的返回结果 用户态可访问的无锁环形队列 HTTP：超文本传输协议 发展过程 HTTP/0.9 只有 GET 没有标题/响应的必须是HTML HTTP/1.0 增加了HOST 可以处理其他格式的响应（图像、视频等） 添加了跟多的方法（POST、HEAD） 添加了状态码以识别响应 响应格式 不能有多个请求，对于任意的下一个请求，都需要新建一个连接 HTTP/1.1 添加了新的方法（PUT、PATCH、OPTIONS、DELETE） 持久连接：一个链接可以处理多个请求 引入了对流水线（pipelining）的支持，即客户端可以发送多个请求，不需要等待服务器的响应，而服务器必须按接收顺序发送响应 HTTP/2 二进制 替换 文本 多路复用：通过单个连接处理多个http请求 使用HPACK进行header压缩：文字值使用霍夫曼代码编码，标头表由客户端和服务器以及客户端和服务器维护在后续请求中省略任何重复的标头。 Server Push ：单个请求可以有多个响应 请求优先级 安全 状态代码 1xx 信息性 2xx 成功 3xx Redirection 4xx 客户端错误 5xx 服务器错误 编译原理 数据对齐 1.数据或结构体、类中的数据成员的存储起始地址为有效对齐值N的倍数。 2.结构体或类或联合体最终的大小应为有效对齐值N的倍数（圆整）。 基本数据类型 char: 1；short：2；int：4；float：4；long：4；long long：8；double：8； 数据库 关系型数据库： 优点： 结构简单、易于维护：都是使用表结构，格式一致；数据库设计和规范化过程也简单易行和易于理解。 使用方便、灵活：使用标准查询语言SQL，允许用户几乎毫无差别地从一个产品到另一个产品存取信息。与关系数据库接口的应用软件具有相似的程序访问机制，提供大量标准的数据存取方法。 复杂操作：可以进行join等复杂查询； 保持数据的一致性； 由于以标准为前提，数据更新的开销小（相同的字段基本都是只有一处）； 存在很多实际成果和专业技术信息（成熟的技术）。 缺点： 数据类型表达能力差：关系数据模型不直接支持复杂的数据类型。 复杂读写功能差。 支持长事务能力差：由于RDBMS记录锁机制的颗粒度限制，对于支持多种记录类型的大段数据的登记和查询来说，简单的记录级的锁机制是不够 环境应变能力差：在要求系统频繁改变的环境下，关系系统的成本高且修改困难。 读写性能：面对海量数据的高并发读写需求，效率就会变得很差，硬盘I/O是一个很大的瓶颈； 扩展方式：固定的表结构，灵活度稍欠，如字段不固定时的应用； 存储过程： 优点： 1、重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。 2、减少网络流量：存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。 3、安全性：参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。 缺点： 1、更改比较繁琐：如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则仍需要更新程序集中的代码以添加参数、更新 GetValue() 调用。 2、可移植性差：由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。如果应用程序的可移植性在您的环境中非常重要，则需要将业务逻辑封装在不特定于 RDBMS 的中间层中。 设计数据密集型应用 要求 可靠性（Reliability） 系统在 困境（adversity，比如硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。 可伸缩性（Scalability） 有合理的办法应对系统的增长（数据量、流量、复杂性）。 可维护性（Maintainability） 许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。 设计模式 设计模式 游戏设计模式 图形学(大概) mipmap：多级渐远纹理 一系列的纹理图像，后一个纹理图像是前一个的二分之一。 当物体距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个纹理。 "},{"title":"C/C++方向","date":"2022-09-21T12:09:10.000Z","url":"/2022/09/21/CC++%E6%96%B9%E5%90%91/","tags":[["C/C++","/tags/C-C/"]],"categories":[["undefined",""]],"content":" C中如何调用C++函数 对于非成员函数，将 C++ 函数声明为 extern &quot;C&quot; 对于成员函数，需要简单包装 若要调用重载函数，则需要提供不同名字的包装 计网 网络编程 cache(缓存): cost/benefit cost: 需要缓存的数据会给系统带来的代价 内存管理 "},{"title":"知识点记录(Unity/C#)","date":"2022-08-19T14:13:21.000Z","url":"/2022/08/19/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/","tags":[["Unity","/tags/Unity/"],["C#","/tags/C/"]],"categories":[["undefined",""]],"content":" Shader 从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果 算法 给定一个数组，有n(n &gt;= 0)个元素，找到数组中第二大的元素 给定一个可包含重复数字的序列 nums ，按序列内字典升序返回所有不重复的全排列。 其中序列内字典升序指的是， 序列内从左到右的非降序排列，例如 nums=[1,2,3], 则因为[1,2,3] &lt; [1,3,2], [3,1,2] &lt; [3,2,1]， [1,2,3]要先于[1,3,2]输出，[3,1,2]要先于[3,2,1]输出 使用STL库用来计算排列组合关系的算法：next_permutation和prev_permutation。 即按字典序(lexicographical)来找到下一个或前一个的排列组合。例：{2，1，3}的下一个是{2，3，1}，前一个是{1，3，2}。字典序即两个组合从左往右依次比较，若某一位A比B小，则A的字典序在B之前。 oop的四个特征 抽象、封装、继承、多态 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。这也体现了大自然中一般与特殊的关系。继承性很好的解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。 封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。 多态性是指的是同一接口的不同实现方式，多态允许基类的指针指向子类方法。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 多态的作用： 不必编写每一子类的功能调用，可以直接把不同子类当父类看，屏蔽子类间的差异，提高代码的通用率/复用率 父类引用可以调用不同子类的功能，提高了代码的扩充性和可维护性 迭代器和数组的区别迭代器：迭代器（iterator）有时又称光标（cursor）是程序设计的软件设计模式，可在容器对象（container，例如链表或数组）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。 C# 迭代器模式 指按照一定顺序来访问一个集合对象中的每个元素, 但是同时不会暴露集合对象的内部结构. C#中内置的迭代器模式就是Foreach语句, 它可以顺序遍历容器中的每个元素. 而迭代器的具体实现主要是靠IEnumerable 和IEnumerator. IEnumerator IEnumerator接口其实就是foreach的具体实现, 它只定义了三个函数, 如下 也就是说我们实现一个最简单的IEnumerator接口只需要实现这三个函数即可. MoveNext()表示向集合中的下一个元素移动, 如果有下一个元素返回true, 没有就返回false. Current是一个只读属性, 返回当前迭代器所指元素. Reset()表示重置迭代器到第一个元素. 这就是一个简单的IEnumerator, 如果用Foreach输出, 可以得到从9到0的十个计数. 而具体的实现过程还需要IEnumerable. IEnumerable IEnumerable可以粗略的理解为可迭代(遍历)的, 如果接口继承了IEnumerable, 那么就可以使用Foreach语句进行迭代操作. 这个接口只定义了一个函数, 如下: 这个函数需要返回一个我们刚才定义的IEnumerator, 即告知上层调用方可以枚举. 这个时候我们的迭代器已经实现, 可以使用Foreach语句进行迭代操作. 我们现在有一个完整的迭代器了, 但是有一个问题, 很多时候我们需要的迭代器并不复杂, 如上面的计数装置, 如果每次都需要实现IEnumerator和IEnumerable十分不方便, 显得头重脚轻, 这时我们可以使用yield. yield yield是为了方便使用迭代器而产生的语法糖, 他可以直接使用在返回类型为IEnumerable或IEnumerator的函数中直接实现迭代器操作. 它有两种用法yield break 和yield return (something) 效果和break与return一样. 当使用yield return在foreach语句中进行迭代器操作时, 每一次执行到yield return时都会返回后面定义的something并且记录函数内的信息, 下一次运行时继续. 这里我们在i = 5的时候使用了yield break终止了迭代器操作, 如果去掉它, 这个函数就和我们刚才定义的迭代器作用一样, 产生了9到0, 共10个数的倒数. 协程(coroutine) 除了foreach语句, Unity中另一种迭代器模式就是协程, 它是根据每一次IEnumerator的MoveNext()方法调用进行迭代的, 有些类似于Unity的Update方法. 同时它可以结合Unity的yield return new WaitForSeconds(time)等等接口实行迭代器+定时器模式.使用和停止协程比较简单, 都只要传入IEnumerator就可以. 使用协程的方法实现我们的从9数到0. 值得注意的是unity里有很多可以和yield结合使用的语句块, 如上的代码不仅实现了从9数到0, 还实现了每隔1秒数一次, 数到0后继续从头开始数, 当然还有很多其他有趣的功能可以通过coroutine和yield实现. 泛型的作用。泛型和传统类型Boxing/UnBoxing的区别 泛型：即通过参数化类型来实现在同一份代码上操作多种数据类型。泛型编程是一种编程范式，它利用“参数化类型”将类型抽象化，从而实现更为灵活的复用。 作用：减少拆装箱，确保类型安全 区别： 装箱：值类型转引用类型。开辟一块内存空间进行存放数据。 拆箱：引用类型转值类型。 写一个泛型类 C 使其继承自 CBase 性能优化 当你接手一个新项目，当运行一段时间后，发现内存占用高且帧率低，如何解决 性能优化： C#语法C# 特性（Attribute）特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。 特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：预定义特性和自定义特性。 规定特性（Attribute）的语法如下： 预定义特性（Attribute） .Net 框架提供了三种预定义特性： AttributeUsage：描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。 规定该特性的语法如下：[AttributeUsage( validon, AllowMultiple=allowmultiple，Inherited=inherited)] 参数 validon规定特性可被放置的语言元素。它是枚举器AttributeTargets的值的组合。默认值是AttributeTargets.All。 参数allowmultiple(可选的)为该特性的AllowMultiple属性(property)提供一个布尔值。如果为true，则该特性是多用的。默认值是false(单用的) 参数inherited(可选的)为该特性的Inherited 属性(property)提供一个布尔值。如果为true，则该特性可被派生类继承。默认值是false(不被继承)。 Conditional：我们可以将一些函数隔离出来，使得它们只有在定义了某些环节变量或者设置了某个值之后才能发挥作用 Obsolete：它标记了不应被使用的程序实体。当一个新方法被用在一个类中，但若仍然想要保持类中的旧方法，可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。 参数 message，是一个字符串，描述项目为什么过时以及该替代使用什么。 参数 iserror，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。 特殊类 密封类：不能被继承 关键字：sealed 接口类：接口定义了所有类继承]接口时应遵循的语法合同 Interface 抽象类：不能被实例化，可以包含非抽象成员 abstract 深拷贝 利用反射实现：此方式比较耗费性能，而且遇到对象中有值为null就会报错 二进制序列化实现：性能相对较高，遇到对象为null不会报错，需要在拷贝对象上标记[serializable]特性 xml序列化实现：遇到对象为null不会报错 利用silverlight DataContractSerilalizer实现 利用protobuf序列化实现 反射的作用动态创建一个数据集，并获得其类型T，调用T的Create函数。 .NET的一个强大功能是它可以通过一种称为反射(reflection)的过程访问应用程序的元数据。简单地说，反射就是运行时查询类型信息的能力。可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。 反射（Reflection）有下列用途： 它允许在运行时查看特性（attribute）信息。 它允许审查集合中的各种类型，以及实例化这些类型。 它允许延迟绑定的方法和属性（property）。 它允许在运行时创建新类型，然后使用这些类型执行一些任务。 优点： 1、反射提高了程序的灵活性和扩展性。 2、降低耦合性，提高自适应能力。 3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。 2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。 Prefab如何获得Prefab的GameObject类型，PrefabInstance和ModelPrefabInstance的区别 委托和事件的区别 委托类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。 委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类 事件（Event） 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。 C# 中使用事件机制实现线程间的通信。 通过事件使用委托 事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 发布器（publisher） 类。其他接受该事件的类被称为 订阅器（subscriber） 类。事件使用 发布-订阅（publisher-subscriber） 模型。 发布器（publisher） 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。 订阅器（subscriber） 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序） 区别 委托 Delegate 是一个类，在任何可以声明类的地方都可以声明委托。 可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。 事件 在类的内部，它总是private 的。 在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。 使用事件不仅能获得比委托更好的封装性以外，还能限制含有事件的类型的能力。 事件应该由事件发布者触发，而不应该由事件的客户端（客户程序）来触发。 万向锁万向锁(Gimbal Lock)：一旦选择±90°作为pitch角，就会导致第一次旋转和第三次旋转等价，整个旋转表示系统被限制在只能绕竖直轴旋转，丢失了一个表示维度。 以unity为例：unity中欧拉角的旋转顺序为 y-x-z。即旋转y轴x轴和z轴都改变，旋转x轴z轴改变，旋转z轴其他轴不变。 当模型的x轴的旋转为±90度时，旋转y轴和z轴的效果是一样的，这就是万向锁。此时y轴（惯性坐标系）旋转面和z轴（模型坐标系）旋转面共面 因为计算机每次执行旋转都是从[0, 0, 0]开始进行，且y轴旋转的优先级最高，此时y轴的模型坐标系和惯性坐标系的重合，因此y轴的旋转从结果上看就是惯性坐标系的旋转。 Unity生命周期函数Awake -&gt; OnEnable -&gt; Start -&gt; FixedUpdate -&gt; OnTrigger/OnCollision -&gt; 输入事件 -&gt; Update -&gt; LateUpdate -&gt; 渲染(Scene -&gt; Gizmo -&gt; GUI) -&gt; OnDisable -&gt; OnDestroy AssetBundleAssetBundle是Unity中的一种资源包，这种资源包可以是游戏内要用到的几乎所有资源，并且可以在运行时动态加载。 卸载Load的asset资源，通过Resources.UnloadAsset(asset)来进行卸载； 压缩格式：LZMA, LZ4, 以及不压缩。 LZMA是一种默认的压缩形式，这种标准压缩格式是一个单一LZMA流序列化数据文件，并且在使用前需要解压缩整个包体。能使压缩后文件达到最小，但是解压相对缓慢。 LZ4能使得压缩量更大，而且在使用资源包前不需要解压整个包体。 不压缩的方式打包后包体会很大，导致很占用空间 AssetBundle的卸载和加载 加载 AssetBundle.LoadFromFile：从本地加载 AssetBundle.LoadFromMemory：从内存加载 AssetBundle.LoadFromMemoryAsync：从内存异步加载 从AB中加载资源 AssetBundle.LoadAsset(assetName) ：加载AB包中的指定对象，不包含依赖的包 AssetBundle.LoadAllAssets() ：加载AB包中所有的对象，不包含依赖的包 AssetBundle.LoadAssetAsync() ：异步加载，加载较大资源的时候 AssetBundle.LoadAllAssetsAsync() ：异步加载全部资源 AssetBundle.LoadAssetWithSubAssets() ：加载资源及其子资源 卸载 AssetBundle.Unload(true)：卸载所有资源，包含其中正被使用的资源 AssetBundle.Unload(false)：卸载所有没被使用的资源 Resources.UnloadUnusedAssets()：卸载未使用的资源 protobuf重写和重载的区别​ 1.定义不同—-重载是定义相同的方法名，参数不同；重写是子类重写父类的方法。 ​ 2.范围不同—-重载是在一个类中，重写是子类与父类之间的。 ​ 3.多态不同—-重载是编译时的多态性，重写是运行时的多态性。 ​ 4.返回不同—-重载对返回类型没有要求，而重写要求返回类型，有兼容的返回类型。 ​ 5.参数不同—-重载的参数个数、参数类型、参数顺序可以不同，而重写父子方法参数必须相同。 ​ 6.修饰不同—-重载对访问修饰没有特殊要求，重写访问修饰符的限制一定要大于被重写方法的访问修. 堆(Heap)和栈(Stack) 程序内存 栈：由操作系统自动分配释放，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。：堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。 区别： 管理方式不同。栈自动释放；堆手动释放，容易产生内存泄漏 空间大小不同。栈 &lt;&lt; 堆。 生长方向不同。堆的内存地址由低到高；栈的内存地址由高到低。 分配方式不同。堆都是动态分配的；栈有静态分配和动态分配。 数据结构 栈：线性表。先进后出(First In Last Out). 堆：树形结构，是一种特殊的完全二叉树。满足所有节点的值总是不大于或不小于父节点的值的完全二叉树。根节点最大称为大顶堆，根节点最小称为小顶堆。 值类型存储在栈中；引用类型存储在堆上。 GC​ 什么是GC：即Garbage Collection，垃圾回收。当使用可用内存不能满足内存请求时，GC会自动进行。 C#中的GC GC的四个步骤。 垃圾回收器搜索内存中的托管对象； 从托管代码中搜索被引用的对象并标记为有效； 释放没有被标记为有效的对象并收回内存； 整理内存将有效对象挪动到一起。 GC的作用： 提高软件系统的内聚。 降低编程复杂度，使程序员不必分散精力去处理析构。 不妨碍设计师进行系统抽象。 减少由于内存运用不当产生的Bug。 成功的将内存管理工作从程序的编写时，脱离至运行时，使不可预估的管理漏洞变为可预估的。 什么是垃圾 只要判定一个引用类型对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。 对象代龄 CLR初始化后的第一批被创建的对象被列为0代对象。 回收方法 Finalizer(析构函数)：一般不用，因为不确定GC调用时间，影响效率。 Dispose：继承IDisposable接口，实现Dispose方法；调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。’ Mark-Compact 标记压缩算法 Generational 分代算法 Unity中的CG Boehm GC(非分代非压缩) Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGen GC的设计思想）。 Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。 降低GC的方法： 使用对象池 减少string，使用StringBuilder 减少拆装箱 struct中不要有引用类型变量 主动调用GC 三色标记清除法 三色：黑色、灰色、白色 黑色: 表示对象以及被垃圾收集器访问过，且这个对象的引用都已经扫描过。黑色的对象代表以及扫描过，他是安全存活的，如果有其他对象引用指向了黑色对象，无需重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。 灰色: 表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描到 白色: 表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色，如在分析结束的阶段，仍然是白色的对象，即代表不可达。 步骤： 刚开始，所有对象都在白色集合中 将GC Roots直接引用的对象挪到灰色集合中 从灰色集合中获取对象： 将本对象的引用到的对象放入灰色集合中 将本对象放入黑色集合中 重复步骤3，直到灰色集合为空结束 结束后，仍在白色集合的对象即为GC Roots不可达，可以进行回收。 三代标记清除法 Lua pairs和ipairs 同：都能遍历集合，均按优先顺序输出没有key的值 异：对于又key的值 ipairs从第一个数字key开始，依次输出所有的key+1的键值，遇到字母下标不会结束遍历，但不输出，如果遇到nil则退出；pairs无序输出字母类型key或者数字类型key的键值，遇到nil不输出，也不会停止遍历。 __index和__newindex __index：(get)当在表中找不到元素时，lua会从 __index指向的表查找元素或获得方法的返回值。 __newindex：(set)对表中不存在的值进行赋值时调用。 当__newindex指向一个函数时，会执行该函数，且对本表的创建不成功； 当__newindex指向一个表时，会对指向的表进行操作，且对本表创建不成功。 __rawset和 __rawget 可以通过rawset和rawget操作绕过原表这一过程(__index和__newindex)，直接把这个表相应的结论输出。 a 网络同步​ 网络同步的目标时保证多台机器的游戏表现完全一致 帧同步 原理： 帧同步的战斗逻辑在客户端； 在帧同步下，服务端只转发操作，不做任何逻辑处理； 客户端按照一定的帧速率（逻辑帧）去上传当前的操作指令，服务端将操作指令广播给所有客户端； 当客户端收到指令后执行本地代码，如果输入的指令一致，计算的过程一致，那么计算的结果肯定是一致的，这样就能保证所有客户端的同步，这就是帧同步。 缺点： 由于帧同步战斗逻辑都在客户端，服务器没有验证，外挂成本低（加速、透视、自动瞄准、数据修改等）； 网络条件较差的客户端会影响其他玩家的游戏体验。（优化方案：乐观帧锁定、渲染与逻辑帧分离、客户端预执行、指令流水线化、操作回滚等）； 不同机器浮点数精度问题、容器排序不确定性、RPC时序、随机数值计算不统一。 乐观帧锁定： 状态同步 原理： 状态同步的战斗逻辑在服务端； 在状态同步下，客户端更像是一个服务端数据的表现层； 一般流程： 客户端上传操作到服务器； 服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态； 客户端收到状态后再根据状态显示内容。 缺点： 状态同步的回放实现较为复杂； 延迟过大、客户端性能浪费、服务端压力大； 对带宽的浪费。对于对象少的游戏，可以用快照保存整个游戏的状态发送，但一旦数量多起来，数量的占用就会直线上升。（优化：增量快照同步，协议同步指定数据） 区别 属性 状态同步 帧同步 流量 相对高 相对低 回放 记录文件大，且实现相对复杂 记录文件小，且相对容易实现 安全性 服务器实现逻辑，安全性高 逻辑在客户端，防作弊难度高 服务器压力 逻辑在服务端，压力大 小 战斗校验 服务端可以重跑一遍战斗 网络卡顿表现 瞬移，回位 卡顿 表现优化 表现优化用于弱化玩家对延迟的感受。 插值优化：客户端采用插值，避免位置突变 客户端预测+回滚 "},{"title":"热更新（XLua框架）","date":"2022-08-16T01:41:04.000Z","url":"/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/","tags":[["Unity","/tags/Unity/"],["Lua","/tags/Lua/"],["C#","/tags/C/"],["xlua","/tags/xlua/"]],"categories":[["undefined",""]],"content":" 资源目录划分 框架内容 Lua UI 实体（模型，特效） 场景 声音 网络 事件 对象池 框架开发流程第一阶段：Bundle处理 构建 查找BuildResources下的资源文件 使用Unity提供的BuildPipeline进行构建 meta文件不需要打入bundle包 Bundle Build策略 按文件夹打包 ：每一个最小文件夹打包 bundle数量少，小包模式：首次下载块 后期更新补丁大 按文件打包：每一个文件一个包 更新补丁很小 小包模式下：首次下载较慢 加载 加载对应的包，然后实例化 代码为从文件中异步加载 实际过程中不可能查看预制体来知晓依赖文件，因此需要用一个文件来对依赖文件信息进行存储。即版本文件，文件信息为：文件路径名|bundle名|依赖文件列表。 解析版本文件，加载依赖，加载自身，加载资源 开放接口，方便用户调用 更新 热更新方案 整包 策略：完整更新资源放在包内 优点：首次更新少 缺点：安装包下载时间长，首次安装久 分包 策略：包内放少量或不妨更新资源 优点：安装包小，下载快，安装块 缺点：首次更新时间久 热更资源流程 Application.streamingAssets：只读 Application.persisitentDataPath：可写 热更新代码流程 下载文件 写入文件 解析filelist 检测初次安装 只读目录有热更资源 可读写目录没有热更资源 判断filelist文件是否存在 最后写入filelist 检查更新 下载资源服务器上的filelist文件 对比文件信息和本地是否一致 文件路径 只读目录：Application.streamingAssetsPath/ + path 可读写目录：Application.persistentDataPath/ + path 资源服务器地址： + path 第二阶段：C#调用Lua Lua加载与管理 Lua文件加载 执行字符串：直接使用DoString执行一个字符串 luaenv.DoString(“print(‘hello world’)”) 加载Lua文件：使用lua的require函数，lua文件需要在Resource路径下，或者需要绝对路径 DoString(“require ‘byfile’”); 自定义Loader 涉及一个接口 public delegate byte[] CustomLoader(ref string filepath); public void LuaEnv.AddLoader(CustomLoader loader); filepath为文件路径，返回值是lua文件的内容 Lua文件管理 异步加载 同步使用 预加载 C#访问LUA luaenv.Global.Get&lt;int&gt;(&quot;a&quot;) luaenv.Global.Get&lt;string&gt;(&quot;b&quot;) luaenv.Global.Get&lt;bool&gt;(&quot;c&quot;) Lua绑定与执行 绑定：XLua插件的案例2为例 绑定脚本和方法后，可以在C#中进行lua方法的调用 结束运行前需要取消绑定 执行 Lua中调用C#代码 所有的类和命名空间都在CS命名空间下，方法通过 ‘ : ‘ 调用 第三阶段：向Lua提供接口第四阶段：完善和优化UI管理 界面类型 一极界面 二级弹窗 三级弹窗 特殊界面 UGUI层级特点 根据节点顺序渲染 为了解决UI的层级显示问题，根据Unity中的ui渲染顺序，可以设置多个父节点来对所有的UI进行一个分类的管理。每一个层级对应一个父节点。 UI的层级设置应该放在lua热更中，方便之后对ui层级的添加和修改 UIManger中提供设置层级的方法供lua调用 实体管理 管理方法与UI一致 场景管理 场景加载 通过协程调用SceneManager的的异步场景加载方法LoadSceneAsync(name, mode); 场景不能直接添加脚本，所以在场景中添加一个物体，用于添加场景的管理脚本，并调用其相关方法。 为了方便，提供一个方法用于获取场景中的管理对象上的管理脚本，即查找场景中的所有物体，然后获得名字为管理对象的脚本 场景叠加 即LoadSceneMode.Additive模式加载场景，即打开一个新的场景至当前场景 场景切换 即LoadSceneMode.Additive模式加载场景，即关闭当前所有场景，打开新的场景 场景激活 即SetActiveScene(name) 场景的setActive和InActive会有相关方法调用，因此需要添加场景激活的函数回调 场景卸载 和加载类似，通过协程调用异步卸载场景的方法。、 声音管理 背景音乐 播放 除播放外，其余只需要调用相关方法即可 暂停 恢复 停止 音量 音效 音量 播放 事件管理时间管理可以对所有的事件进行一个统一的管理 订阅 取消订阅 执行调用 对象池设计对象类型 AssetBundle GameObject 特点 使用自定义类，该类有上次使用时间，使用的对象和销毁的时间间隔 PoolObject 对象池中存放多种类型 用一个List\\对所有对象进行存储 短时间内重复使用 在销毁的间隔时间内能以一直使用 过期自动销毁 当过了销毁时间间隔还未被使用，则将对象进行销毁 设计原理：池内不创建对象，对象在外部创建，使用完放入对象池， 使用时再取出。即不预先创建对象，当需要时向对象池中取，池中没有则创建 由于存在两种对象，且加载和释放的方式有不同，所以定义一个基类PoolBase和两个类继承基类 生成 回收 对于AssetBundle，在游戏中可能存在多个物体对其的引用，只有当没有物体的引用时，才能将其放回对象池中。因此，可以定义一个数据结构对bundle的引用进行计数。 网络模块通信协议：用于服务端和客户端通信的数据格式 protobuf、sproto、pbc、json等 xlua使用通信协议需要添加第三方库，此项目中直接使用的是github上的编译好的库 客户端C# NetClient：客户端的网络消息处理类 NetManager：提供消息处理的中转接口，调用lua 客户端Lua 基于Class存在一个baseMessage类，存在消息注册的方法。在该模块中会存在对消息请求和接收的处理。 功能模块化 消息注册 消息发送 消息接收 模块管理器 模块管理器即消息管理，在此类中保存所有的模块列表和所有的回调列表。所有的模块的名字需要手动添加 模块化初始化 模块获取 消息接收 消息发送 简单服务器 热更新框架为什么需要更新 修复产品问题 游戏内容扩充/删减 热更新是什么 普通更新流程 需要商店审核，周期长，更新需要重新安装。 热更新流程 不需要商店审核，提交便捷，在游戏内自动完成资源下载和更新 为什么选择LUA Unity3D 资源热更 C# 编译型语言 脚本打包成动态链接库DLL Lua 解释型语言 脚本运行时翻译成机器语言，不需要编译。脚本和资源都可以动态替换 Lua热更的几个点 需要导入热更插件（XLua、ToLua、SLua等） 稳定易用，不用重复造轮子 综合考量，划分项目功能结构。 需要频繁更新的部分就采用热性新，即使用Lua脚本实现 编写框架或使用成熟的热更行框架，便于之后开发流程的进行 Xlua框架与项目框架引入xLua插件， 制定整体架构，选择对应的技术方案 lua框架—主程所考虑的 游戏类型：强联网、若联网 功能划分与Scene场景规划：背包，战斗等 特殊需求 制定模块系统：版本更新检测系统、登录等。C#仅调用lua的主要接口，lua脚本中的功能或操作均在lua中处理 中后期项目的热更重构建议 核心数据Lua存储 配置文件挪到Lua 网络交互使用Lua封装和调用 业务功能模块不在绑定C# 每个UI功能使用Lua处理 战斗等复合功能模块，增加辅助Lua处理 原框架核心功能部分改成Lua实现，部分打上LUACALLCSHARP标签 实现Lua模块间的通信。 XLua框架 框架基本功能资源目录结构划分以资源类型划分一级目录 Custom：用户自定义功能 Font：字体 Module：所有功能模块，每个功能对应Lua脚本 Prefab：预制体 Sound：音效等 Sprite：图片 Texture：纹理 功能模块的引用与操作 功能预制体资源 按照功能将模块封装为预制体 存放于Module目录对应的目录下 Tag设置为uiComponent 功能脚本资源 功能名.lua （逻辑脚本） Create() 加载并创建功能模块预制体 Awake() 完成View脚本的初始化和逻辑脚本初始化 BottonClickHander() 按钮对应方法的调用 功能名View.lua （试图脚本） Create() 指向模块路径和模块名 SetUICompenent() 绑定模块下的物体 按钮 图片 预制体 StartInit() 按钮功能监听 配置文件的使用图片与预制体资源的动态获取单机Demo热更新制作规划 ARPG游戏DEMO的需求分析 正式确定DEMO的功能模块 功能模块与技术支持 功能模块 技术支撑 准备开发 战斗系统分析 需求分析 形式：回合制、即时战斗 如何开始：攻击怪物、靠近怪物 如何结束：打败敌人、退出地图 配置表与数据结构 需要较为完整的配置表才能更好的进行代码逻辑的编写 模块支撑 分析 场景管理：进入战场，场景切换 怪物管理：怪物刷新、怪物相关任务 战斗计算：战斗过程处理 战斗结算：进行结算 战斗动画：管理动画 特效管理：管理特效 普攻实现 攻击距离 攻击判定 攻击力动态计算 数值与公式 技能实现 回复术：回复生命值/魔法值等（对Player属性的修改） buff：存在时间，可以对多种属性进行增益或减益 火球术：伤害类技能，直接碰撞检测等 网游功能模块分析 模块分析 框架技术 网络请求 网络模块分析 Net模块工作原理 Net模块功能分析 Net模块使用操作 短链接 缺点：连接操作频繁 优点：服务器管理成本低，对服务器压力小 C#端与Http请求回调 IP地址问题 接收Lua回调方法 使用Post请求 响应后将回调方法加入C#CallLua列表 一次业务请求逻辑流程 方式一 方式二：主数据的 更新交给框架处理，不需要再业务逻辑开发的过程中处理 背包模块分析​ 需求分析 滑动列表多物体处理：只显示框内的物体，对在列表外的物体进行隐藏 数据流 数据结构 配置文件 总结 框架概念框架目标 可靠性 bug为什么多 公共功能架构解决 安全性 核心是数据安全 加密 身份验证 只相信服务器的运算 可扩展和和维护 功能和功能之间需要进行合理的划分，之间不能直接进行调用，要方便后续的功能开发 功能不断增加 功能需要维护 功能划分 松耦合 可定制和可伸缩 可根据需求进行调整：不同项目侧重不同——框架扩充 可根据新技术对现有框架进行扩展 不同项目自定义模块方法 lua插件本体也可以更换 客户体验 方便开发 开发模板 开发工具 ：配置文件等 为什么需要热更框架 被动因素 XLua：和Tween/easyTouch等插件不一样，使用的是lua语言进行项目开发，从根本上改变了原有框架 热更框架目标 引擎部分 内部采用打包时间作为版本号 C#部分 Lua部分：使代码功能模式化 框架结构框架项目目录结构 Ant：自定义组件C#脚本 AssetBundlesLocal：热更新资源目录 Editor：编辑器开发目录 EditorPrefab：自定义组件预制体 Lua：lua脚本存放目录 Plugins：插件目录 Resources：内部资源目录 Xlua：xlua插件目录 重点功能模块 功能模块调用关系 重点功能模块 UIGameLoading AppBoot LuaTools LuaBehaviour ResourceManager SystemTool 重点脚本 ui.lua main.lua 网络模块 list.lua GameMainData event.lua 事件系统，可以订阅和调用 plugin.lua 插件资源管理，方便管理 public.lua 公共资源管理，存放公共方法 tools.lua 框架功能设计 业务功能管理 ui.lua UIGameLoading 网络请求管理 net.lua 资源打包策略 资源打包前提 资源打包流程 资源打包策略 相关类和函数 AssetImporter： 属性 assetBundleName / assetBundleVariant：获取或设置AssetBundle Name / Property； 静态方法 GetAtPath()：通过静态方法GetAtPath获取指定路径（相对路径）下的资源的导入器 资源管理策略 ab包加载 编辑器开发 使用unity资源数据库类管理 AssetDatabase.LoadAssetAtPath&lt;AudioClip&gt;(&quot;Assets/AssetBundlesLocal/&quot; + path + &quot;/&quot; + name + &quot;.wav&quot;) 真机环境(PC、安卓) 判断内存中是否加载需要的资源 若不存在相应资源，则判断是否存在对应的ab包 若存在，则从ab包中读取对应的资源 若不存在，则先load这个ab包，放入对应容器，然后加载资源 优点 可以避免重复加载同一个ab包 每一个资源都不会重复加载 通过ab包名和资源名就可以获取相应的资源。ab包名对应路径 ab包加载路径 真机 在从资源服务器判断热更后，下载ab包，将其存放在客户端的PersistentData目录下 编辑器 要将ab包复制到PersistentData目录下 预加载资源 有一些资源需要在运行前加载到内存中 有些资源需要在某功能开始前加载 依赖关系 一个预制体，使用了text，text使用了字体 字体和预制体都被打包未ab包 则这个预制体ab依赖于字体的ab 要使用这个预制体，则需要预加载字体ab 按照功能划分ab包，一个功能的所有依赖都打包到同一个ab包中 公共部分打包为公共ab包，所有使用它的模块共同依赖这个ab包 预加载常驻内存资源 提供加载方法，一般用于字体，shader等资源 预加载模块资源 资源维护与清理 维护 allAssetBundle[path] ：存储所有ab包的容器（字典），每一个ab在内存中的引用。ab包被清理后，对应的值也会被清理 ab.Unload(true)：清理ab包，并清理ab包中每一个资源的引用 ab.Unload(false)：仅清理ab包，不清理资源的引用。可能会导致内存泄露 清理 C#端，判断内存中是否存在ab包，存在则Unload lua端根据需要的时候调用 资源清理策略 如何清理 调用清理方法 调用时机 功能模块关闭后直接调用清理 对于ab包容量不大，资源数适中，在load时不卡顿 根据实际情况决定时机 对于ab包容量大，资源数较多，load时有卡顿 策略一：从源头 在ab包划分时：功能划分，资源划分，公共资源部分确定（常驻） 资源本生容量控制：在显示效果牺牲不大的情况下降低资源配置 二：补救，通过配置文件决定如何清理 延迟清理：在模块关闭一定时间后再清理 根据需要 时间段：某个时间段内不清理 等级：某些等级对某些模块的使用更频繁 其他：vip、等 开发工具设计 编译器工具 通过自定义扩展编辑器功能 常规工具 独立运行的exe程序 准换工具 json转换为lua excel转换为json "},{"title":"Lua学习","date":"2022-08-12T02:30:23.000Z","url":"/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/","tags":[["Lua","/tags/Lua/"]],"categories":[["undefined",""]],"content":" Lua5.3参考手册 语法： 变量 动态类型 弱类型 大小写敏感 默认全局 带GC 类型：nil、boolean、number、string、function、userdata(用户自定义类型)、tread、table 语句 数据结构 Table function 函数 运算符 函数库：例 协程 OO 面向对象 类的继承的简单实现 简单封装的实现 闭包 "},{"title":"数据结构与算法","date":"2022-05-12T02:30:23.000Z","url":"/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","tags":[["C++","/tags/C/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":" 算法复杂度时间复杂度：指执行算法所需要的工作量。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，即考察输入值大小趋近无穷时的情况。 空间复杂度：指执行算法需要的内存空间 数据结构栈（Stack）：后进先出的数据结构。只能在栈顶进行添加（入栈）和删除（出栈）的操作。 应用：①撤销操作，②数组反转，③递归 队列（Queue）： 先进先出的数据结构，只能在队尾添加（入队）元素，队首删除（出队）元素。（双向队列无尾首区别） 循环队列 性能最好 应用：排队 queue 集合（Set）：包含不重复元素的集合称为set，例如HashSet等，能快速的进行去重操作。 应用：词汇量统计 映射（Reflection）：特殊集合，例如Dictionary，存储的是键值对 应用：词汇量统计 有序数组： Rank使用二分查找找到target的对应位置，方便add 和 remove 的操作，保证数组始终有序 树：​ 二叉树（Binary Tree）：普通二叉树 ​ 满二叉树（Full Binary Tree）：除了叶子节点外都有两个节点 ​ 完全二叉树（Complete Binary Tree）：每层的节点均达到最大值，及每层的节点数为2的n-1次方个 ​ 二叉搜索树（Binary Search Tree）：每个节点左边所有节点的值均小于右边节点的值 ​ 平衡二叉树（AVL Tree）：任何节点的两颗字数的高度差小于等于1 ​ B树（B-Tree）：B树与平衡二叉树一样，但是是多叉树 ​ 红黑树（Red-Black Tree）：自平衡二叉寻找数 ​ string substr(int pos, int len); 获得字串，pos为起始位置，len为长度 算法排序：升序为例 冒泡：双重循环，依次比较大小，前一个比后一个大，则交换位置，时间复杂度O(n^2) 选择：双重循环，但内循环只选出第 i 个即其之后位置的最小值，然后和第 i 个位置交换，时间复杂度O(n^2) 快排：以第一个数为界 记flag，从前往后找出第一个比flag大的值，从后往前，找出第一个比flag小的数，然后交换两个数的位置。直到找到flag的位置，然后递归查找flag的左侧和右侧的中间值 时间复杂度O(n log2 n) 不能对存在重复元素的数组进行排序 若快排前数组有序，则时间复杂度为O(n^2) 排序前可以将第一个元素与中间或随机元素进行交换，可优化时间复杂度 三路快排：有重复元素的快速排序 ，即相比上一个方法，多了等于flag的情况 即将数组中的元素分为三个区域，大于[gt, right] 小于[l+1, lt]和等于选定值flag的情况 i 指向当前元素 若 i 指向元素等于flag，则i++； 若 i 指向元素小于flag，则将 it + 1 指向的值与 i 交换，然后 it++、i++。即将小于flag的区域增1，且等于flag的区域右移1. 若 i 指向的元素大于flag， 则将 gt - 1 指向的元素与 i 交换，然后 gt—。即将大于flag的区域向后增1，其余区域不变 当 i 指向 gt 时，表示遍历完成，此时只需将 flag 除的值与 lt 处的值进行交换，则三个区间形成，然后继续遍历大于flag和小于flag的区域 归并：采用分治法，先使子序列有序，然后将两个有序子序列合并，得到有序序列。即先将输入序列分成n/2个子序列，对这两个子序列分别采用归并排序，将两个排序好的子序列合并成排序序列，时间复杂度O(nlogn) 堆： 桶： 查找： 顺序查找O(n)：遍历所有数据，进行处理 二分查找O(log n)：对有序数组进行分半查找，每次为对比中间数据，然后根据大小关系，对前半部分或后半部分进行对比。 递归(recursion)： 程序调用自身的编程技巧称为递归，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解.。递归需要有边界条件、递归前进段和递归返回段。 尾递归：首先执行计算，然后执行递归调用 在尾部调用的是函数自身 （Self-called）； 可通过优化，使得计算仅占用常量栈空间 (Stack Space)。 并查集 定义：在一些有N个元素的集合应用问题中，通常在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 主要用于解决一些元素分组的问题，用于管理一系列不相交的集合并存在两种操作： 查找(Find):查询两个元素是否在同一个集合中； 合并(Union):把两个不相交的集合合并成一个集合。 最简单版本的并查集代码： 直接合并可能会导致每次查询的路径过长，而增加时间消耗，因此，存在两个方面对算法进行优化 路径压缩：在查询过程中把沿途的每个节点的父节点全部设置为根节点 按秩合并：用rank[]数组记录每个根节点对应的深度。初始化为1。合并时把rank较小的合并在较大的根节点上 路径压缩和按秩合并如果一起使用，时间复杂度接近 ，但是很可能会破坏rank的准确性。 背包问题背包问题大体的解题模板是两层循环，分别遍历物品nums和背包容量target，然后写转移方程，根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法。 01背包：外循环nums,内循环target,target倒序且target&gt;=nums[i]; 例：416. 分割等和子集 完全背包 组合问题：外循环nums,内循环target,target正序且target&gt;=nums[i] 排列问题：外循环target,内循环nums,target正序且target&gt;=nums[i] 分组背包：需要多重循环：外循环nums,内部循环根据题目的要求构建多重背包循环 A*算法概述 A*算法是一个搜索算法，是对于广搜(BFS)的优化。 A算法类似于Dijkstra算法。不同点在于A\\算法的查找优先向最可能到达终点的方向进行查找。即相较于BFS，少搜索了一些不太可能达到终点的点。 因为H是对未来路径的预测，所以A*算法找到的路径不一定是最短的，但牺牲准确度带来的是效率的提升 关键 启发函数：计算组成路径的方格的关键是以下等式 F = G + H G：从起点移动到当前点的代价。 H：从当前点移动到终点的预估代价。 F：当前选择路径的可能总代价，作为下一个将遍历点的依据 对于网格形式的图，H有几种方式： 中能上下左右移动的，使用曼哈顿距离(|x1 - x2| + |y1 - y2|) 允许八个方向的，则使用对角距离 允许任意方向的，使用欧几里得距离(两点间的先线段长度) Github，Unity案例 为了方便观察使用和Debug，进行了一些可视化处理 算法思路 每帧执行 Point类为地图中的一个点 将将要被遍历的点放入openList中，每次执行FindPath都会对openList中F值最小的点进行遍历，然后将其加入closeList中。 当openList中存在终点时，代表已经遍历至终点，从终点依次遍历其Parent点便可以得到最终路径 执行 STL(C++) 增删查：insert()、erase()、find() vector 初始化 增 删 set find(T val); 返回指向对应元素的迭代器，若无对应元素，则返回指向end()。 erase(iterator); 删除迭代器指向的元素； insert(T val); 插入元素 若T为结构体，则需重载 &lt; 运算符 map 优先队列(priority_queue) 特殊队列。每次从队列中取出的是具有最高优先权的元素。\\ 自定义优先级： 重载运算符 其他智能指针(shared_ptr) ss 字典序 C++ static的用法 静态局部变量 静态全局变量 静态函数 "},{"title":"剑指offer","date":"2021-09-16T08:45:47.000Z","url":"/2021/09/16/%E5%89%91%E6%8C%87offer/","tags":[["c++","/tags/c/"]],"categories":[["c++","/categories/c/"]],"content":" 链表 链表反转： 开始先设定三个指针，并进行初始化，如图 并将Pre的指向的Next指向NULL 开始循环，head指针后移，让Cur指针的Next指向Pre，然后使Pre = Cur，Cur = Head。直到链表尾 二分法模板： 广度优先遍历（BFS） 深度优先遍历（DFS） 例题：剑指 Offer 12. 矩阵中的路径 用dfs深度遍历加回溯法。 字符串 清除字符串前后的空格符号 二叉树​ 前序遍历：优先遍历根节点，然后是左子节点，再是右子节点 ​ A-B-D-F-G-H-I-E-C 中序遍历：优先遍历左子节点，然后是根节点，再是右子节点 ​ F-D-H-G-I-B-E-A-C 后序遍历：优先遍历左子节点，然后是右子节点，再是根节点 ​ F-H-I-G-D-E-B-C-A 二叉树转化成双向链表：用中序遍历 数据结构 优先队列：priority_queue 包含在头文件 ‘queue’ 中,我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队. 优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的 二叉搜索树：Binary Search Tree 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 中序遍历得到的结果使有序的 算法 分组位运算：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 相同数字异或为零 "},{"title":"几种AI解决方法","date":"2021-07-29T11:36:24.000Z","url":"/2021/07/29/%E5%87%A0%E7%A7%8DAI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","tags":[["unity","/tags/unity/"],["C#","/tags/C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 人工智能遵循着：感知-&gt;思考-&gt;行动决策方法：有限状态机（Finite-State Machines），分层状态机（Hierarchical Finite-State Machines），行为树（Behavior Trees），效用系统（Utility Systems），目标导向型行动计划（Goal-Oriented Action Planners），分层任务网络（Hierarchical Task Networks） 有限状态机FSM是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的机器。是一种设计模式 假设存在3个状态：巡逻（patrol），查看（investigate），攻击（attack）。正常状态为巡逻，当听到动静时会变为查看状态，若发现敌人则变为攻击状态，或者一段时间后回到巡逻状态。打死敌人之后或脱离范围，则回到巡逻状态 每个状态用一个类表示 "},{"title":"3D RPG 学习笔记","date":"2021-07-23T07:38:31.000Z","url":"/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["unity","/tags/unity/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 一、创建项目导入素材 创建普通项目 在Package Manager中安装Universal RP 在Asset中创建Rendering =&gt; Universal Render Pipeline =&gt; Pipeline Asset(URP的设置文件) 将project setting中Graphics和Quality的渲染管线设置为刚创建的渲染管线设置文件 导入素材（Dog Knight PBR Polyart、 Low-Poly Simple Nature Pack 和 FREE Skybox Extended Shader） 在Edit =&gt; Edit=Render Pipeline =&gt; Universal Render Pipeline 中设置当前项目或当前素材的渲染管线 在Lighting =&gt; Environment 中设置天空盒的材质 注意Asset窗口和Inspect窗口的物体分类，方便管理 安装package PolyBrush 调整地面的高度(左键直接点击变高，control+左键点击变矮) Outer Radius：外圈大小 Inner Radius：内圈大小 Strength：变化强度 Direction：设置变化的方向。Brush normal：材质的法线方向 Brush Mirroring：沿坐标轴对称形成另一个笔刷同时进行相同操作 柔化：将比较突出的棱角变的平滑。设置基本同上 将当前物体刷上不同的颜色 如果需要将颜色刷到物体上，则物体材质的 shader 需要为 Polybrush=&gt; Shader 下的shader Brush：根据笔刷的大小刷上颜色 Fill：填充区块 Flood：整个物体 将预制体刷到场景当中 基本设置同1 将需要的prefab添加到Current Palette中，当前选中的prefab会在Brush Loadout中 Brush Loadout 中prefab下的拖动条表示此物体出现的概率 Hit Surface is Parent：将所有的画在平面上的物体都是此平面的子物体 将texture刷到场景当中 同4 Pro Builder 按住shift可以查看图标的功能 Pro Grids 安装ProGrids需要在Project Setting的Package Manger中打开允许preview 设置物体移动时的单位距离 是否在Scene窗口中显示坐标轴 是否自动吸附：即按照1的设置在坐标轴上自动进行吸附，每次只移动1的距离 4 5 X 、Y、 Z、 3D均为Scene窗口显示的坐标轴 Navigation自动导航 点击移动 自定义事件的注册和调用 注册 调用 屏幕射线转为世界射线 单例模式 方便事件函数等在外部的调用 事件注册和调用 功能实现 鼠标指针图片切换 Cinemachine：多功能相机插件 Post Processing：后处理 Animator Shader Graph 遮挡剔除 FSM 状态机 "},{"title":"每日一题","date":"2021-07-19T07:49:14.000Z","url":"/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","tags":[["C#","/tags/C/"],["Leetcode","/tags/Leetcode/"]],"categories":[["每日一题","/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"]],"content":" 面试题 10.02. 变位词组编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串 示例： 说明： 所有输入均为小写字母。 不考虑答案输出的顺序 题解： 思路：计数法。 计算每个字符串中所有字符出现的个数，将相同的放在同一个list中，完成分类 代码： 1877. 数组中最大数对和的最小值题解： 分析： 最大与最小相加产生的数对和最小，即第k大的数和第k小的数相加，所得的最大数对和最小. 所以先将数组进行排序，然后依次下相加比较，即得出结果 代码： 1893. 检查是否区域内所有整数都被覆盖题解： 分析： 暴力解法，用一个 right-left+1 大小的数组来记录，直接通过二重循环，依次判断ranges中的每个[start,end]中是否包含[left,right]中的任意数字，如果包含，则对应的数组的值加一，循环完毕后再次循环判断数组中是否有0，有则为false，没有返回true。 代码： 1743. 从相邻元素对还原数组题解： 分析： 将数组中的数对用字典储存，则数组头或尾中字典的list的长度只有1，然后在通过字典，一次查找下一个 代码： 704. 二分查找 2021/9/7题解： 分析： 经典二分题，将数组分成两个部分，通过判断中间数字和目标数字的大小比较，然后进入目标数字存在的部分再次进行二分查找 在进行中间下标的计算时，若直接用 (left + right)/2 会导致一些特殊情况出现问题，所以使用 (right - left)/2 + left， 或直接使用位移运算 left + right &gt;&gt; 1。 代码： 470. 用 Rand7() 实现 Rand10() 2021/9/6题解： 分析： Rand7() 有 1~7 共7种数字，49种情况，所以从1-10依次分布如下 ​ 代码： 1221. 分割平衡字符串 2021/9/7题解： 分析： 循环计算字符串中的L和R的字符个数，当两个个数相等时就表示出现一个平衡字符串，则计数器加一。 代码： 678. 有效的括号字符串 2021/9/12题解： 分析： 堆栈法： 对字符串s逐个字符进行判断，有如下三种情况 如果字符是左括号，则将其下标压入左括号栈 如果字符是星号，则将其下表压入星号栈 如果字符是右括号，则 如果左括号栈中元素不为空，则将左括号栈中顶部元素出栈 如果左括号栈中元素为空，星号栈中元素不为空，则将星号栈中顶部元素出栈 如果两个栈中元素都为空，则此右括号无匹配元素，返回false 字符串遍历完后，如果两个栈中元素都不为空，则依次将两个栈中的栈顶元素出栈，然后比较两个元素的大小，如果左括号栈的出栈下标比星号栈的出栈下标大，则表示左括号在星号的后面，无法匹配，返回false 最后判断左括号栈中的所有元素是否全部出栈，即所有左括号均有匹配，则返回true（星号可以为空字符，所以星号栈不需要做判断） 动态规划： 贪心： 代码： 447. 回旋镖的数量 2021/9/12题解： 分析： 直接三重循环依次判断三个点是否组成等边三角形，然后返回值。（严重超时） 一个回旋镖可以看作三个点组成的一个等边三角形，所以要判断是否可以放置回旋镖即判断是否可以组成等边三角形，即找到两个点到同一个点的距离相同。每多一个点到顶点的距离相同，就会多两个可摆放的回旋镖（存在位置差异，n&gt;=2），即为n的排列组合。 An = n * (n - 1) 所以我们可以采用枚举的方法，依次判断所有点到其他点的距离，并用字典储存,再在最后进行判断。 代码： 524. 通过删除字母匹配到字典里最长单词 2021/9/14题解： 分析： 题目描述不清楚，应为在第二个参数dictionary中找到最长的s的，且相同长度下字典序靠前的子字符串。 所以先将字典中的字符串按长度和字典序进行排序，然后依次判断是否为s的子串。 排序时需要先将 IList 转化为 List var list = new List(dictionary); 然后使用List的Sort方法 代码： 162. 寻找峰值 2021/9/15题解： 分析： 该题需要时间复杂度为O(log n)，所以直接循环查找行不通。 因此需要使用二分法进行查找。 在二分查找时有四种情况 nums[mid - 1] &lt; nums[mid] &lt; nums[mid + 1]，此时右边一定存在一个峰值 nums[mid - 1] &gt; nums[mid] &gt; nums[mid + 1]，此时左边一定存在一个峰值 nums[mid - 1] &gt; nums[mid] &lt; nums[mid + 1]，此时左边和右边都存在峰值 nums[mid - 1] &lt; nums[mid] &gt; nums[mid + 1]，此时mid 本生就为一个峰值 对上述四种情况进行优化，可以分为两种情况，峰值在左边（右边）和峰值在右边（左边）和中间 代码： "},{"title":"VRTK学习记录","date":"2021-06-06T11:27:43.000Z","url":"/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":[["错误总结","/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"],["经验","/tags/%E7%BB%8F%E9%AA%8C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 配置环境unity 2018.4.14VRTK 3.3.0steamVR 1.2.3 键鼠模拟基本操作 wasd控制人物移动 鼠标默认控制人物方向 alt切换控制模式 鼠标：控制人物方向 —&gt;控制左右Controller的水平位置 ctrl：按住ctrl控制Controller的垂直位置 tab切换左右Controller ctrl 切换为抓取物体模式 鼠标右键为右Controller抓取 鼠标左键为左Controller抓取 shift 奔跑 q 发出射线 鼠标右键代表Controller的扳机 基本配置 新建场景，删除原本的Camera。 simulator为键鼠模拟；steamVr为设备操作；[VRSimulator_CameraRig]是VRTK的prefab，可直接使用； RightController 为右控制器； LeftController 为左控制器； PlayArea 为需要传送时添加。 VRTK SDK 需要添加VRTK_SDKManager 组件，并将子物体simulator和steamVR添加到组件中Setups的列表中（因为只需要键鼠模拟，所以只添加了simulator），然后将左右手控制器分别添加到Scripts Aliases中。 Simulator和SteamVR需要添加VRTK_SDK Setup 组件，并将Quick Select设置为相应的模式 Controller相关控制器基本组件​ ​ ​ ​ 射线类型可以为直线(VRTK_Straight Pointer Renderer)或贝塞尔曲线(VRTK_Bezier Pointer Renderer) ​ Heighlighter …. ； VRTK_UI Pointer为ui互动所必须组件 射线与场景互动控制器上可以添加自定义脚本，使之可以与场景中的物体进行互动,脚本参考VRTK_ControllerPointerEvents_ListenerExample ​ "},{"title":"JavaScript","date":"2021-04-25T08:12:15.000Z","url":"/2021/04/25/Web/","categories":[["Web","/categories/Web/"]],"content":" 概念外部JavaScript脚本的调用：&lt;script src = &quot;../../路径&quot;&gt;&lt;/scripts&gt; NaN：not a Number 逻辑运算（&amp;&amp;）：谁在表达式中起关键性作用，结果就是谁例：true &amp;&amp; 4 &amp;&amp; “aaa”x输出 “aaa” 0 &nbsp;&nbsp; “0” &nbsp;&nbsp; “” &nbsp;&nbsp; null &nbsp;&nbsp; NaN &nbsp;&nbsp; undefined =&gt; false 用 new 创建的对象为引用类型（object） 预定义函数parseInt():将字符转化为Int eval(string):string为一个可计算的字符串或者是可执行的表达式 对象prototype可以为一个类创建一个共有的模板新new的对象会调用模板中的属性 数组cars = [“0”, 2, new Object()];//数组中的元素可以不同 joinjoin() : 将数组中的元素拼接成字符串，默认连接符为“,” splicesplice(index, howmany, [item1, … , itemx], item, …) : howmany为从index的位置开始删除元素的个数，后面的为插入的元素 sortsort(function(a,b){return b - a}); 数字的降序排列sort(function(a,b){return a - b}); 数字的升序排列 Dateunix时间戳，从1970.1.1到xxxx.xx.xx的毫秒数 Mathround() 四舍五入random() 返回0~1的随机数"},{"title":"TANKS! Unity Tutorial 项目学习记录","date":"2021-04-13T15:25:35.000Z","url":"/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":[["Unity","/tags/Unity/"],["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[["Unity","/categories/Unity/"]],"content":" APISmoothDamp平滑的改变当前值至另一个值 *current*：当前位置 *target*：尝试达到的目标值 *currentVelocity*：当前速度，该值在每次调用时都会由函数修改。 *smoothTime*：达到目标值的时间 *maxSpeed*：最大速度 *deltaTime*：默认为Time.deltatime *ref关键字*：相当于c的指针传参，及引用传参。 InverseTransformPoint 将position这个Vector3类型变量转化为 以V3的世界坐标为零点基准的情况下 position相对于V3的坐标值。 PhysicsPhysics.OverlapSphere检测范围内的Collider public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); *position*：圆心 *radius*：检测半径 *layerMask*：检测层级 *queryTriggerInteraction*：判断是否应该检测Trigger RigidbodytargetRigidbody.AddExplosionForce爆炸力将随着到物体的距离变小。 public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)); *explosionForce*：爆炸的力量（会根据距离变化） *explosionPosition*：爆炸中心 *explosionRadius*：爆炸半径 *upwardsModifier*：可以调整爆炸的位置，让物体有被炸起来向上的效果，但爆炸本身的位置不变 *ForceMode*：对物体施加力的方法 Manual相机的两种投影方式 透视投影(Perspective)(左): 正交投影的观察体是长方体，它使用一组平行投影将三维对象投影到投影平面上去，即场景中的物体没有近大远小的效果。 正交投影(Orthographic)(右): 透视投影的观察体是视锥体，它使用一组由投影中心产生的放射投影线，将三维对象投影到投影平面上去，即屏幕中的物体存在透视效果 Aodio Mixer类似于Windows的音量合成器，但更为复杂可以用来进行多种音效的混合表现要用可百度学习 问题与解决移动和旋转问题有问题的代码 此代码会导致物体旋转后会继续以世界坐标的z轴为前后方向，而导致旋转看起来不起作用，像坐标轴没有跟着旋转一样 正确的代码 修改后一切正常 Vector3.forward和transform.forward的区别 Vector3.forward的值永远是世界坐标（0,0,1），而transform.forward是世界坐标对应的物体坐标的轴的向量 代码记录相机的平滑运动 移动相关 缩放相关 炮弹的爆炸和伤害判定 爆炸相关 计算伤害 子弹的对象池模式 子弹 对象池 IPooler 学习总结游戏循环模式(协程完成) 游戏管理模式一些游戏物体的代码不需要继承MonoBehaviour（无需挂载），只当实例化后赋予其GameObject或直接更具里面的信息实例化一个物体。例如此例中的Tank 或者 一些随机地图的部分地图信息 可能的心得(……..) 协程内调用多个协程，只会在上一个协程调用完成后，下一个协程才会开始 回合制的游戏可以使用协程控制游戏流程，开始、游玩、结束，都很清晰明了 写代码时因该将所有功能块写成函数，可以让代码结构更清晰 尽量将可能的变量全定义在类的开头，理由同上 "},{"title":"部署网站的记录","date":"2021-04-13T08:56:13.000Z","url":"/2021/04/13/Demo/","tags":[["错误总结","/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"],["经验","/tags/%E7%BB%8F%E9%AA%8C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 总结网页属性 其他提示信息 折叠相关 折叠的折叠框 预先打开的折叠框 提示 提示框 type是框的类型·successs·danger·info·warning 图片插入图片需要放在source文件夹下的images下 字体颜色 color=#00ffff 颜色表参考 参考部分参考来源"}]