[{"title":"知识点记录","date":"2022-08-19T14:13:21.000Z","url":"/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/","tags":[["Unity","/tags/Unity/"],["C#","/tags/C/"]],"categories":[["undefined",""]],"content":" Shader 从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果 算法 给定一个数组，有n(n &gt;= 0)个元素，找到数组中第二大的元素 给定一个可包含重复数字的序列 nums ，按序列内字典升序返回所有不重复的全排列。 其中序列内字典升序指的是， 序列内从左到右的非降序排列，例如 nums=[1,2,3], 则因为[1,2,3] &lt; [1,3,2], [3,1,2] &lt; [3,2,1]， [1,2,3]要先于[1,3,2]输出，[3,1,2]要先于[3,2,1]输出 使用STL库用来计算排列组合关系的算法：next_permutation和prev_permutation。 即按字典序(lexicographical)来找到下一个或前一个的排列组合。例：{2，1，3}的下一个是{2，3，1}，前一个是{1，3，2}。字典序即两个组合从左往右依次比较，若某一位A比B小，则A的字典序在B之前。 oop的四个特征 抽象、封装、继承、多态 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。这也体现了大自然中一般与特殊的关系。继承性很好的解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。 封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。 多态性是指的是同一接口的不同实现方式，多态允许基类的指针指向子类方法。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 多态的作用： 不必编写每一子类的功能调用，可以直接把不同子类当父类看，屏蔽子类间的差异，提高代码的通用率/复用率 父类引用可以调用不同子类的功能，提高了代码的扩充性和可维护性 迭代器和数组的区别迭代器：迭代器（iterator）有时又称光标（cursor）是程序设计的软件设计模式，可在容器对象（container，例如链表或数组）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。 C# 迭代器模式 指按照一定顺序来访问一个集合对象中的每个元素, 但是同时不会暴露集合对象的内部结构. C#中内置的迭代器模式就是Foreach语句, 它可以顺序遍历容器中的每个元素. 而迭代器的具体实现主要是靠IEnumerable 和IEnumerator. IEnumerator IEnumerator接口其实就是foreach的具体实现, 它只定义了三个函数, 如下 也就是说我们实现一个最简单的IEnumerator接口只需要实现这三个函数即可. MoveNext()表示向集合中的下一个元素移动, 如果有下一个元素返回true, 没有就返回false. Current是一个只读属性, 返回当前迭代器所指元素. Reset()表示重置迭代器到第一个元素. 这就是一个简单的IEnumerator, 如果用Foreach输出, 可以得到从9到0的十个计数. 而具体的实现过程还需要IEnumerable. IEnumerable IEnumerable可以粗略的理解为可迭代(遍历)的, 如果接口继承了IEnumerable, 那么就可以使用Foreach语句进行迭代操作. 这个接口只定义了一个函数, 如下: 这个函数需要返回一个我们刚才定义的IEnumerator, 即告知上层调用方可以枚举. 这个时候我们的迭代器已经实现, 可以使用Foreach语句进行迭代操作. 我们现在有一个完整的迭代器了, 但是有一个问题, 很多时候我们需要的迭代器并不复杂, 如上面的计数装置, 如果每次都需要实现IEnumerator和IEnumerable十分不方便, 显得头重脚轻, 这时我们可以使用yield. yield yield是为了方便使用迭代器而产生的语法糖, 他可以直接使用在返回类型为IEnumerable或IEnumerator的函数中直接实现迭代器操作. 它有两种用法yield break 和yield return (something) 效果和break与return一样. 当使用yield return在foreach语句中进行迭代器操作时, 每一次执行到yield return时都会返回后面定义的something并且记录函数内的信息, 下一次运行时继续. 这里我们在i = 5的时候使用了yield break终止了迭代器操作, 如果去掉它, 这个函数就和我们刚才定义的迭代器作用一样, 产生了9到0, 共10个数的倒数. 协程(coroutine) 除了foreach语句, Unity中另一种迭代器模式就是协程, 它是根据每一次IEnumerator的MoveNext()方法调用进行迭代的, 有些类似于Unity的Update方法. 同时它可以结合Unity的yield return new WaitForSeconds(time)等等接口实行迭代器+定时器模式.使用和停止协程比较简单, 都只要传入IEnumerator就可以. 使用协程的方法实现我们的从9数到0. 值得注意的是unity里有很多可以和yield结合使用的语句块, 如上的代码不仅实现了从9数到0, 还实现了每隔1秒数一次, 数到0后继续从头开始数, 当然还有很多其他有趣的功能可以通过coroutine和yield实现. 泛型的作用。泛型和传统类型Boxing/UnBoxing的区别 泛型：即通过参数化类型来实现在同一份代码上操作多种数据类型。泛型编程是一种编程范式，它利用“参数化类型”将类型抽象化，从而实现更为灵活的复用。 作用：减少拆装箱，确保类型安全 区别： 装箱：值类型转引用类型。开辟一块内存空间进行存放数据。 拆箱：引用类型转值类型。 写一个泛型类 C 使其继承自 CBase 性能优化 当你接手一个新项目，当运行一段时间后，发现内存占用高且帧率低，如何解决 性能优化： C#语法C# 特性（Attribute）特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。 特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：预定义特性和自定义特性。 规定特性（Attribute）的语法如下： 预定义特性（Attribute） .Net 框架提供了三种预定义特性： AttributeUsage：描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。 规定该特性的语法如下：[AttributeUsage( validon, AllowMultiple=allowmultiple，Inherited=inherited)] 参数 validon规定特性可被放置的语言元素。它是枚举器AttributeTargets的值的组合。默认值是AttributeTargets.All。 参数allowmultiple(可选的)为该特性的AllowMultiple属性(property)提供一个布尔值。如果为true，则该特性是多用的。默认值是false(单用的) 参数inherited(可选的)为该特性的Inherited 属性(property)提供一个布尔值。如果为true，则该特性可被派生类继承。默认值是false(不被继承)。 Conditional：我们可以将一些函数隔离出来，使得它们只有在定义了某些环节变量或者设置了某个值之后才能发挥作用 Obsolete：它标记了不应被使用的程序实体。当一个新方法被用在一个类中，但若仍然想要保持类中的旧方法，可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。 参数 message，是一个字符串，描述项目为什么过时以及该替代使用什么。 参数 iserror，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。 特殊类 密封类：不能被继承 关键字：sealed 接口类：接口定义了所有类继承]接口时应遵循的语法合同 Interface 抽象类：不能被实例化，可以包含非抽象成员 abstract 反射的作用动态创建一个数据集，并获得其类型T，调用T的Create函数。 .NET的一个强大功能是它可以通过一种称为反射(reflection)的过程访问应用程序的元数据。简单地说，反射就是运行时查询类型信息的能力。可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。 反射（Reflection）有下列用途： 它允许在运行时查看特性（attribute）信息。 它允许审查集合中的各种类型，以及实例化这些类型。 它允许延迟绑定的方法和属性（property）。 它允许在运行时创建新类型，然后使用这些类型执行一些任务。 优点： 1、反射提高了程序的灵活性和扩展性。 2、降低耦合性，提高自适应能力。 3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。 2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。 如何获得Prefab的GameObject类型，PrefabInstance和ModelPrefabInstance的区别委托和事件的区别 委托类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。 委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类 事件（Event） 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。 C# 中使用事件机制实现线程间的通信。 通过事件使用委托 事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 发布器（publisher） 类。其他接受该事件的类被称为 订阅器（subscriber） 类。事件使用 发布-订阅（publisher-subscriber） 模型。 发布器（publisher） 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。 订阅器（subscriber） 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序） 区别 委托 Delegate 是一个类，在任何可以声明类的地方都可以声明委托。 可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。 事件 在类的内部，它总是private 的。 在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。 使用事件不仅能获得比委托更好的封装性以外，还能限制含有事件的类型的能力。 事件应该由事件发布者触发，而不应该由事件的客户端（客户程序）来触发。 Unity生命周期函数Awake -&gt; OnEnable -&gt; Start -&gt; FixedUpdate -&gt; OnTrigger/OnCollision -&gt; 输入事件 -&gt; Update -&gt; LateUpdate -&gt; 渲染(Scene -&gt; Gizmo -&gt; GUI) -&gt; OnDisable -&gt; OnDestroy AssetBundleAssetBundle是Unity中的一种资源包，这种资源包可以是游戏内要用到的几乎所有资源，并且可以在运行时动态加载。 卸载Load的asset资源，通过Resources.UnloadAsset(asset)来进行卸载； 压缩格式：LZMA, LZ4, 以及不压缩。 LZMA是一种默认的压缩形式，这种标准压缩格式是一个单一LZMA流序列化数据文件，并且在使用前需要解压缩整个包体。能使压缩后文件达到最小，但是解压相对缓慢。 LZ4能使得压缩量更大，而且在使用资源包前不需要解压整个包体。 不压缩的方式打包后包体会很大，导致很占用空间 AssetBundle的卸载和加载 加载 AssetBundle.LoadFromFile：从本地加载 AssetBundle.LoadFromMemory：从内存加载 AssetBundle.LoadFromMemoryAsync：从内存异步加载 从AB中加载资源 AssetBundle.LoadAsset(assetName) ：加载AB包中的指定对象，不包含依赖的包 AssetBundle.LoadAllAssets() ：加载AB包中所有的对象，不包含依赖的包 AssetBundle.LoadAssetAsync() ：异步加载，加载较大资源的时候 AssetBundle.LoadAllAssetsAsync() ：异步加载全部资源 AssetBundle.LoadAssetWithSubAssets() ：加载资源及其子资源 卸载 AssetBundle.Unload(true)：卸载所有资源，包含其中正被使用的资源 AssetBundle.Unload(false)：卸载所有没被使用的资源 Resources.UnloadUnusedAssets()：卸载未使用的资源 protobuf重写和重载的区别​ 1.定义不同—-重载是定义相同的方法名，参数不同；重写是子类重写父类的方法。 ​ 2.范围不同—-重载是在一个类中，重写是子类与父类之间的。 ​ 3.多态不同—-重载是编译时的多态性，重写是运行时的多态性。 ​ 4.返回不同—-重载对返回类型没有要求，而重写要求返回类型，有兼容的返回类型。 ​ 5.参数不同—-重载的参数个数、参数类型、参数顺序可以不同，而重写父子方法参数必须相同。 ​ 6.修饰不同—-重载对访问修饰没有特殊要求，重写访问修饰符的限制一定要大于被重写方法的访问修. 堆(Heap)和栈(Stack) 程序内存 栈：由操作系统自动分配释放，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。 堆：堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。 区别： 管理方式不同。栈自动释放；堆手动释放，容易产生内存泄漏 空间大小不同。栈 &lt;&lt; 堆。 生长方向不同。堆的内存地址由低到高；栈的内存地址由高到低。 分配方式不同。堆都是动态分配的；栈有静态分配和动态分配。 数据结构 栈：线性表。先进后出(First In Last Out). 堆：树形结构，是一种特殊的完全二叉树。满足所有节点的值总是不大于或不小于父节点的值的完全二叉树。根节点最大称为大顶堆，根节点最小称为小顶堆。 值类型存储在栈中；引用类型存储在堆上。 GC​ 什么是GC：即Garbage Collection，垃圾回收。当使用可用内存不能满足内存请求时，GC会自动进行。 C#中的GC GC的四个步骤。 垃圾回收器搜索内存中的托管对象； 从托管代码中搜索被引用的对象并标记为有效； 释放没有被标记为有效的对象并收回内存； 整理内存将有效对象挪动到一起。 GC的作用： 提高软件系统的内聚。 降低编程复杂度，使程序员不必分散精力去处理析构。 不妨碍设计师进行系统抽象。 减少由于内存运用不当产生的Bug。 成功的将内存管理工作从程序的编写时，脱离至运行时，使不可预估的管理漏洞变为可预估的。 什么是垃圾 只要判定一个引用类型对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。 对象代龄 CLR初始化后的第一批被创建的对象被列为0代对象。 回收方法 Finalizer(析构函数)：一般不用，因为不确定GC调用时间，影响效率。 Dispose：继承IDisposable接口，实现Dispose方法；调用Dispose方法，销毁对象，需要显示调用或者通过using语句，在显示调用或者离开using程序块时被调用。’ Mark-Compact 标记压缩算法 Generational 分代算法 Unity中的CG Boehm GC(非分代非压缩) Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGen GC的设计思想）。 Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。 降低GC的方法： 使用对象池 减少string，使用StringBuilder 减少拆装箱 struct中不要有引用类型变量 主动调用GC 三色标记清除法 三色：黑色、灰色、白色 黑色: 表示对象以及被垃圾收集器访问过，且这个对象的引用都已经扫描过。黑色的对象代表以及扫描过，他是安全存活的，如果有其他对象引用指向了黑色对象，无需重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。 灰色: 表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描到 白色: 表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色，如在分析结束的阶段，仍然是白色的对象，即代表不可达。 步骤： 刚开始，所有对象都在白色集合中 将GC Roots直接引用的对象挪到灰色集合中 从灰色集合中获取对象： 将本对象的引用到的对象放入灰色集合中 将本对象放入黑色集合中 重复步骤3，直到灰色集合为空结束 结束后，仍在白色集合的对象即为GC Roots不可达，可以进行回收。 三代标记清除法 Lua pairs和ipairs 同：都能遍历集合，均按优先顺序输出没有key的值 异：对于又key的值 ipairs从第一个数字key开始，依次输出所有的key+1的键值，遇到字母下标不会结束遍历，但不输出，如果遇到nil则退出；pairs无序输出字母类型key或者数字类型key的键值，遇到nil不输出，也不会停止遍历。 __index和__newindex __index：(get)当在表中找不到元素时，lua会从 __index指向的表查找元素或获得方法的返回值。 __newindex：(set)对表中不存在的值进行赋值时调用。 当__newindex指向一个函数时，会执行该函数，且对本表的创建不成功； 当__newindex指向一个表时，会对指向的表进行操作，且对本表创建不成功。 __rawset和 __rawget 可以通过rawset和rawget操作绕过原表这一过程(__index和__newindex)，直接把这个表相应的结论输出。 a 网络同步​ 网络同步的目标时保证多台机器的游戏表现完全一致 帧同步 原理： 帧同步的战斗逻辑在客户端； 在帧同步下，服务端只转发操作，不做任何逻辑处理； 客户端按照一定的帧速率（逻辑帧）去上传当前的操作指令，服务端将操作指令广播给所有客户端； 当客户端收到指令后执行本地代码，如果输入的指令一致，计算的过程一致，那么计算的结果肯定是一致的，这样就能保证所有客户端的同步，这就是帧同步。 缺点： 由于帧同步战斗逻辑都在客户端，服务器没有验证，外挂成本低（加速、透视、自动瞄准、数据修改等）； 网络条件较差的客户端会影响其他玩家的游戏体验。（优化方案：乐观帧锁定、渲染与逻辑帧分离、客户端预执行、指令流水线化、操作回滚等）； 不同机器浮点数精度问题、容器排序不确定性、RPC时序、随机数值计算不统一。 乐观帧锁定： 状态同步 原理： 状态同步的战斗逻辑在服务端； 在状态同步下，客户端更像是一个服务端数据的表现层； 一般流程： 客户端上传操作到服务器； 服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态； 客户端收到状态后再根据状态显示内容。 缺点： 状态同步的回放实现较为复杂； 延迟过大、客户端性能浪费、服务端压力大； 对带宽的浪费。对于对象少的游戏，可以用快照保存整个游戏的状态发送，但一旦数量多起来，数量的占用就会直线上升。（优化：增量快照同步，协议同步指定数据） 区别 属性 状态同步 帧同步 流量 相对高 相对低 回放 记录文件大，且实现相对复杂 记录文件小，且相对容易实现 安全性 服务器实现逻辑，安全性高 逻辑在客户端，防作弊难度高 服务器压力 逻辑在服务端，压力大 小 战斗校验 服务端可以重跑一遍战斗 网络卡顿表现 瞬移，回位 卡顿 表现优化 表现优化用于弱化玩家对延迟的感受。 插值优化：客户端采用插值，避免位置突变 客户端预测+回滚 "},{"title":"热更新","date":"2022-08-16T01:41:04.000Z","url":"/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/","tags":[["Lua","/tags/Lua/"],["Unity","/tags/Unity/"],["C#","/tags/C/"],["xlua","/tags/xlua/"]],"categories":[["undefined",""]],"content":" 资源目录划分"},{"title":"Lua学习","date":"2022-08-12T02:30:23.000Z","url":"/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/","tags":[["Lua","/tags/Lua/"]],"categories":[["undefined",""]],"content":" Lua5.3参考手册 语法： 变量 动态类型 弱类型 大小写敏感 默认全局 带GC 类型：nil、boolean、number、string、function、userdata(用户自定义类型)、tread、table 语句 数据结构 Table function 函数 运算符 函数库：例 协程 OO 面向对象 类的继承的简单实现 简单封装的实现 闭包 "},{"title":"数据结构与算法","date":"2022-05-12T02:30:23.000Z","url":"/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","tags":[["C++","/tags/C/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":" 算法复杂度时间复杂度：指执行算法所需要的工作量。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，即考察输入值大小趋近无穷时的情况。 空间复杂度：指执行算法需要的内存空间 数据结构栈（Stack）：后进先出的数据结构。只能在栈顶进行添加（入栈）和删除（出栈）的操作。 应用：①撤销操作，②数组反转，③递归 队列（Queue）： 先进先出的数据结构，只能在队尾添加（入队）元素，队首删除（出队）元素。（双向队列无尾首区别） 循环队列 性能最好 应用：排队 集合（Set）：包含不重复元素的集合称为set，例如HashSet等，能快速的进行去重操作。 应用：词汇量统计 映射（Reflection）：特殊集合，例如Dictionary，存储的是键值对 应用：词汇量统计 有序数组： Rank使用二分查找找到target的对应位置，方便add 和 remove 的操作，保证数组始终有序 树：​ 二叉树（Binary Tree）：普通二叉树 ​ 满二叉树（Full Binary Tree）：除了叶子节点外都有两个节点 ​ 完全二叉树（Complete Binary Tree）：每层的节点均达到最大值，及每层的节点数为2的n-1次方个 ​ 二叉搜索树（Binary Search Tree）：每个节点左边所有节点的值均小于右边节点的值 ​ 平衡二叉树（AVL Tree）：任何节点的两颗字数的高度差小于等于1 ​ B树（B-Tree）：B树与平衡二叉树一样，但是是多叉树 ​ 红黑树（Red-Black Tree）：自平衡二叉寻找数 ​ 算法排序：升序为例 冒泡：双重循环，依次比较大小，前一个比后一个大，则交换位置，时间复杂度O(n^2) 选择：双重循环，但内循环只选出第 i 个即其之后位置的最小值，然后和第 i 个位置交换，时间复杂度O(n^2) 快排：以第一个数为界 记flag，从前往后找出第一个比flag大的值，从后往前，找出第一个比flag小的数，然后交换两个数的位置。直到找到flag的位置，然后递归查找flag的左侧和右侧的中间值 时间复杂度O(n log2 n) 不能对存在重复元素的数组进行排序 若快排前数组有序，则时间复杂度为O(n^2) 排序前可以将第一个元素与中间或随机元素进行交换，可优化时间复杂度 三路快排：有重复元素的快速排序 ，即相比上一个方法，多了等于flag的情况 即将数组中的元素分为三个区域，大于[gt, right] 小于[l+1, lt]和等于选定值flag的情况 i 指向当前元素 若 i 指向元素等于flag，则i++； 若 i 指向元素小于flag，则将 it + 1 指向的值与 i 交换，然后 it++、i++。即将小于flag的区域增1，且等于flag的区域右移1. 若 i 指向的元素大于flag， 则将 gt - 1 指向的元素与 i 交换，然后 gt—。即将大于flag的区域向后增1，其余区域不变 当 i 指向 gt 时，表示遍历完成，此时只需将 flag 除的值与 lt 处的值进行交换，则三个区间形成，然后继续遍历大于flag和小于flag的区域 归并：采用分治法，先使子序列有序，然后将两个有序子序列合并，得到有序序列。即先将输入序列分成n/2个子序列，对这两个子序列分别采用归并排序，将两个排序好的子序列合并成排序序列，时间复杂度O(nlogn) 堆： 桶： 查找： 顺序查找O(n)：遍历所有数据，进行处理 二分查找O(log n)：对有序数组进行分半查找，每次为对比中间数据，然后根据大小关系，对前半部分或后半部分进行对比。 递归(recursion)： 程序调用自身的编程技巧称为递归，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解.。递归需要有边界条件、递归前进段和递归返回段。 并查集 定义：在一些有N个元素的集合应用问题中，通常在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 主要用于解决一些元素分组的问题，用于管理一系列不相交的集合并存在两种操作： 查找(Find):查询两个元素是否在同一个集合中； 合并(Union):把两个不相交的集合合并成一个集合。 最简单版本的并查集代码： 直接合并可能会导致每次查询的路径过长，而增加时间消耗，因此，存在两个方面对算法进行优化 路径压缩：在查询过程中把沿途的每个节点的父节点全部设置为根节点 按秩合并：用rank[]数组记录每个根节点对应的深度。初始化为1。合并时把rank较小的合并在较大的根节点上 路径压缩和按秩合并如果一起使用，时间复杂度接近 ，但是很可能会破坏rank的准确性。 "},{"title":"剑指offer","date":"2021-09-16T08:45:47.000Z","url":"/2021/09/16/%E5%89%91%E6%8C%87offer/","tags":[["c++","/tags/c/"]],"categories":[["c++","/categories/c/"]],"content":" 链表 链表反转： 开始先设定三个指针，并进行初始化，如图 并将Pre的指向的Next指向NULL 开始循环，head指针后移，让Cur指针的Next指向Pre，然后使Pre = Cur，Cur = Head。直到链表尾 二分法模板： 广度优先遍历（BFS） 深度优先遍历（DFS） 例题：剑指 Offer 12. 矩阵中的路径 用dfs深度遍历加回溯法。 字符串 清除字符串前后的空格符号 二叉树​ 前序遍历：优先遍历根节点，然后是左子节点，再是右子节点 ​ A-B-D-F-G-H-I-E-C 中序遍历：优先遍历左子节点，然后是根节点，再是右子节点 ​ F-D-H-G-I-B-E-A-C 后序遍历：优先遍历左子节点，然后是右子节点，再是根节点 ​ F-H-I-G-D-E-B-C-A 二叉树转化成双向链表：用中序遍历 数据结构 优先队列：priority_queue 包含在头文件 ‘queue’ 中,我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队. 优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的 二叉搜索树：Binary Search Tree 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 中序遍历得到的结果使有序的 算法 分组位运算：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 相同数字异或为零 "},{"title":"FSM状态机","date":"2021-07-29T11:36:24.000Z","url":"/2021/07/29/FSM%E7%8A%B6%E6%80%81%E6%9C%BA/","tags":[["unity","/tags/unity/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 介绍FSM是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的机器。 是一种设计模式 代码设计 "},{"title":"3D RPG 学习笔记","date":"2021-07-23T07:38:31.000Z","url":"/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["unity","/tags/unity/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 一、创建项目导入素材 创建普通项目 在Package Manager中安装Universal RP 在Asset中创建Rendering =&gt; Universal Render Pipeline =&gt; Pipeline Asset(URP的设置文件) 将project setting中Graphics和Quality的渲染管线设置为刚创建的渲染管线设置文件 导入素材（Dog Knight PBR Polyart、 Low-Poly Simple Nature Pack 和 FREE Skybox Extended Shader） 在Edit =&gt; Edit=Render Pipeline =&gt; Universal Render Pipeline 中设置当前项目或当前素材的渲染管线 在Lighting =&gt; Environment 中设置天空盒的材质 注意Asset窗口和Inspect窗口的物体分类，方便管理 安装package PolyBrush 调整地面的高度(左键直接点击变高，control+左键点击变矮) Outer Radius：外圈大小 Inner Radius：内圈大小 Strength：变化强度 Direction：设置变化的方向。Brush normal：材质的法线方向 Brush Mirroring：沿坐标轴对称形成另一个笔刷同时进行相同操作 柔化：将比较突出的棱角变的平滑。设置基本同上 将当前物体刷上不同的颜色 如果需要将颜色刷到物体上，则物体材质的 shader 需要为 Polybrush=&gt; Shader 下的shader Brush：根据笔刷的大小刷上颜色 Fill：填充区块 Flood：整个物体 将预制体刷到场景当中 基本设置同1 将需要的prefab添加到Current Palette中，当前选中的prefab会在Brush Loadout中 Brush Loadout 中prefab下的拖动条表示此物体出现的概率 Hit Surface is Parent：将所有的画在平面上的物体都是此平面的子物体 将texture刷到场景当中 同4 Pro Builder 按住shift可以查看图标的功能 Pro Grids 安装ProGrids需要在Project Setting的Package Manger中打开允许preview 设置物体移动时的单位距离 是否在Scene窗口中显示坐标轴 是否自动吸附：即按照1的设置在坐标轴上自动进行吸附，每次只移动1的距离 4 5 X 、Y、 Z、 3D均为Scene窗口显示的坐标轴 Navigation自动导航 点击移动 自定义事件的注册和调用 注册 调用 屏幕射线转为世界射线 单例模式 方便事件函数等在外部的调用 事件注册和调用 功能实现 鼠标指针图片切换 Cinemachine：多功能相机插件 Post Processing：后处理 Animator Shader Graph 遮挡剔除 FSM 状态机 "},{"title":"每日一题","date":"2021-07-19T07:49:14.000Z","url":"/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","tags":[["C#","/tags/C/"],["Leetcode","/tags/Leetcode/"]],"categories":[["每日一题","/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"]],"content":" 面试题 10.02. 变位词组编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串 示例： 说明： 所有输入均为小写字母。 不考虑答案输出的顺序 题解： 思路：计数法。 计算每个字符串中所有字符出现的个数，将相同的放在同一个list中，完成分类 代码： 1877. 数组中最大数对和的最小值题解： 分析： 最大与最小相加产生的数对和最小，即第k大的数和第k小的数相加，所得的最大数对和最小. 所以先将数组进行排序，然后依次下相加比较，即得出结果 代码： 1893. 检查是否区域内所有整数都被覆盖题解： 分析： 暴力解法，用一个 right-left+1 大小的数组来记录，直接通过二重循环，依次判断ranges中的每个[start,end]中是否包含[left,right]中的任意数字，如果包含，则对应的数组的值加一，循环完毕后再次循环判断数组中是否有0，有则为false，没有返回true。 代码： 1743. 从相邻元素对还原数组题解： 分析： 将数组中的数对用字典储存，则数组头或尾中字典的list的长度只有1，然后在通过字典，一次查找下一个 代码： 704. 二分查找 2021/9/7题解： 分析： 经典二分题，将数组分成两个部分，通过判断中间数字和目标数字的大小比较，然后进入目标数字存在的部分再次进行二分查找 在进行中间下标的计算时，若直接用 (left + right)/2 会导致一些特殊情况出现问题，所以使用 (right - left)/2 + left， 或直接使用位移运算 left + right &gt;&gt; 1。 代码： 470. 用 Rand7() 实现 Rand10() 2021/9/6题解： 分析： Rand7() 有 1~7 共7种数字，49种情况，所以从1-10依次分布如下 ​ 代码： 1221. 分割平衡字符串 2021/9/7题解： 分析： 循环计算字符串中的L和R的字符个数，当两个个数相等时就表示出现一个平衡字符串，则计数器加一。 代码： 678. 有效的括号字符串 2021/9/12题解： 分析： 堆栈法： 对字符串s逐个字符进行判断，有如下三种情况 如果字符是左括号，则将其下标压入左括号栈 如果字符是星号，则将其下表压入星号栈 如果字符是右括号，则 如果左括号栈中元素不为空，则将左括号栈中顶部元素出栈 如果左括号栈中元素为空，星号栈中元素不为空，则将星号栈中顶部元素出栈 如果两个栈中元素都为空，则此右括号无匹配元素，返回false 字符串遍历完后，如果两个栈中元素都不为空，则依次将两个栈中的栈顶元素出栈，然后比较两个元素的大小，如果左括号栈的出栈下标比星号栈的出栈下标大，则表示左括号在星号的后面，无法匹配，返回false 最后判断左括号栈中的所有元素是否全部出栈，即所有左括号均有匹配，则返回true（星号可以为空字符，所以星号栈不需要做判断） 动态规划： 贪心： 代码： 447. 回旋镖的数量 2021/9/12题解： 分析： 直接三重循环依次判断三个点是否组成等边三角形，然后返回值。（严重超时） 一个回旋镖可以看作三个点组成的一个等边三角形，所以要判断是否可以放置回旋镖即判断是否可以组成等边三角形，即找到两个点到同一个点的距离相同。每多一个点到顶点的距离相同，就会多两个可摆放的回旋镖（存在位置差异，n&gt;=2），即为n的排列组合。 An = n * (n - 1) 所以我们可以采用枚举的方法，依次判断所有点到其他点的距离，并用字典储存,再在最后进行判断。 代码： 524. 通过删除字母匹配到字典里最长单词 2021/9/14题解： 分析： 题目描述不清楚，应为在第二个参数dictionary中找到最长的s的，且相同长度下字典序靠前的子字符串。 所以先将字典中的字符串按长度和字典序进行排序，然后依次判断是否为s的子串。 排序时需要先将 IList 转化为 List var list = new List(dictionary); 然后使用List的Sort方法 代码： 162. 寻找峰值 2021/9/15题解： 分析： 该题需要时间复杂度为O(log n)，所以直接循环查找行不通。 因此需要使用二分法进行查找。 在二分查找时有四种情况 nums[mid - 1] &lt; nums[mid] &lt; nums[mid + 1]，此时右边一定存在一个峰值 nums[mid - 1] &gt; nums[mid] &gt; nums[mid + 1]，此时左边一定存在一个峰值 nums[mid - 1] &gt; nums[mid] &lt; nums[mid + 1]，此时左边和右边都存在峰值 nums[mid - 1] &lt; nums[mid] &gt; nums[mid + 1]，此时mid 本生就为一个峰值 对上述四种情况进行优化，可以分为两种情况，峰值在左边（右边）和峰值在右边（左边）和中间 代码： "},{"title":"VRTK学习记录","date":"2021-06-06T11:27:43.000Z","url":"/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":[["错误总结","/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"],["经验","/tags/%E7%BB%8F%E9%AA%8C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 配置环境unity 2018.4.14VRTK 3.3.0steamVR 1.2.3 键鼠模拟基本操作 wasd控制人物移动 鼠标默认控制人物方向 alt切换控制模式 鼠标：控制人物方向 —&gt;控制左右Controller的水平位置 ctrl：按住ctrl控制Controller的垂直位置 tab切换左右Controller ctrl 切换为抓取物体模式 鼠标右键为右Controller抓取 鼠标左键为左Controller抓取 shift 奔跑 q 发出射线 鼠标右键代表Controller的扳机 基本配置 新建场景，删除原本的Camera。 simulator为键鼠模拟；steamVr为设备操作；[VRSimulator_CameraRig]是VRTK的prefab，可直接使用； RightController 为右控制器； LeftController 为左控制器； PlayArea 为需要传送时添加。 VRTK SDK 需要添加VRTK_SDKManager 组件，并将子物体simulator和steamVR添加到组件中Setups的列表中（因为只需要键鼠模拟，所以只添加了simulator），然后将左右手控制器分别添加到Scripts Aliases中。 Simulator和SteamVR需要添加VRTK_SDK Setup 组件，并将Quick Select设置为相应的模式 Controller相关控制器基本组件​ ​ ​ ​ 射线类型可以为直线(VRTK_Straight Pointer Renderer)或贝塞尔曲线(VRTK_Bezier Pointer Renderer) ​ Heighlighter …. ； VRTK_UI Pointer为ui互动所必须组件 射线与场景互动控制器上可以添加自定义脚本，使之可以与场景中的物体进行互动,脚本参考VRTK_ControllerPointerEvents_ListenerExample ​ "},{"title":"JavaScript","date":"2021-04-25T08:12:15.000Z","url":"/2021/04/25/Web/","categories":[["Web","/categories/Web/"]],"content":" 概念外部JavaScript脚本的调用：&lt;script src = &quot;../../路径&quot;&gt;&lt;/scripts&gt; NaN：not a Number 逻辑运算（&amp;&amp;）：谁在表达式中起关键性作用，结果就是谁例：true &amp;&amp; 4 &amp;&amp; “aaa”x输出 “aaa” 0 &nbsp;&nbsp; “0” &nbsp;&nbsp; “” &nbsp;&nbsp; null &nbsp;&nbsp; NaN &nbsp;&nbsp; undefined =&gt; false 用 new 创建的对象为引用类型（object） 预定义函数parseInt():将字符转化为Int eval(string):string为一个可计算的字符串或者是可执行的表达式 对象prototype可以为一个类创建一个共有的模板新new的对象会调用模板中的属性 数组cars = [“0”, 2, new Object()];//数组中的元素可以不同 joinjoin() : 将数组中的元素拼接成字符串，默认连接符为“,” splicesplice(index, howmany, [item1, … , itemx], item, …) : howmany为从index的位置开始删除元素的个数，后面的为插入的元素 sortsort(function(a,b){return b - a}); 数字的降序排列sort(function(a,b){return a - b}); 数字的升序排列 Dateunix时间戳，从1970.1.1到xxxx.xx.xx的毫秒数 Mathround() 四舍五入random() 返回0~1的随机数"},{"title":"数电","date":"2021-04-19T13:05:33.000Z","url":"/2021/04/19/%E6%95%B0%E7%94%B5/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[["数电","/categories/%E6%95%B0%E7%94%B5/"]],"content":" 第四章：组合逻辑电路编码器 译码器 选择器 \\mid \\mathrm{Y}_{1}=\\left[\\mathrm{D}_{10}\\left(\\mathrm{~A}_{1} \\mathrm{~A}_{0}^{\\prime}\\right)+\\mathrm{D}_{11}\\left(\\mathrm{~A}_{1}^{\\prime} \\mathrm{A}_{0}\\right)+\\mathrm{D}_{12}\\left(\\mathrm{~A}_{1} \\mathrm{~A}_{0}^{\\prime}\\right)+\\mathrm{D}_{13}\\left(\\mathrm{~A}_{1} \\mathrm{~A}_{0}\\right)\\right]^{*} \\mathrm{~S}_{1}加法器一位加法器 多位加法器 \\begin{array}{l} (\\boldsymbol{C I})_{i}=(\\boldsymbol{C O})_{i-1} \\\\ \\boldsymbol{S}_{i}=\\boldsymbol{A}_{i} \\oplus \\boldsymbol{B}_{i} \\oplus(\\boldsymbol{C I})_{i} \\\\ (\\boldsymbol{C O})_{i}=A_{i} \\boldsymbol{B}_{i}+\\left(\\boldsymbol{A}_{i}+\\boldsymbol{B}_{i}\\right)(\\boldsymbol{C I})_{i} \\end{array}数值比较器一位数值比较器 "},{"title":"TANKS! Unity Tutorial 项目学习记录","date":"2021-04-13T15:25:35.000Z","url":"/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":[["Unity","/tags/Unity/"],["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[["Unity","/categories/Unity/"]],"content":" APISmoothDamp平滑的改变当前值至另一个值 *current*：当前位置 *target*：尝试达到的目标值 *currentVelocity*：当前速度，该值在每次调用时都会由函数修改。 *smoothTime*：达到目标值的时间 *maxSpeed*：最大速度 *deltaTime*：默认为Time.deltatime *ref关键字*：相当于c的指针传参，及引用传参。 InverseTransformPoint 将position这个Vector3类型变量转化为 以V3的世界坐标为零点基准的情况下 position相对于V3的坐标值。 PhysicsPhysics.OverlapSphere检测范围内的Collider public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); *position*：圆心 *radius*：检测半径 *layerMask*：检测层级 *queryTriggerInteraction*：判断是否应该检测Trigger RigidbodytargetRigidbody.AddExplosionForce爆炸力将随着到物体的距离变小。 public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)); *explosionForce*：爆炸的力量（会根据距离变化） *explosionPosition*：爆炸中心 *explosionRadius*：爆炸半径 *upwardsModifier*：可以调整爆炸的位置，让物体有被炸起来向上的效果，但爆炸本身的位置不变 *ForceMode*：对物体施加力的方法 Manual相机的两种投影方式 透视投影(Perspective)(左): 正交投影的观察体是长方体，它使用一组平行投影将三维对象投影到投影平面上去，即场景中的物体没有近大远小的效果。 正交投影(Orthographic)(右): 透视投影的观察体是视锥体，它使用一组由投影中心产生的放射投影线，将三维对象投影到投影平面上去，即屏幕中的物体存在透视效果 Aodio Mixer类似于Windows的音量合成器，但更为复杂可以用来进行多种音效的混合表现要用可百度学习 问题与解决移动和旋转问题有问题的代码 此代码会导致物体旋转后会继续以世界坐标的z轴为前后方向，而导致旋转看起来不起作用，像坐标轴没有跟着旋转一样 正确的代码 修改后一切正常 Vector3.forward和transform.forward的区别 Vector3.forward的值永远是世界坐标（0,0,1），而transform.forward是世界坐标对应的物体坐标的轴的向量 代码记录相机的平滑运动 移动相关 缩放相关 炮弹的爆炸和伤害判定 爆炸相关 计算伤害 子弹的对象池模式 子弹 对象池 IPooler 学习总结游戏循环模式(协程完成) 游戏管理模式一些游戏物体的代码不需要继承MonoBehaviour（无需挂载），只当实例化后赋予其GameObject或直接更具里面的信息实例化一个物体。例如此例中的Tank 或者 一些随机地图的部分地图信息 可能的心得(……..) 协程内调用多个协程，只会在上一个协程调用完成后，下一个协程才会开始 回合制的游戏可以使用协程控制游戏流程，开始、游玩、结束，都很清晰明了 写代码时因该将所有功能块写成函数，可以让代码结构更清晰 尽量将可能的变量全定义在类的开头，理由同上 "},{"title":"部署网站的记录","date":"2021-04-13T08:56:13.000Z","url":"/2021/04/13/Demo/","tags":[["错误总结","/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"],["经验","/tags/%E7%BB%8F%E9%AA%8C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 总结网页属性 其他提示信息 折叠相关 折叠的折叠框 预先打开的折叠框 提示 提示框 type是框的类型·successs·danger·info·warning 图片插入图片需要放在source文件夹下的images下 字体颜色 color=#00ffff 颜色表参考 参考部分参考来源"}]