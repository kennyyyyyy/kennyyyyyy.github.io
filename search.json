[{"title":"笔试题记录","date":"2022-08-19T14:13:21.000Z","url":"/2022/08/19/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/","tags":[["Unity","/tags/Unity/"],["C#","/tags/C/"]],"categories":[["undefined",""]],"content":" 从Render获取材质，获得材质的Shader，获取Shader的Uniform Constant值，每帧修改constant值来实现装备的流光效果 给定一个数组，有n(n &gt;= 0)个元素，找到数组中第二大的元素 oop的四个特征： 抽象、封装、继承、多态 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。这也体现了大自然中一般与特殊的关系。继承性很好的解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。 封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。 多态性是指允许不同类的对象对同一消息作出响应。比如同样的加法，把两个时间加在一起和把两个整数加在一起肯定完全不同。又比如，同样的选择编辑-粘贴操作，在字处理程序和绘图程序中有不同的效果。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 AssetBundle的打包和加载 反射的作用。动态创建一个数据集，并获得其类型T，调用T的Create函数。 .NET的一个强大功能是它可以通过一种称为反射(reflection)的过程访问应用程序的元数据。简单地说，反射就是运行时查询类型信息的能力 基本用法：一是用反射来创建实例，二是用反射调用实例的方法，三是用反射调用实例的属性。 迭代器和数组的区别 迭代器：迭代器（iterator）有时又称光标（cursor）是程序设计的软件设计模式，可在容器对象（container，例如链表或数组）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。 C# 迭代器模式 指按照一定顺序来访问一个集合对象中的每个元素, 但是同时不会暴露集合对象的内部结构. C#中内置的迭代器模式就是Foreach语句, 它可以顺序遍历容器中的每个元素. 而迭代器的具体实现主要是靠IEnumerable 和IEnumerator. IEnumeratorIEnumerator接口其实就是foreach的具体实现, 它只定义了三个函数, 如下 也就是说我们实现一个最简单的IEnumerator接口只需要实现这三个函数即可. MoveNext()表示向集合中的下一个元素移动, 如果有下一个元素返回true, 没有就返回false. Current是一个只读属性, 返回当前迭代器所指元素. Reset()表示重置迭代器到第一个元素. 这就是一个简单的IEnumerator, 如果用Foreach输出, 可以得到从9到0的十个计数. 而具体的实现过程还需要IEnumerable. IEnumerableIEnumerable可以粗略的理解为可迭代(遍历)的, 如果接口继承了IEnumerable, 那么就可以使用Foreach语句进行迭代操作. 这个接口只定义了一个函数, 如下: 这个函数需要返回一个我们刚才定义的IEnumerator, 即告知上层调用方可以枚举. 这个时候我们的迭代器已经实现, 可以使用Foreach语句进行迭代操作. 我们现在有一个完整的迭代器了, 但是有一个问题, 很多时候我们需要的迭代器并不复杂, 如上面的计数装置, 如果每次都需要实现IEnumerator和IEnumerable十分不方便, 显得头重脚轻, 这时我们可以使用yield. yieldyield是为了方便使用迭代器而产生的语法糖, 他可以直接使用在返回类型为IEnumerable或IEnumerator的函数中直接实现迭代器操作. 它有两种用法yield break 和yield return (something) 效果和break与return一样. 当使用yield return在foreach语句中进行迭代器操作时, 每一次执行到yield return时都会返回后面定义的something并且记录函数内的信息, 下一次运行时继续. 这里我们在i = 5的时候使用了yield break终止了迭代器操作, 如果去掉它, 这个函数就和我们刚才定义的迭代器作用一样, 产生了9到0, 共10个数的倒数. 协程(coroutine)除了foreach语句, Unity中另一种迭代器模式就是协程, 它是根据每一次IEnumerator的MoveNext()方法调用进行迭代的, 有些类似于Unity的Update方法. 同时它可以结合Unity的yield return new WaitForSeconds(time)等等接口实行迭代器+定时器模式.使用和停止协程比较简单, 都只要传入IEnumerator就可以. 使用协程的方法实现我们的从9数到0. 值得注意的是unity里有很多可以和yield结合使用的语句块, 如上的代码不仅实现了从9数到0, 还实现了每隔1秒数一次, 数到0后继续从头开始数, 当然还有很多其他有趣的功能可以通过coroutine和yield实现. 多态的作用。多态和传统类型Boxing/UnBoxing的区别 当你接手一个新项目，当运行一段时间后，发现内存占用高且帧率低，如何解决 如何获得Prefab的GameObject类型，PrefabInstance和ModelPrefabInstance的区别 "},{"title":"热更新","date":"2022-08-16T01:41:04.000Z","url":"/2022/08/16/%E7%83%AD%E6%9B%B4%E6%96%B0/","tags":[["Lua","/tags/Lua/"],["Unity","/tags/Unity/"],["C#","/tags/C/"],["xlua","/tags/xlua/"]],"categories":[["undefined",""]],"content":" 资源目录划分"},{"title":"Lua学习","date":"2022-08-12T02:30:23.000Z","url":"/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/","tags":[["Lua","/tags/Lua/"]],"categories":[["undefined",""]],"content":" Lua5.3参考手册 语法： 变量 动态类型 弱类型 大小写敏感 默认全局 带GC 类型：nil、boolean、number、string、function、userdata(用户自定义类型)、tread、table 语句 数据结构 Table function 函数 运算符 函数库：例 协程 OO 面向对象 类的继承的简单实现 简单封装的实现 闭包 "},{"title":"数据结构与算法","date":"2022-05-12T02:30:23.000Z","url":"/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","tags":[["C++","/tags/C/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":" 算法复杂度时间复杂度：指执行算法所需要的工作量。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，即考察输入值大小趋近无穷时的情况。 空间复杂度：指执行算法需要的内存空间 数据结构栈（Stack）：后进先出的数据结构。只能在栈顶进行添加（入栈）和删除（出栈）的操作。 应用：①撤销操作，②数组反转，③递归 队列（Queue）： 先进先出的数据结构，只能在队尾添加（入队）元素，队首删除（出队）元素。（双向队列无尾首区别） 循环队列 性能最好 应用：排队 集合（Set）：包含不重复元素的集合称为set，例如HashSet等，能快速的进行去重操作。 应用：词汇量统计 映射（Reflection）：特殊集合，例如Dictionary，存储的是键值对 应用：词汇量统计 有序数组： Rank使用二分查找找到target的对应位置，方便add 和 remove 的操作，保证数组始终有序 树：​ 二叉树（Binary Tree）：普通二叉树 ​ 满二叉树（Full Binary Tree）：除了叶子节点外都有两个节点 ​ 完全二叉树（Complete Binary Tree）：每层的节点均达到最大值，及每层的节点数为2的n-1次方个 ​ 二叉搜索树（Binary Search Tree）：每个节点左边所有节点的值均小于右边节点的值 ​ 平衡二叉树（AVL Tree）：任何节点的两颗字数的高度差小于等于1 ​ B树（B-Tree）：B树与平衡二叉树一样，但是是多叉树 ​ 红黑树（Red-Black Tree）：自平衡二叉寻找数 ​ 算法排序：升序为例 冒泡：双重循环，依次比较大小，前一个比后一个大，则交换位置，时间复杂度O(n^2) 选择：双重循环，但内循环只选出第 i 个即其之后位置的最小值，然后和第 i 个位置交换，时间复杂度O(n^2) 快排：以第一个数为界 记flag，从前往后找出第一个比flag大的值，从后往前，找出第一个比flag小的数，然后交换两个数的位置。直到找到flag的位置，然后递归查找flag的左侧和右侧的中间值 时间复杂度O(n log2 n) 不能对存在重复元素的数组进行排序 若快排前数组有序，则时间复杂度为O(n^2) 排序前可以将第一个元素与中间或随机元素进行交换，可优化时间复杂度 三路快排：有重复元素的快速排序 ，即相比上一个方法，多了等于flag的情况 即将数组中的元素分为三个区域，大于[gt, right] 小于[l+1, lt]和等于选定值flag的情况 i 指向当前元素 若 i 指向元素等于flag，则i++； 若 i 指向元素小于flag，则将 it + 1 指向的值与 i 交换，然后 it++、i++。即将小于flag的区域增1，且等于flag的区域右移1. 若 i 指向的元素大于flag， 则将 gt - 1 指向的元素与 i 交换，然后 gt—。即将大于flag的区域向后增1，其余区域不变 当 i 指向 gt 时，表示遍历完成，此时只需将 flag 除的值与 lt 处的值进行交换，则三个区间形成，然后继续遍历大于flag和小于flag的区域 归并：采用分治法，先使子序列有序，然后将两个有序子序列合并，得到有序序列。即先将输入序列分成n/2个子序列，对这两个子序列分别采用归并排序，将两个排序好的子序列合并成排序序列，时间复杂度O(nlogn) 堆： 桶： 查找： 顺序查找O(n)：遍历所有数据，进行处理 二分查找O(log n)：对有序数组进行分半查找，每次为对比中间数据，然后根据大小关系，对前半部分或后半部分进行对比。 递归(recursion)： 程序调用自身的编程技巧称为递归，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解.。递归需要有边界条件、递归前进段和递归返回段。 并查集 定义：在一些有N个元素的集合应用问题中，通常在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 主要用于解决一些元素分组的问题，用于管理一系列不相交的集合并存在两种操作： 查找(Find):查询两个元素是否在同一个集合中； 合并(Union):把两个不相交的集合合并成一个集合。 最简单版本的并查集代码： 直接合并可能会导致每次查询的路径过长，而增加时间消耗，因此，存在两个方面对算法进行优化 路径压缩：在查询过程中把沿途的每个节点的父节点全部设置为根节点 按秩合并：用rank[]数组记录每个根节点对应的深度。初始化为1。合并时把rank较小的合并在较大的根节点上 路径压缩和按秩合并如果一起使用，时间复杂度接近 ，但是很可能会破坏rank的准确性。 "},{"title":"剑指offer","date":"2021-09-16T08:45:47.000Z","url":"/2021/09/16/%E5%89%91%E6%8C%87offer/","tags":[["c++","/tags/c/"]],"categories":[["c++","/categories/c/"]],"content":" 链表 链表反转： 开始先设定三个指针，并进行初始化，如图 并将Pre的指向的Next指向NULL 开始循环，head指针后移，让Cur指针的Next指向Pre，然后使Pre = Cur，Cur = Head。直到链表尾 二分法模板： 广度优先遍历（BFS） 深度优先遍历（DFS） 例题：剑指 Offer 12. 矩阵中的路径 用dfs深度遍历加回溯法。 字符串 清除字符串前后的空格符号 二叉树​ 前序遍历：优先遍历根节点，然后是左子节点，再是右子节点 ​ A-B-D-F-G-H-I-E-C 中序遍历：优先遍历左子节点，然后是根节点，再是右子节点 ​ F-D-H-G-I-B-E-A-C 后序遍历：优先遍历左子节点，然后是右子节点，再是根节点 ​ F-H-I-G-D-E-B-C-A 二叉树转化成双向链表：用中序遍历 数据结构 优先队列：priority_queue 包含在头文件 ‘queue’ 中,我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队. 优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的 二叉搜索树：Binary Search Tree 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 中序遍历得到的结果使有序的 算法 分组位运算：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 相同数字异或为零 "},{"title":"FSM状态机","date":"2021-07-29T11:36:24.000Z","url":"/2021/07/29/FSM%E7%8A%B6%E6%80%81%E6%9C%BA/","tags":[["unity","/tags/unity/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 介绍FSM是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的机器。 是一种设计模式 代码设计 "},{"title":"3D RPG 学习笔记","date":"2021-07-23T07:38:31.000Z","url":"/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["unity","/tags/unity/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 一、创建项目导入素材 创建普通项目 在Package Manager中安装Universal RP 在Asset中创建Rendering =&gt; Universal Render Pipeline =&gt; Pipeline Asset(URP的设置文件) 将project setting中Graphics和Quality的渲染管线设置为刚创建的渲染管线设置文件 导入素材（Dog Knight PBR Polyart、 Low-Poly Simple Nature Pack 和 FREE Skybox Extended Shader） 在Edit =&gt; Edit=Render Pipeline =&gt; Universal Render Pipeline 中设置当前项目或当前素材的渲染管线 在Lighting =&gt; Environment 中设置天空盒的材质 注意Asset窗口和Inspect窗口的物体分类，方便管理 安装package PolyBrush 调整地面的高度(左键直接点击变高，control+左键点击变矮) Outer Radius：外圈大小 Inner Radius：内圈大小 Strength：变化强度 Direction：设置变化的方向。Brush normal：材质的法线方向 Brush Mirroring：沿坐标轴对称形成另一个笔刷同时进行相同操作 柔化：将比较突出的棱角变的平滑。设置基本同上 将当前物体刷上不同的颜色 如果需要将颜色刷到物体上，则物体材质的 shader 需要为 Polybrush=&gt; Shader 下的shader Brush：根据笔刷的大小刷上颜色 Fill：填充区块 Flood：整个物体 将预制体刷到场景当中 基本设置同1 将需要的prefab添加到Current Palette中，当前选中的prefab会在Brush Loadout中 Brush Loadout 中prefab下的拖动条表示此物体出现的概率 Hit Surface is Parent：将所有的画在平面上的物体都是此平面的子物体 将texture刷到场景当中 同4 Pro Builder 按住shift可以查看图标的功能 Pro Grids 安装ProGrids需要在Project Setting的Package Manger中打开允许preview 设置物体移动时的单位距离 是否在Scene窗口中显示坐标轴 是否自动吸附：即按照1的设置在坐标轴上自动进行吸附，每次只移动1的距离 4 5 X 、Y、 Z、 3D均为Scene窗口显示的坐标轴 Navigation自动导航 点击移动 自定义事件的注册和调用 注册 调用 屏幕射线转为世界射线 单例模式 方便事件函数等在外部的调用 事件注册和调用 功能实现 鼠标指针图片切换 Cinemachine：多功能相机插件 Post Processing：后处理 Animator Shader Graph 遮挡剔除 FSM 状态机 "},{"title":"每日一题","date":"2021-07-19T07:49:14.000Z","url":"/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","tags":[["C#","/tags/C/"],["Leetcode","/tags/Leetcode/"]],"categories":[["每日一题","/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"]],"content":" 面试题 10.02. 变位词组编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串 示例： 说明： 所有输入均为小写字母。 不考虑答案输出的顺序 题解： 思路：计数法。 计算每个字符串中所有字符出现的个数，将相同的放在同一个list中，完成分类 代码： 1877. 数组中最大数对和的最小值题解： 分析： 最大与最小相加产生的数对和最小，即第k大的数和第k小的数相加，所得的最大数对和最小. 所以先将数组进行排序，然后依次下相加比较，即得出结果 代码： 1893. 检查是否区域内所有整数都被覆盖题解： 分析： 暴力解法，用一个 right-left+1 大小的数组来记录，直接通过二重循环，依次判断ranges中的每个[start,end]中是否包含[left,right]中的任意数字，如果包含，则对应的数组的值加一，循环完毕后再次循环判断数组中是否有0，有则为false，没有返回true。 代码： 1743. 从相邻元素对还原数组题解： 分析： 将数组中的数对用字典储存，则数组头或尾中字典的list的长度只有1，然后在通过字典，一次查找下一个 代码： 704. 二分查找 2021/9/7题解： 分析： 经典二分题，将数组分成两个部分，通过判断中间数字和目标数字的大小比较，然后进入目标数字存在的部分再次进行二分查找 在进行中间下标的计算时，若直接用 (left + right)/2 会导致一些特殊情况出现问题，所以使用 (right - left)/2 + left， 或直接使用位移运算 left + right &gt;&gt; 1。 代码： 470. 用 Rand7() 实现 Rand10() 2021/9/6题解： 分析： Rand7() 有 1~7 共7种数字，49种情况，所以从1-10依次分布如下 ​ 代码： 1221. 分割平衡字符串 2021/9/7题解： 分析： 循环计算字符串中的L和R的字符个数，当两个个数相等时就表示出现一个平衡字符串，则计数器加一。 代码： 678. 有效的括号字符串 2021/9/12题解： 分析： 堆栈法： 对字符串s逐个字符进行判断，有如下三种情况 如果字符是左括号，则将其下标压入左括号栈 如果字符是星号，则将其下表压入星号栈 如果字符是右括号，则 如果左括号栈中元素不为空，则将左括号栈中顶部元素出栈 如果左括号栈中元素为空，星号栈中元素不为空，则将星号栈中顶部元素出栈 如果两个栈中元素都为空，则此右括号无匹配元素，返回false 字符串遍历完后，如果两个栈中元素都不为空，则依次将两个栈中的栈顶元素出栈，然后比较两个元素的大小，如果左括号栈的出栈下标比星号栈的出栈下标大，则表示左括号在星号的后面，无法匹配，返回false 最后判断左括号栈中的所有元素是否全部出栈，即所有左括号均有匹配，则返回true（星号可以为空字符，所以星号栈不需要做判断） 动态规划： 贪心： 代码： 447. 回旋镖的数量 2021/9/12题解： 分析： 直接三重循环依次判断三个点是否组成等边三角形，然后返回值。（严重超时） 一个回旋镖可以看作三个点组成的一个等边三角形，所以要判断是否可以放置回旋镖即判断是否可以组成等边三角形，即找到两个点到同一个点的距离相同。每多一个点到顶点的距离相同，就会多两个可摆放的回旋镖（存在位置差异，n&gt;=2），即为n的排列组合。 An = n * (n - 1) 所以我们可以采用枚举的方法，依次判断所有点到其他点的距离，并用字典储存,再在最后进行判断。 代码： 524. 通过删除字母匹配到字典里最长单词 2021/9/14题解： 分析： 题目描述不清楚，应为在第二个参数dictionary中找到最长的s的，且相同长度下字典序靠前的子字符串。 所以先将字典中的字符串按长度和字典序进行排序，然后依次判断是否为s的子串。 排序时需要先将 IList 转化为 List var list = new List(dictionary); 然后使用List的Sort方法 代码： 162. 寻找峰值 2021/9/15题解： 分析： 该题需要时间复杂度为O(log n)，所以直接循环查找行不通。 因此需要使用二分法进行查找。 在二分查找时有四种情况 nums[mid - 1] &lt; nums[mid] &lt; nums[mid + 1]，此时右边一定存在一个峰值 nums[mid - 1] &gt; nums[mid] &gt; nums[mid + 1]，此时左边一定存在一个峰值 nums[mid - 1] &gt; nums[mid] &lt; nums[mid + 1]，此时左边和右边都存在峰值 nums[mid - 1] &lt; nums[mid] &gt; nums[mid + 1]，此时mid 本生就为一个峰值 对上述四种情况进行优化，可以分为两种情况，峰值在左边（右边）和峰值在右边（左边）和中间 代码： "},{"title":"VRTK学习记录","date":"2021-06-06T11:27:43.000Z","url":"/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":[["错误总结","/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"],["经验","/tags/%E7%BB%8F%E9%AA%8C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 配置环境unity 2018.4.14VRTK 3.3.0steamVR 1.2.3 键鼠模拟基本操作 wasd控制人物移动 鼠标默认控制人物方向 alt切换控制模式 鼠标：控制人物方向 —&gt;控制左右Controller的水平位置 ctrl：按住ctrl控制Controller的垂直位置 tab切换左右Controller ctrl 切换为抓取物体模式 鼠标右键为右Controller抓取 鼠标左键为左Controller抓取 shift 奔跑 q 发出射线 鼠标右键代表Controller的扳机 基本配置 新建场景，删除原本的Camera。 simulator为键鼠模拟；steamVr为设备操作；[VRSimulator_CameraRig]是VRTK的prefab，可直接使用； RightController 为右控制器； LeftController 为左控制器； PlayArea 为需要传送时添加。 VRTK SDK 需要添加VRTK_SDKManager 组件，并将子物体simulator和steamVR添加到组件中Setups的列表中（因为只需要键鼠模拟，所以只添加了simulator），然后将左右手控制器分别添加到Scripts Aliases中。 Simulator和SteamVR需要添加VRTK_SDK Setup 组件，并将Quick Select设置为相应的模式 Controller相关控制器基本组件​ ​ ​ ​ 射线类型可以为直线(VRTK_Straight Pointer Renderer)或贝塞尔曲线(VRTK_Bezier Pointer Renderer) ​ Heighlighter …. ； VRTK_UI Pointer为ui互动所必须组件 射线与场景互动控制器上可以添加自定义脚本，使之可以与场景中的物体进行互动,脚本参考VRTK_ControllerPointerEvents_ListenerExample ​ "},{"title":"JavaScript","date":"2021-04-25T08:12:15.000Z","url":"/2021/04/25/Web/","categories":[["Web","/categories/Web/"]],"content":" 概念外部JavaScript脚本的调用：&lt;script src = &quot;../../路径&quot;&gt;&lt;/scripts&gt; NaN：not a Number 逻辑运算（&amp;&amp;）：谁在表达式中起关键性作用，结果就是谁例：true &amp;&amp; 4 &amp;&amp; “aaa”x输出 “aaa” 0 &nbsp;&nbsp; “0” &nbsp;&nbsp; “” &nbsp;&nbsp; null &nbsp;&nbsp; NaN &nbsp;&nbsp; undefined =&gt; false 用 new 创建的对象为引用类型（object） 预定义函数parseInt():将字符转化为Int eval(string):string为一个可计算的字符串或者是可执行的表达式 对象prototype可以为一个类创建一个共有的模板新new的对象会调用模板中的属性 数组cars = [“0”, 2, new Object()];//数组中的元素可以不同 joinjoin() : 将数组中的元素拼接成字符串，默认连接符为“,” splicesplice(index, howmany, [item1, … , itemx], item, …) : howmany为从index的位置开始删除元素的个数，后面的为插入的元素 sortsort(function(a,b){return b - a}); 数字的降序排列sort(function(a,b){return a - b}); 数字的升序排列 Dateunix时间戳，从1970.1.1到xxxx.xx.xx的毫秒数 Mathround() 四舍五入random() 返回0~1的随机数"},{"title":"数电","date":"2021-04-19T13:05:33.000Z","url":"/2021/04/19/%E6%95%B0%E7%94%B5/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[["数电","/categories/%E6%95%B0%E7%94%B5/"]],"content":" 第四章：组合逻辑电路编码器 译码器 选择器 \\mid \\mathrm{Y}_{1}=\\left[\\mathrm{D}_{10}\\left(\\mathrm{~A}_{1} \\mathrm{~A}_{0}^{\\prime}\\right)+\\mathrm{D}_{11}\\left(\\mathrm{~A}_{1}^{\\prime} \\mathrm{A}_{0}\\right)+\\mathrm{D}_{12}\\left(\\mathrm{~A}_{1} \\mathrm{~A}_{0}^{\\prime}\\right)+\\mathrm{D}_{13}\\left(\\mathrm{~A}_{1} \\mathrm{~A}_{0}\\right)\\right]^{*} \\mathrm{~S}_{1}加法器一位加法器 多位加法器 \\begin{array}{l} (\\boldsymbol{C I})_{i}=(\\boldsymbol{C O})_{i-1} \\\\ \\boldsymbol{S}_{i}=\\boldsymbol{A}_{i} \\oplus \\boldsymbol{B}_{i} \\oplus(\\boldsymbol{C I})_{i} \\\\ (\\boldsymbol{C O})_{i}=A_{i} \\boldsymbol{B}_{i}+\\left(\\boldsymbol{A}_{i}+\\boldsymbol{B}_{i}\\right)(\\boldsymbol{C I})_{i} \\end{array}数值比较器一位数值比较器 "},{"title":"TANKS! Unity Tutorial 项目学习记录","date":"2021-04-13T15:25:35.000Z","url":"/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":[["Unity","/tags/Unity/"],["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[["Unity","/categories/Unity/"]],"content":" APISmoothDamp平滑的改变当前值至另一个值 *current*：当前位置 *target*：尝试达到的目标值 *currentVelocity*：当前速度，该值在每次调用时都会由函数修改。 *smoothTime*：达到目标值的时间 *maxSpeed*：最大速度 *deltaTime*：默认为Time.deltatime *ref关键字*：相当于c的指针传参，及引用传参。 InverseTransformPoint 将position这个Vector3类型变量转化为 以V3的世界坐标为零点基准的情况下 position相对于V3的坐标值。 PhysicsPhysics.OverlapSphere检测范围内的Collider public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); *position*：圆心 *radius*：检测半径 *layerMask*：检测层级 *queryTriggerInteraction*：判断是否应该检测Trigger RigidbodytargetRigidbody.AddExplosionForce爆炸力将随着到物体的距离变小。 public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)); *explosionForce*：爆炸的力量（会根据距离变化） *explosionPosition*：爆炸中心 *explosionRadius*：爆炸半径 *upwardsModifier*：可以调整爆炸的位置，让物体有被炸起来向上的效果，但爆炸本身的位置不变 *ForceMode*：对物体施加力的方法 Manual相机的两种投影方式 透视投影(Perspective)(左): 正交投影的观察体是长方体，它使用一组平行投影将三维对象投影到投影平面上去，即场景中的物体没有近大远小的效果。 正交投影(Orthographic)(右): 透视投影的观察体是视锥体，它使用一组由投影中心产生的放射投影线，将三维对象投影到投影平面上去，即屏幕中的物体存在透视效果 Aodio Mixer类似于Windows的音量合成器，但更为复杂可以用来进行多种音效的混合表现要用可百度学习 问题与解决移动和旋转问题有问题的代码 此代码会导致物体旋转后会继续以世界坐标的z轴为前后方向，而导致旋转看起来不起作用，像坐标轴没有跟着旋转一样 正确的代码 修改后一切正常 Vector3.forward和transform.forward的区别 Vector3.forward的值永远是世界坐标（0,0,1），而transform.forward是世界坐标对应的物体坐标的轴的向量 代码记录相机的平滑运动 移动相关 缩放相关 炮弹的爆炸和伤害判定 爆炸相关 计算伤害 子弹的对象池模式 子弹 对象池 IPooler 学习总结游戏循环模式(协程完成) 游戏管理模式一些游戏物体的代码不需要继承MonoBehaviour（无需挂载），只当实例化后赋予其GameObject或直接更具里面的信息实例化一个物体。例如此例中的Tank 或者 一些随机地图的部分地图信息 可能的心得(……..) 协程内调用多个协程，只会在上一个协程调用完成后，下一个协程才会开始 回合制的游戏可以使用协程控制游戏流程，开始、游玩、结束，都很清晰明了 写代码时因该将所有功能块写成函数，可以让代码结构更清晰 尽量将可能的变量全定义在类的开头，理由同上 "},{"title":"部署网站的记录","date":"2021-04-13T08:56:13.000Z","url":"/2021/04/13/Demo/","tags":[["错误总结","/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"],["经验","/tags/%E7%BB%8F%E9%AA%8C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 总结网页属性 其他提示信息 折叠相关 折叠的折叠框 预先打开的折叠框 提示 提示框 type是框的类型·successs·danger·info·warning 图片插入图片需要放在source文件夹下的images下 字体颜色 color=#00ffff 颜色表参考 参考部分参考来源"}]