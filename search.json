[{"title":"Lua学习","date":"2022-08-12T02:30:23.000Z","url":"/2022/08/12/Lua%E5%AD%A6%E4%B9%A0/","tags":[["Lua","/tags/Lua/"]],"categories":[["undefined",""]],"content":" Lua5.3参考手册 语法： 变量 动态类型 弱类型 大小写敏感 默认全局 带GC 类型：nil、boolean、number、string、function、userdata(用户自定义类型)、tread、table 语句 数据结构 Table function 函数 运算符 函数库：例 协程 OO 面向对象 类的继承实现 "},{"title":"数据结构与算法","date":"2022-05-12T02:30:23.000Z","url":"/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","tags":[["C++","/tags/C/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":" 算法复杂度时间复杂度：指执行算法所需要的工作量。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，即考察输入值大小趋近无穷时的情况。 空间复杂度：指执行算法需要的内存空间 数据结构栈（Stack）：后进先出的数据结构。只能在栈顶进行添加（入栈）和删除（出栈）的操作。 应用：①撤销操作，②数组反转，③递归 队列（Queue）： 先进先出的数据结构，只能在队尾添加（入队）元素，队首删除（出队）元素。（双向队列无尾首区别） 循环队列 性能最好 应用：排队 集合（Set）：包含不重复元素的集合称为set，例如HashSet等，能快速的进行去重操作。 应用：词汇量统计 映射（Reflection）：特殊集合，例如Dictionary，存储的是键值对 应用：词汇量统计 有序数组： Rank使用二分查找找到target的对应位置，方便add 和 remove 的操作，保证数组始终有序 树：​ 二叉树（Binary Tree）：普通二叉树 ​ 满二叉树（Full Binary Tree）：除了叶子节点外都有两个节点 ​ 完全二叉树（Complete Binary Tree）：每层的节点均达到最大值，及每层的节点数为2的n-1次方个 ​ 二叉搜索树（Binary Search Tree）：每个节点左边所有节点的值均小于右边节点的值 ​ 平衡二叉树（AVL Tree）：任何节点的两颗字数的高度差小于等于1 ​ B树（B-Tree）：B树与平衡二叉树一样，但是是多叉树 ​ 红黑树（Red-Black Tree）：自平衡二叉寻找数 ​ 算法排序：升序为例 冒泡：双重循环，依次比较大小，前一个比后一个大，则交换位置，时间复杂度O(n^2) 选择：双重循环，但内循环只选出第 i 个即其之后位置的最小值，然后和第 i 个位置交换，时间复杂度O(n^2) 快排：以第一个数为界 记flag，从前往后找出第一个比flag大的值，从后往前，找出第一个比flag小的数，然后交换两个数的位置。直到找到flag的位置，然后递归查找flag的左侧和右侧的中间值 时间复杂度O(n log2 n) 不能对存在重复元素的数组进行排序 若快排前数组有序，则时间复杂度为O(n^2) 排序前可以将第一个元素与中间或随机元素进行交换，可优化时间复杂度 三路快排：有重复元素的快速排序 ，即相比上一个方法，多了等于flag的情况 即将数组中的元素分为三个区域，大于[gt, right] 小于[l+1, lt]和等于选定值flag的情况 i 指向当前元素 若 i 指向元素等于flag，则i++； 若 i 指向元素小于flag，则将 it + 1 指向的值与 i 交换，然后 it++、i++。即将小于flag的区域增1，且等于flag的区域右移1. 若 i 指向的元素大于flag， 则将 gt - 1 指向的元素与 i 交换，然后 gt—。即将大于flag的区域向后增1，其余区域不变 当 i 指向 gt 时，表示遍历完成，此时只需将 flag 除的值与 lt 处的值进行交换，则三个区间形成，然后继续遍历大于flag和小于flag的区域 归并：采用分治法，先使子序列有序，然后将两个有序子序列合并，得到有序序列。即先将输入序列分成n/2个子序列，对这两个子序列分别采用归并排序，将两个排序好的子序列合并成排序序列，时间复杂度O(nlogn) 堆： 桶： 查找： 顺序查找O(n)：遍历所有数据，进行处理 二分查找O(log n)：对有序数组进行分半查找，每次为对比中间数据，然后根据大小关系，对前半部分或后半部分进行对比。 递归(recursion)： 程序调用自身的编程技巧称为递归，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解.。递归需要有边界条件、递归前进段和递归返回段。 并查集 定义：在一些有N个元素的集合应用问题中，通常在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。 主要用于解决一些元素分组的问题，用于管理一系列不相交的集合并存在两种操作： 查找(Find):查询两个元素是否在同一个集合中； 合并(Union):把两个不相交的集合合并成一个集合。 最简单版本的并查集代码： 直接合并可能会导致每次查询的路径过长，而增加时间消耗，因此，存在两个方面对算法进行优化 路径压缩：在查询过程中把沿途的每个节点的父节点全部设置为根节点 按秩合并：用rank[]数组记录每个根节点对应的深度。初始化为1。合并时把rank较小的合并在较大的根节点上 路径压缩和按秩合并如果一起使用，时间复杂度接近 ，但是很可能会破坏rank的准确性。 "},{"title":"剑指offer","date":"2021-09-16T08:45:47.000Z","url":"/2021/09/16/%E5%89%91%E6%8C%87offer/","tags":[["c++","/tags/c/"]],"categories":[["c++","/categories/c/"]],"content":" 链表 链表反转： 开始先设定三个指针，并进行初始化，如图 并将Pre的指向的Next指向NULL 开始循环，head指针后移，让Cur指针的Next指向Pre，然后使Pre = Cur，Cur = Head。直到链表尾 二分法模板： 广度优先遍历（BFS） 深度优先遍历（DFS） 例题：剑指 Offer 12. 矩阵中的路径 用dfs深度遍历加回溯法。 字符串 清除字符串前后的空格符号 二叉树​ 前序遍历：优先遍历根节点，然后是左子节点，再是右子节点 ​ A-B-D-F-G-H-I-E-C 中序遍历：优先遍历左子节点，然后是根节点，再是右子节点 ​ F-D-H-G-I-B-E-A-C 后序遍历：优先遍历左子节点，然后是右子节点，再是根节点 ​ F-H-I-G-D-E-B-C-A 二叉树转化成双向链表：用中序遍历 数据结构 优先队列：priority_queue 包含在头文件 ‘queue’ 中,我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队. 优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的 二叉搜索树：Binary Search Tree 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 中序遍历得到的结果使有序的 算法 分组位运算：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 相同数字异或为零 "},{"title":"FSM状态机","date":"2021-07-29T11:36:24.000Z","url":"/2021/07/29/FSM%E7%8A%B6%E6%80%81%E6%9C%BA/","tags":[["unity","/tags/unity/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 介绍FSM是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的机器。 是一种设计模式 代码设计 "},{"title":"3D RPG 学习笔记","date":"2021-07-23T07:38:31.000Z","url":"/2021/07/23/3D-RPG-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["unity","/tags/unity/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 一、创建项目导入素材 创建普通项目 在Package Manager中安装Universal RP 在Asset中创建Rendering =&gt; Universal Render Pipeline =&gt; Pipeline Asset(URP的设置文件) 将project setting中Graphics和Quality的渲染管线设置为刚创建的渲染管线设置文件 导入素材（Dog Knight PBR Polyart、 Low-Poly Simple Nature Pack 和 FREE Skybox Extended Shader） 在Edit =&gt; Edit=Render Pipeline =&gt; Universal Render Pipeline 中设置当前项目或当前素材的渲染管线 在Lighting =&gt; Environment 中设置天空盒的材质 注意Asset窗口和Inspect窗口的物体分类，方便管理 安装package PolyBrush 调整地面的高度(左键直接点击变高，control+左键点击变矮) Outer Radius：外圈大小 Inner Radius：内圈大小 Strength：变化强度 Direction：设置变化的方向。Brush normal：材质的法线方向 Brush Mirroring：沿坐标轴对称形成另一个笔刷同时进行相同操作 柔化：将比较突出的棱角变的平滑。设置基本同上 将当前物体刷上不同的颜色 如果需要将颜色刷到物体上，则物体材质的 shader 需要为 Polybrush=&gt; Shader 下的shader Brush：根据笔刷的大小刷上颜色 Fill：填充区块 Flood：整个物体 将预制体刷到场景当中 基本设置同1 将需要的prefab添加到Current Palette中，当前选中的prefab会在Brush Loadout中 Brush Loadout 中prefab下的拖动条表示此物体出现的概率 Hit Surface is Parent：将所有的画在平面上的物体都是此平面的子物体 将texture刷到场景当中 同4 Pro Builder 按住shift可以查看图标的功能 Pro Grids 安装ProGrids需要在Project Setting的Package Manger中打开允许preview 设置物体移动时的单位距离 是否在Scene窗口中显示坐标轴 是否自动吸附：即按照1的设置在坐标轴上自动进行吸附，每次只移动1的距离 4 5 X 、Y、 Z、 3D均为Scene窗口显示的坐标轴 Navigation自动导航 点击移动 自定义事件的注册和调用 注册 调用 屏幕射线转为世界射线 单例模式 方便事件函数等在外部的调用 事件注册和调用 功能实现 鼠标指针图片切换 Cinemachine：多功能相机插件 Post Processing：后处理 Animator Shader Graph 遮挡剔除 FSM 状态机 "},{"title":"每日一题","date":"2021-07-19T07:49:14.000Z","url":"/2021/07/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","tags":[["C#","/tags/C/"],["Leetcode","/tags/Leetcode/"]],"categories":[["每日一题","/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"]],"content":" 面试题 10.02. 变位词组编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串 示例： 说明： 所有输入均为小写字母。 不考虑答案输出的顺序 题解： 思路：计数法。 计算每个字符串中所有字符出现的个数，将相同的放在同一个list中，完成分类 代码： 1877. 数组中最大数对和的最小值题解： 分析： 最大与最小相加产生的数对和最小，即第k大的数和第k小的数相加，所得的最大数对和最小. 所以先将数组进行排序，然后依次下相加比较，即得出结果 代码： 1893. 检查是否区域内所有整数都被覆盖题解： 分析： 暴力解法，用一个 right-left+1 大小的数组来记录，直接通过二重循环，依次判断ranges中的每个[start,end]中是否包含[left,right]中的任意数字，如果包含，则对应的数组的值加一，循环完毕后再次循环判断数组中是否有0，有则为false，没有返回true。 代码： 1743. 从相邻元素对还原数组题解： 分析： 将数组中的数对用字典储存，则数组头或尾中字典的list的长度只有1，然后在通过字典，一次查找下一个 代码： 704. 二分查找 2021/9/7题解： 分析： 经典二分题，将数组分成两个部分，通过判断中间数字和目标数字的大小比较，然后进入目标数字存在的部分再次进行二分查找 在进行中间下标的计算时，若直接用 (left + right)/2 会导致一些特殊情况出现问题，所以使用 (right - left)/2 + left， 或直接使用位移运算 left + right &gt;&gt; 1。 代码： 470. 用 Rand7() 实现 Rand10() 2021/9/6题解： 分析： Rand7() 有 1~7 共7种数字，49种情况，所以从1-10依次分布如下 ​ 代码： 1221. 分割平衡字符串 2021/9/7题解： 分析： 循环计算字符串中的L和R的字符个数，当两个个数相等时就表示出现一个平衡字符串，则计数器加一。 代码： 678. 有效的括号字符串 2021/9/12题解： 分析： 堆栈法： 对字符串s逐个字符进行判断，有如下三种情况 如果字符是左括号，则将其下标压入左括号栈 如果字符是星号，则将其下表压入星号栈 如果字符是右括号，则 如果左括号栈中元素不为空，则将左括号栈中顶部元素出栈 如果左括号栈中元素为空，星号栈中元素不为空，则将星号栈中顶部元素出栈 如果两个栈中元素都为空，则此右括号无匹配元素，返回false 字符串遍历完后，如果两个栈中元素都不为空，则依次将两个栈中的栈顶元素出栈，然后比较两个元素的大小，如果左括号栈的出栈下标比星号栈的出栈下标大，则表示左括号在星号的后面，无法匹配，返回false 最后判断左括号栈中的所有元素是否全部出栈，即所有左括号均有匹配，则返回true（星号可以为空字符，所以星号栈不需要做判断） 动态规划： 贪心： 代码： 447. 回旋镖的数量 2021/9/12题解： 分析： 直接三重循环依次判断三个点是否组成等边三角形，然后返回值。（严重超时） 一个回旋镖可以看作三个点组成的一个等边三角形，所以要判断是否可以放置回旋镖即判断是否可以组成等边三角形，即找到两个点到同一个点的距离相同。每多一个点到顶点的距离相同，就会多两个可摆放的回旋镖（存在位置差异，n&gt;=2），即为n的排列组合。 An = n * (n - 1) 所以我们可以采用枚举的方法，依次判断所有点到其他点的距离，并用字典储存,再在最后进行判断。 代码： 524. 通过删除字母匹配到字典里最长单词 2021/9/14题解： 分析： 题目描述不清楚，应为在第二个参数dictionary中找到最长的s的，且相同长度下字典序靠前的子字符串。 所以先将字典中的字符串按长度和字典序进行排序，然后依次判断是否为s的子串。 排序时需要先将 IList 转化为 List var list = new List(dictionary); 然后使用List的Sort方法 代码： 162. 寻找峰值 2021/9/15题解： 分析： 该题需要时间复杂度为O(log n)，所以直接循环查找行不通。 因此需要使用二分法进行查找。 在二分查找时有四种情况 nums[mid - 1] &lt; nums[mid] &lt; nums[mid + 1]，此时右边一定存在一个峰值 nums[mid - 1] &gt; nums[mid] &gt; nums[mid + 1]，此时左边一定存在一个峰值 nums[mid - 1] &gt; nums[mid] &lt; nums[mid + 1]，此时左边和右边都存在峰值 nums[mid - 1] &lt; nums[mid] &gt; nums[mid + 1]，此时mid 本生就为一个峰值 对上述四种情况进行优化，可以分为两种情况，峰值在左边（右边）和峰值在右边（左边）和中间 代码： "},{"title":"VRTK学习记录","date":"2021-06-06T11:27:43.000Z","url":"/2021/06/06/VRTK%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":[["错误总结","/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"],["经验","/tags/%E7%BB%8F%E9%AA%8C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 配置环境unity 2018.4.14VRTK 3.3.0steamVR 1.2.3 键鼠模拟基本操作 wasd控制人物移动 鼠标默认控制人物方向 alt切换控制模式 鼠标：控制人物方向 —&gt;控制左右Controller的水平位置 ctrl：按住ctrl控制Controller的垂直位置 tab切换左右Controller ctrl 切换为抓取物体模式 鼠标右键为右Controller抓取 鼠标左键为左Controller抓取 shift 奔跑 q 发出射线 鼠标右键代表Controller的扳机 基本配置 新建场景，删除原本的Camera。 simulator为键鼠模拟；steamVr为设备操作；[VRSimulator_CameraRig]是VRTK的prefab，可直接使用； RightController 为右控制器； LeftController 为左控制器； PlayArea 为需要传送时添加。 VRTK SDK 需要添加VRTK_SDKManager 组件，并将子物体simulator和steamVR添加到组件中Setups的列表中（因为只需要键鼠模拟，所以只添加了simulator），然后将左右手控制器分别添加到Scripts Aliases中。 Simulator和SteamVR需要添加VRTK_SDK Setup 组件，并将Quick Select设置为相应的模式 Controller相关控制器基本组件​ ​ ​ ​ 射线类型可以为直线(VRTK_Straight Pointer Renderer)或贝塞尔曲线(VRTK_Bezier Pointer Renderer) ​ Heighlighter …. ； VRTK_UI Pointer为ui互动所必须组件 射线与场景互动控制器上可以添加自定义脚本，使之可以与场景中的物体进行互动,脚本参考VRTK_ControllerPointerEvents_ListenerExample ​ "},{"title":"JavaScript","date":"2021-04-25T08:12:15.000Z","url":"/2021/04/25/Web/","categories":[["Web","/categories/Web/"]],"content":" 概念外部JavaScript脚本的调用：&lt;script src = &quot;../../路径&quot;&gt;&lt;/scripts&gt; NaN：not a Number 逻辑运算（&amp;&amp;）：谁在表达式中起关键性作用，结果就是谁例：true &amp;&amp; 4 &amp;&amp; “aaa”x输出 “aaa” 0 &nbsp;&nbsp; “0” &nbsp;&nbsp; “” &nbsp;&nbsp; null &nbsp;&nbsp; NaN &nbsp;&nbsp; undefined =&gt; false 用 new 创建的对象为引用类型（object） 预定义函数parseInt():将字符转化为Int eval(string):string为一个可计算的字符串或者是可执行的表达式 对象prototype可以为一个类创建一个共有的模板新new的对象会调用模板中的属性 数组cars = [“0”, 2, new Object()];//数组中的元素可以不同 joinjoin() : 将数组中的元素拼接成字符串，默认连接符为“,” splicesplice(index, howmany, [item1, … , itemx], item, …) : howmany为从index的位置开始删除元素的个数，后面的为插入的元素 sortsort(function(a,b){return b - a}); 数字的降序排列sort(function(a,b){return a - b}); 数字的升序排列 Dateunix时间戳，从1970.1.1到xxxx.xx.xx的毫秒数 Mathround() 四舍五入random() 返回0~1的随机数"},{"title":"数电","date":"2021-04-19T13:05:33.000Z","url":"/2021/04/19/%E6%95%B0%E7%94%B5/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[["数电","/categories/%E6%95%B0%E7%94%B5/"]],"content":" 第四章：组合逻辑电路编码器 译码器 选择器 \\mid \\mathrm{Y}_{1}=\\left[\\mathrm{D}_{10}\\left(\\mathrm{~A}_{1} \\mathrm{~A}_{0}^{\\prime}\\right)+\\mathrm{D}_{11}\\left(\\mathrm{~A}_{1}^{\\prime} \\mathrm{A}_{0}\\right)+\\mathrm{D}_{12}\\left(\\mathrm{~A}_{1} \\mathrm{~A}_{0}^{\\prime}\\right)+\\mathrm{D}_{13}\\left(\\mathrm{~A}_{1} \\mathrm{~A}_{0}\\right)\\right]^{*} \\mathrm{~S}_{1}加法器一位加法器 多位加法器 \\begin{array}{l} (\\boldsymbol{C I})_{i}=(\\boldsymbol{C O})_{i-1} \\\\ \\boldsymbol{S}_{i}=\\boldsymbol{A}_{i} \\oplus \\boldsymbol{B}_{i} \\oplus(\\boldsymbol{C I})_{i} \\\\ (\\boldsymbol{C O})_{i}=A_{i} \\boldsymbol{B}_{i}+\\left(\\boldsymbol{A}_{i}+\\boldsymbol{B}_{i}\\right)(\\boldsymbol{C I})_{i} \\end{array}数值比较器一位数值比较器 "},{"title":"TANKS! Unity Tutorial 项目学习记录","date":"2021-04-13T15:25:35.000Z","url":"/2021/04/13/Tanks%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":[["Unity","/tags/Unity/"],["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[["Unity","/categories/Unity/"]],"content":" APISmoothDamp平滑的改变当前值至另一个值 *current*：当前位置 *target*：尝试达到的目标值 *currentVelocity*：当前速度，该值在每次调用时都会由函数修改。 *smoothTime*：达到目标值的时间 *maxSpeed*：最大速度 *deltaTime*：默认为Time.deltatime *ref关键字*：相当于c的指针传参，及引用传参。 InverseTransformPoint 将position这个Vector3类型变量转化为 以V3的世界坐标为零点基准的情况下 position相对于V3的坐标值。 PhysicsPhysics.OverlapSphere检测范围内的Collider public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); *position*：圆心 *radius*：检测半径 *layerMask*：检测层级 *queryTriggerInteraction*：判断是否应该检测Trigger RigidbodytargetRigidbody.AddExplosionForce爆炸力将随着到物体的距离变小。 public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)); *explosionForce*：爆炸的力量（会根据距离变化） *explosionPosition*：爆炸中心 *explosionRadius*：爆炸半径 *upwardsModifier*：可以调整爆炸的位置，让物体有被炸起来向上的效果，但爆炸本身的位置不变 *ForceMode*：对物体施加力的方法 Manual相机的两种投影方式 透视投影(Perspective)(左): 正交投影的观察体是长方体，它使用一组平行投影将三维对象投影到投影平面上去，即场景中的物体没有近大远小的效果。 正交投影(Orthographic)(右): 透视投影的观察体是视锥体，它使用一组由投影中心产生的放射投影线，将三维对象投影到投影平面上去，即屏幕中的物体存在透视效果 Aodio Mixer类似于Windows的音量合成器，但更为复杂可以用来进行多种音效的混合表现要用可百度学习 问题与解决移动和旋转问题有问题的代码 此代码会导致物体旋转后会继续以世界坐标的z轴为前后方向，而导致旋转看起来不起作用，像坐标轴没有跟着旋转一样 正确的代码 修改后一切正常 Vector3.forward和transform.forward的区别 Vector3.forward的值永远是世界坐标（0,0,1），而transform.forward是世界坐标对应的物体坐标的轴的向量 代码记录相机的平滑运动 移动相关 缩放相关 炮弹的爆炸和伤害判定 爆炸相关 计算伤害 子弹的对象池模式 子弹 对象池 IPooler 学习总结游戏循环模式(协程完成) 游戏管理模式一些游戏物体的代码不需要继承MonoBehaviour（无需挂载），只当实例化后赋予其GameObject或直接更具里面的信息实例化一个物体。例如此例中的Tank 或者 一些随机地图的部分地图信息 可能的心得(……..) 协程内调用多个协程，只会在上一个协程调用完成后，下一个协程才会开始 回合制的游戏可以使用协程控制游戏流程，开始、游玩、结束，都很清晰明了 写代码时因该将所有功能块写成函数，可以让代码结构更清晰 尽量将可能的变量全定义在类的开头，理由同上 "},{"title":"部署网站的记录","date":"2021-04-13T08:56:13.000Z","url":"/2021/04/13/Demo/","tags":[["错误总结","/tags/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"],["经验","/tags/%E7%BB%8F%E9%AA%8C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":" 总结网页属性 其他提示信息 折叠相关 折叠的折叠框 预先打开的折叠框 提示 提示框 type是框的类型·successs·danger·info·warning 图片插入图片需要放在source文件夹下的images下 字体颜色 color=#00ffff 颜色表参考 参考部分参考来源"}]